# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _function.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_function', [dirname(__file__)])
        except ImportError:
            import _function
            return _function
        if fp is not None:
            try:
                _mod = imp.load_module('_function', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _function = swig_import_helper()
    del swig_import_helper
else:
    import _function
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0



def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except Exception:
    weakref_proxy = lambda x: x



_function.SHARED_PTR_DISOWN_swigconstant(_function)
SHARED_PTR_DISOWN = _function.SHARED_PTR_DISOWN
import ufc

def _attach_base_to_numpy_array(obj, owner):
    return _function._attach_base_to_numpy_array(obj, owner)
_attach_base_to_numpy_array = _function._attach_base_to_numpy_array

def dolfin_swigversion():
    return _function.dolfin_swigversion()
dolfin_swigversion = _function.dolfin_swigversion

def dolfin_pythonversion():
    return _function.dolfin_pythonversion()
dolfin_pythonversion = _function.dolfin_pythonversion

tmp = hex(dolfin_swigversion())
__swigversion__ = "%d.%d.%d"%(tuple(map(int, [tmp[-5], tmp[-3], tmp[-2:]])))
tmp = hex(dolfin_pythonversion())
__pythonversion__ = "%d.%d.%d"%(tuple(map(lambda x: int(x,16), [tmp[2], tmp[3:5], tmp[5:7]])))
del tmp, dolfin_pythonversion, dolfin_swigversion


def has_petsc4py():
    return _function.has_petsc4py()
has_petsc4py = _function.has_petsc4py

def has_slepc4py():
    return _function.has_slepc4py()
has_slepc4py = _function.has_slepc4py
import common
class HierarchicalMesh(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, arg2):
        _function.HierarchicalMesh_swiginit(self, _function.new_HierarchicalMesh(arg2))
    __swig_destroy__ = _function.delete_HierarchicalMesh
HierarchicalMesh.depth = new_instancemethod(_function.HierarchicalMesh_depth, None, HierarchicalMesh)
HierarchicalMesh.has_parent = new_instancemethod(_function.HierarchicalMesh_has_parent, None, HierarchicalMesh)
HierarchicalMesh.has_child = new_instancemethod(_function.HierarchicalMesh_has_child, None, HierarchicalMesh)
HierarchicalMesh._parent = new_instancemethod(_function.HierarchicalMesh__parent, None, HierarchicalMesh)
HierarchicalMesh._child = new_instancemethod(_function.HierarchicalMesh__child, None, HierarchicalMesh)
HierarchicalMesh._root_node = new_instancemethod(_function.HierarchicalMesh__root_node, None, HierarchicalMesh)
HierarchicalMesh._leaf_node = new_instancemethod(_function.HierarchicalMesh__leaf_node, None, HierarchicalMesh)
HierarchicalMesh.set_parent = new_instancemethod(_function.HierarchicalMesh_set_parent, None, HierarchicalMesh)
HierarchicalMesh.clear_child = new_instancemethod(_function.HierarchicalMesh_clear_child, None, HierarchicalMesh)
HierarchicalMesh.set_child = new_instancemethod(_function.HierarchicalMesh_set_child, None, HierarchicalMesh)
HierarchicalMesh._debug = new_instancemethod(_function.HierarchicalMesh__debug, None, HierarchicalMesh)
HierarchicalMesh_swigregister = _function.HierarchicalMesh_swigregister
HierarchicalMesh_swigregister(HierarchicalMesh)

import mesh
import la
class HierarchicalFunctionSpace(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, arg2):
        _function.HierarchicalFunctionSpace_swiginit(self, _function.new_HierarchicalFunctionSpace(arg2))
    __swig_destroy__ = _function.delete_HierarchicalFunctionSpace
HierarchicalFunctionSpace.depth = new_instancemethod(_function.HierarchicalFunctionSpace_depth, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace.has_parent = new_instancemethod(_function.HierarchicalFunctionSpace_has_parent, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace.has_child = new_instancemethod(_function.HierarchicalFunctionSpace_has_child, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace._parent = new_instancemethod(_function.HierarchicalFunctionSpace__parent, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace._child = new_instancemethod(_function.HierarchicalFunctionSpace__child, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace._root_node = new_instancemethod(_function.HierarchicalFunctionSpace__root_node, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace._leaf_node = new_instancemethod(_function.HierarchicalFunctionSpace__leaf_node, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace.set_parent = new_instancemethod(_function.HierarchicalFunctionSpace_set_parent, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace.clear_child = new_instancemethod(_function.HierarchicalFunctionSpace_clear_child, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace.set_child = new_instancemethod(_function.HierarchicalFunctionSpace_set_child, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace._debug = new_instancemethod(_function.HierarchicalFunctionSpace__debug, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace_swigregister = _function.HierarchicalFunctionSpace_swigregister
HierarchicalFunctionSpace_swigregister(HierarchicalFunctionSpace)

class HierarchicalFunction(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, arg2):
        _function.HierarchicalFunction_swiginit(self, _function.new_HierarchicalFunction(arg2))
    __swig_destroy__ = _function.delete_HierarchicalFunction
HierarchicalFunction.depth = new_instancemethod(_function.HierarchicalFunction_depth, None, HierarchicalFunction)
HierarchicalFunction.has_parent = new_instancemethod(_function.HierarchicalFunction_has_parent, None, HierarchicalFunction)
HierarchicalFunction.has_child = new_instancemethod(_function.HierarchicalFunction_has_child, None, HierarchicalFunction)
HierarchicalFunction._parent = new_instancemethod(_function.HierarchicalFunction__parent, None, HierarchicalFunction)
HierarchicalFunction._child = new_instancemethod(_function.HierarchicalFunction__child, None, HierarchicalFunction)
HierarchicalFunction._root_node = new_instancemethod(_function.HierarchicalFunction__root_node, None, HierarchicalFunction)
HierarchicalFunction._leaf_node = new_instancemethod(_function.HierarchicalFunction__leaf_node, None, HierarchicalFunction)
HierarchicalFunction.set_parent = new_instancemethod(_function.HierarchicalFunction_set_parent, None, HierarchicalFunction)
HierarchicalFunction.clear_child = new_instancemethod(_function.HierarchicalFunction_clear_child, None, HierarchicalFunction)
HierarchicalFunction.set_child = new_instancemethod(_function.HierarchicalFunction_set_child, None, HierarchicalFunction)
HierarchicalFunction._debug = new_instancemethod(_function.HierarchicalFunction__debug, None, HierarchicalFunction)
HierarchicalFunction_swigregister = _function.HierarchicalFunction_swigregister
HierarchicalFunction_swigregister(HierarchicalFunction)

class GenericFunction(ufc.function, common.Variable):
    """

    This is a common base class for functions. Functions can be
    evaluated at a given point and they can be restricted to a given
    cell in a finite element mesh. This functionality is implemented
    by sub-classes that implement the eval() and restrict() functions.

    DOLFIN provides two implementations of the GenericFunction
    interface in the form of the classes Function and Expression.

    Sub-classes may optionally implement the update() function that
    will be called prior to restriction when running in parallel.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _function.delete_GenericFunction

    def value_rank(self):
        """

        Return value rank

        """
        return _function.GenericFunction_value_rank(self)


    def value_dimension(self, i):
        """

        Return value dimension for given axis

        """
        return _function.GenericFunction_value_dimension(self, i)


    def eval_cell(self, values, x, cell):
        """

        **Overloaded versions**

        * eval\ (values, x, cell)

          Evaluate at given point in given cell

        * eval\ (values, x)

          Evaluate at given point

        """
        return _function.GenericFunction_eval_cell(self, values, x, cell)


    def eval(self, values, x):
        """

        **Overloaded versions**

        * eval\ (values, x, cell)

          Evaluate at given point in given cell

        * eval\ (values, x)

          Evaluate at given point

        """
        return _function.GenericFunction_eval(self, values, x)


    def restrict(self, w, element, dolfin_cell, vertex_coordinates, ufc_cell):
        """

        Restrict function to local cell (compute expansion coefficients w)

        """
        return _function.GenericFunction_restrict(self, w, element, dolfin_cell, vertex_coordinates, ufc_cell)


    def compute_vertex_values(self, mesh):
        """

        Compute values at all mesh vertices

        """
        return _function.GenericFunction_compute_vertex_values(self, mesh)


    def update(self):
        """

        Update off-process ghost coefficients

        """
        return _function.GenericFunction_update(self)


    def value_size(self):
        """

        Evaluation at given point
        Return value size (product of value dimensions)

        """
        return _function.GenericFunction_value_size(self)

GenericFunction.value_rank = new_instancemethod(_function.GenericFunction_value_rank, None, GenericFunction)
GenericFunction.value_dimension = new_instancemethod(_function.GenericFunction_value_dimension, None, GenericFunction)
GenericFunction.eval_cell = new_instancemethod(_function.GenericFunction_eval_cell, None, GenericFunction)
GenericFunction.eval = new_instancemethod(_function.GenericFunction_eval, None, GenericFunction)
GenericFunction.restrict = new_instancemethod(_function.GenericFunction_restrict, None, GenericFunction)
GenericFunction.compute_vertex_values = new_instancemethod(_function.GenericFunction_compute_vertex_values, None, GenericFunction)
GenericFunction.update = new_instancemethod(_function.GenericFunction_update, None, GenericFunction)
GenericFunction.value_size = new_instancemethod(_function.GenericFunction_value_size, None, GenericFunction)
GenericFunction_swigregister = _function.GenericFunction_swigregister
GenericFunction_swigregister(GenericFunction)

class Expression(GenericFunction):
    """

    This class represents a user-defined expression. Expressions can
    be used as coefficients in variational forms or interpolated
    into finite element spaces.

    An expression is defined by overloading the eval() method. Users
    may choose to overload either a simple version of eval(), in the
    case of expressions only depending on the coordinate x, or an
    optional version for expressions depending on x and mesh data
    like cell indices or facet normals.

    The geometric dimension (the size of x) and the value rank and
    dimensions of an expression must supplied as arguments to the
    constructor.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * Expression\ ()

          Create scalar expression.

        * Expression\ (dim)

          Create vector-valued expression with given dimension.

          *Arguments*
              dim (int)
                  Dimension of the vector-valued expression.

        * Expression\ (dim0, dim1)

          Create matrix-valued expression with given dimensions.

          *Arguments*
              dim0 (int)
                  Dimension (rows).
              dim1 (int)
                  Dimension (columns).

        * Expression\ (value_shape)

          Create tensor-valued expression with given shape.

          *Arguments*
              value_shape (numpy.array(int))
                  Shape of expression.

        * Expression\ (expression)

          Copy constructor

          *Arguments*
              expression (:py:class:`Expression`)
                  Object to be copied.

        """
        if self.__class__ == Expression:
            _self = None
        else:
            _self = self
        _function.Expression_swiginit(self, _function.new_Expression(_self, *args))
    __swig_destroy__ = _function.delete_Expression

    def eval_cell(self, values, x, cell):
        """

        **Overloaded versions**

        * eval\ (values, x, cell)

          Note: The reimplementation of eval is needed for the Python interface.
          Evaluate at given point in given cell.

          *Arguments*
              values (numpy.array(float))
                  The values at the point.
              x (numpy.array(float))
                  The coordinates of the point.
              cell (ufc::cell)
                  The cell which contains the given point.

        * eval\ (values, x)

          Evaluate at given point.

          *Arguments*
              values (numpy.array(float))
                  The values at the point.
              x (numpy.array(float))
                  The coordinates of the point.

        """
        return _function.Expression_eval_cell(self, values, x, cell)


    def eval(self, values, x):
        """

        **Overloaded versions**

        * eval\ (values, x, cell)

          Note: The reimplementation of eval is needed for the Python interface.
          Evaluate at given point in given cell.

          *Arguments*
              values (numpy.array(float))
                  The values at the point.
              x (numpy.array(float))
                  The coordinates of the point.
              cell (ufc::cell)
                  The cell which contains the given point.

        * eval\ (values, x)

          Evaluate at given point.

          *Arguments*
              values (numpy.array(float))
                  The values at the point.
              x (numpy.array(float))
                  The coordinates of the point.

        """
        return _function.Expression_eval(self, values, x)

    def __disown__(self):
        self.this.disown()
        _function.disown_Expression(self)
        return weakref_proxy(self)
Expression.eval_cell = new_instancemethod(_function.Expression_eval_cell, None, Expression)
Expression.eval = new_instancemethod(_function.Expression_eval, None, Expression)
Expression_swigregister = _function.Expression_swigregister
Expression_swigregister(Expression)

class FunctionAXPY(object):
    """

    This class represents a linear combination of functions. It is
    mostly used as an intermediate class for operations such as u =
    3*u0 + 4*u1; where the rhs generates an FunctionAXPY.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    ADD_ADD = _function.FunctionAXPY_ADD_ADD
    SUB_ADD = _function.FunctionAXPY_SUB_ADD
    ADD_SUB = _function.FunctionAXPY_ADD_SUB
    SUB_SUB = _function.FunctionAXPY_SUB_SUB

    def __init__(self, *args):
        """

        **Overloaded versions**

        * FunctionAXPY\ (func, scalar)

          Constructor

        * FunctionAXPY\ (axpy, scalar)

          Constructor

        * FunctionAXPY\ (func0, func1, direction)

          Constructor

        * FunctionAXPY\ (axpy, func, direction)

          Constructor

        * FunctionAXPY\ (axpy0, axpy1, direction)

          Constructor

        * FunctionAXPY\ (pairs)

          Constructor

        * FunctionAXPY\ (axpy)

          Copy constructor

        """
        _function.FunctionAXPY_swiginit(self, _function.new_FunctionAXPY(*args))

    def __add__(self, *args):
        """

        **Overloaded versions**

        * operator+\ (func)

          Addition operator

        * operator+\ (axpy)

          Addition operator

        """
        return _function.FunctionAXPY___add__(self, *args)


    def __sub__(self, *args):
        """

        **Overloaded versions**

        * operator-\ (func)

          Subtraction operator

        * operator-\ (axpy)

          Subtraction operator

        """
        return _function.FunctionAXPY___sub__(self, *args)


    def __mul__(self, scale):
        """

        Scale operator

        """
        return _function.FunctionAXPY___mul__(self, scale)


    def __div__(self, scale):
        """

        Scale operator

        """
        return _function.FunctionAXPY___div__(self, scale)


    def pairs(self):
        """

        Return the scalar and Function pairs

        """
        return _function.FunctionAXPY_pairs(self)


    __truediv__ = __div__

    __swig_destroy__ = _function.delete_FunctionAXPY
FunctionAXPY.__add__ = new_instancemethod(_function.FunctionAXPY___add__, None, FunctionAXPY)
FunctionAXPY.__sub__ = new_instancemethod(_function.FunctionAXPY___sub__, None, FunctionAXPY)
FunctionAXPY.__mul__ = new_instancemethod(_function.FunctionAXPY___mul__, None, FunctionAXPY)
FunctionAXPY.__div__ = new_instancemethod(_function.FunctionAXPY___div__, None, FunctionAXPY)
FunctionAXPY.pairs = new_instancemethod(_function.FunctionAXPY_pairs, None, FunctionAXPY)
FunctionAXPY_swigregister = _function.FunctionAXPY_swigregister
FunctionAXPY_swigregister(FunctionAXPY)

class Function(GenericFunction, HierarchicalFunction):
    """

    This class represents a function :math:`u_h` in a finite
    element function space :math:`V_h`, given by

    .. math::

        u_h = \sum_{i=1}^{n} U_i \phi_i

    where :math:`\{\phi_i\}_{i=1}^{n}` is a basis for :math:`V_h`,
    and :math:`U` is a vector of expansion coefficients for :math:`u_h`.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * Function\ (V)

          Create function on given function space

          *Arguments*
              V (:py:class:`FunctionSpace`)
                  The function space.

          *Example*
              .. note::

                  No example code available for this function.

        * Function\ (V)

          Create function on given function space (shared data)

          *Arguments*
              V (:py:class:`FunctionSpace`)
                  The function space.

        * Function\ (V, x)

          Create function on given function space with a given vector
          (shared data)

          *Warning: This constructor is intended for internal library use only*

          *Arguments*
              V (:py:class:`FunctionSpace`)
                  The function space.
              x (:py:class:`GenericVector`)
                  The vector.

        * Function\ (V, filename)

          Create function from vector of dofs stored to file

          *Arguments*
              V (:py:class:`FunctionSpace`)
                  The function space.
              filename_vector (str)
                  The name of the file containing the vector.
              filename_dofdata (str)
                  The name of the file containing the dofmap data.

        * Function\ (V, filename)

          Create function from vector of dofs stored to file (shared data)

          *Arguments*
              V (:py:class:`FunctionSpace`)
                  The function space.
              filename_dofdata (str)
                  The name of the file containing the dofmap data.

        * Function\ (v)

          Copy constructor

          *Arguments*
              v (:py:class:`Function`)
                  The object to be copied.

        * Function\ (v, i)

          Sub-function constructor with shallow copy of vector (used in Python
          interface)

          *Arguments*
              v (:py:class:`Function`)
                  The function to be copied.
              i (int)
                  Index of subfunction.


        """
        _function.Function_swiginit(self, _function.new_Function(*args))
    __swig_destroy__ = _function.delete_Function

    def _assign(self, *args):
        """

        **Overloaded versions**

        * operator=\ (v)

          Assignment from function

          *Arguments*
              v (:py:class:`Function`)
                  Another function.

        * operator=\ (v)

          Assignment from expression using interpolation

          *Arguments*
              v (:py:class:`Expression`)
                  The expression.

        * operator=\ (axpy)

          Assignment from linear combination of function

          *Arguments*
              v (:py:class:`FunctionAXPY`)
                  A linear combination of other Functions

        """
        return _function.Function__assign(self, *args)


    def sub(self, i):
        """

        Extract subfunction

        *Arguments*
            i (int)
                Index of subfunction.
        *Returns*
            :py:class:`Function`
                The subfunction.

        """
        return _function.Function_sub(self, i)


    def __add__(self, *args):
        """

        **Overloaded versions**

        * operator+\ (other)

          Add operator with other function

          *Returns*
              :py:class:`FunctionAXPY`
                  Return a linear combination of Functions

        * operator+\ (axpy)

          Add operator with other linear combination of functions

          *Returns*
              :py:class:`FunctionAXPY`
                  Return a linear combination of Functions

        """
        return _function.Function___add__(self, *args)


    def __sub__(self, *args):
        """

        **Overloaded versions**

        * operator-\ (other)

          Subtraction operator with other function

          *Returns*
              :py:class:`FunctionAXPY`
                  Return a linear combination of Functions

        * operator-\ (axpy)

          Subtraction operator with other linear combination of functions

          *Returns*
              :py:class:`FunctionAXPY`
                  Return a linear combination of Functions

        """
        return _function.Function___sub__(self, *args)


    def __mul__(self, scalar):
        """

        Scale operator

        *Returns*
            :py:class:`FunctionAXPY`
                Return a linear combination of Functions

        """
        return _function.Function___mul__(self, scalar)


    def __div__(self, scalar):
        """

        Scale operator

        *Returns*
            :py:class:`FunctionAXPY`
                Return a linear combination of Functions

        """
        return _function.Function___div__(self, scalar)


    def _function_space(self):
        """

        Return shared pointer to function space

        *Returns*
            :py:class:`FunctionSpace`
                Return the shared pointer.

        """
        return _function.Function__function_space(self)


    def vector(self, *args):
        """

        **Overloaded versions**

        * vector\ ()

          Return vector of expansion coefficients (non-const version)

          *Returns*
              :py:class:`GenericVector`
                  The vector of expansion coefficients.

        * vector\ ()

          Return vector of expansion coefficients (const version)

          *Returns*
              :py:class:`GenericVector`
                  The vector of expansion coefficients (const).

        """
        return _function.Function_vector(self, *args)


    def _in(self, V):
        """

        Check if function is a member of the given function space

        *Arguments*
            V (:py:class:`FunctionSpace`)
                The function space.

        *Returns*
            bool
                True if the function is in the function space.

        """
        return _function.Function__in(self, V)


    def geometric_dimension(self):
        """

        Return geometric dimension

        *Returns*
            int
                The geometric dimension.

        """
        return _function.Function_geometric_dimension(self)


    def eval(self, *args):
        """

        **Overloaded versions**

        * eval\ (values, x)

          Evaluate function at given coordinates

          *Arguments*
              values (numpy.array(float))
                  The values.
              x (numpy.array(float))
                  The coordinates.

        * eval\ (values, x, dolfin_cell, ufc_cell)

          Evaluate function at given coordinates in given cell

          *Arguments*
              values (numpy.array(float))
                  The values.
              x (numpy.array(float))
                  The coordinates.
              dolfin_cell (:py:class:`Cell`)
                  The cell.
              ufc_cell (ufc::cell)
                  The ufc::cell.

        * eval\ (values, x, cell)

          Evaluate at given point in given cell

          *Arguments*
              values (numpy.array(float))
                  The values at the point.
              x (numpy.array(float))
                  The coordinates of the point.
              cell (ufc::cell)
                  The cell which contains the given point.

        """
        return _function.Function_eval(self, *args)


    def interpolate(self, v):
        """

        Interpolate function (on possibly non-matching meshes)

        *Arguments*
            v (:py:class:`GenericFunction`)
                The function to be interpolated.

        """
        return _function.Function_interpolate(self, v)


    def extrapolate(self, v):
        """

        Extrapolate function (from a possibly lower-degree function space)

        *Arguments*
            v (:py:class:`Function`)
                The function to be extrapolated.

        """
        return _function.Function_extrapolate(self, v)


    def non_matching_eval(self, values, x, ufc_cell):
        """

        Evaluate function for given data (non-matching meshes)
        This method is deprecated as of dolfin 1.6.0.
        Please use eval(values, x) instead.

        *Arguments*
            values (numpy.array(float))
                The values at the point.
            x (numpy.array(float))
                The coordinates of the point.
            cell (ufc::cell)
                The cell.

        """
        return _function.Function_non_matching_eval(self, values, x, ufc_cell)


    def compute_vertex_values(self, *args):
        """

        **Overloaded versions**

        * compute_vertex_values\ (vertex_values, mesh)

          Compute values at all mesh vertices

          *Arguments*
              vertex_values (numpy.array(float))
                  The values at all vertices.
              mesh (:py:class:`Mesh`)
                  The mesh.

        * compute_vertex_values\ (vertex_values)

          Compute values at all mesh vertices

          *Arguments*
              vertex_values (numpy.array(float))
                  The values at all vertices.

        """
        return _function.Function_compute_vertex_values(self, *args)


    def set_allow_extrapolation(self, allow_extrapolation):
        """

        Allow extrapolation when evaluating the Function

        *Arguments*
            allow_extrapolation (bool)
                Whether or not permit extrapolation.

        """
        return _function.Function_set_allow_extrapolation(self, allow_extrapolation)


    def get_allow_extrapolation(self):
        """

        Check if extrapolation is permitted when evaluating the Function

        *Returns*
            bool
                True if extrapolation is permitted, otherwise false

        """
        return _function.Function_get_allow_extrapolation(self)


    def function_space(self):
        "Return the FunctionSpace"
        from dolfin.functions.functionspace import FunctionSpaceFromCpp
        return FunctionSpaceFromCpp(self._function_space())

    def copy(self, deepcopy=False):
        """
        Return a copy of itself

        *Arguments*
            deepcopy (bool)
                If false (default) the dof vector is shared.

        *Returns*
             _Function_
                 The Function

        """
        from dolfin.functions.function import Function
        if deepcopy:
            return Function(self.function_space(), self.vector().copy())
        return Function(self.function_space(), self.vector())

    def leaf_node(self):
        "Return the finest Function in hierarchy"
        from dolfin.functions.function import Function
        return Function(HierarchicalFunction._leaf_node(self))

    def root_node(self):
        "Return the coarsest Function in hierarchy"
        from dolfin.functions.function import Function
        return Function(HierarchicalFunction._root_node(self))

    def child(self):
        "Return the child Function in the hierarchy"
        from dolfin.functions.function import Function
        return Function(HierarchicalFunction._child(self))

    def parent(self):
        "Return the parent Function in the hierarchy"
        from dolfin.functions.function import Function
        return Function(HierarchicalFunction._parent(self))

Function._assign = new_instancemethod(_function.Function__assign, None, Function)
Function.sub = new_instancemethod(_function.Function_sub, None, Function)
Function.__add__ = new_instancemethod(_function.Function___add__, None, Function)
Function.__sub__ = new_instancemethod(_function.Function___sub__, None, Function)
Function.__mul__ = new_instancemethod(_function.Function___mul__, None, Function)
Function.__div__ = new_instancemethod(_function.Function___div__, None, Function)
Function._function_space = new_instancemethod(_function.Function__function_space, None, Function)
Function.vector = new_instancemethod(_function.Function_vector, None, Function)
Function._in = new_instancemethod(_function.Function__in, None, Function)
Function.geometric_dimension = new_instancemethod(_function.Function_geometric_dimension, None, Function)
Function.eval = new_instancemethod(_function.Function_eval, None, Function)
Function.interpolate = new_instancemethod(_function.Function_interpolate, None, Function)
Function.extrapolate = new_instancemethod(_function.Function_extrapolate, None, Function)
Function.non_matching_eval = new_instancemethod(_function.Function_non_matching_eval, None, Function)
Function.compute_vertex_values = new_instancemethod(_function.Function_compute_vertex_values, None, Function)
Function.set_allow_extrapolation = new_instancemethod(_function.Function_set_allow_extrapolation, None, Function)
Function.get_allow_extrapolation = new_instancemethod(_function.Function_get_allow_extrapolation, None, Function)
Function_swigregister = _function.Function_swigregister
Function_swigregister(Function)

class FunctionSpace(common.Variable, HierarchicalFunctionSpace):
    """

    This class represents a finite element function space defined by
    a mesh, a finite element, and a local-to-global mapping of the
    degrees of freedom (dofmap).

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * FunctionSpace\ (mesh, element, dofmap)

          Create function space for given mesh, element and dofmap
          (shared data)

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh.
              element (:py:class:`FiniteElement`)
                  The element.
              dofmap (:py:class:`GenericDofMap`)
                  The dofmap.

        * FunctionSpace\ (mesh)

          Create empty function space for later initialization. This
          constructor is intended for use by any sub-classes which need
          to construct objects before the initialisation of the base
          class. Data can be attached to the base class using
          FunctionSpace::attach(...).

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh.

        * FunctionSpace\ (V)

          Copy constructor

          *Arguments*
              V (:py:class:`FunctionSpace`)
                  The object to be copied.

        """
        _function.FunctionSpace_swiginit(self, _function.new_FunctionSpace(*args))
    __swig_destroy__ = _function.delete_FunctionSpace

    def assign(self, V):
        """

        Assignment operator

        *Arguments*
            V (:py:class:`FunctionSpace`)
                Another function space.

        """
        return _function.FunctionSpace_assign(self, V)


    def __eq__(self, V):
        """

        Equality operator

        *Arguments*
            V (:py:class:`FunctionSpace`)
                Another function space.

        """
        return _function.FunctionSpace___eq__(self, V)


    def __ne__(self, V):
        """

        Inequality operator

        *Arguments*
            V (:py:class:`FunctionSpace`)
                Another function space.

        """
        return _function.FunctionSpace___ne__(self, V)


    def mesh(self):
        """

        Return mesh

        *Returns*
            :py:class:`Mesh`
                The mesh.

        """
        return _function.FunctionSpace_mesh(self)


    def element(self):
        """

        Return finite element

        *Returns*
            :py:class:`FiniteElement`
                The finite element.

        """
        return _function.FunctionSpace_element(self)


    def dofmap(self):
        """

        Return dofmap

        *Returns*
            :py:class:`GenericDofMap`
                The dofmap.

        """
        return _function.FunctionSpace_dofmap(self)


    def dim(self):
        """

        Return dimension of function space

        *Returns*
            int
                The dimension of the function space.

        """
        return _function.FunctionSpace_dim(self)


    def interpolate(self, expansion_coefficients, v):
        """

        Interpolate function v into function space, returning the
        vector of expansion coefficients

        *Arguments*
            expansion_coefficients (:py:class:`GenericVector`)
                The expansion coefficients.
            v (:py:class:`GenericFunction`)
                The function to be interpolated.

        """
        return _function.FunctionSpace_interpolate(self, expansion_coefficients, v)


    def sub(self, i):
        """

        Extract subspace for component

        *Arguments*
            i (int)
                Index of the subspace.
        *Returns*
            :py:class:`FunctionSpace`
                The subspace.

        """
        return _function.FunctionSpace_sub(self, i)


    def extract_sub_space(self, component):
        """

        Extract subspace for component

        *Arguments*
            component (numpy.array(int))
                The component.

        *Returns*
            :py:class:`FunctionSpace`
                The subspace.

        """
        return _function.FunctionSpace_extract_sub_space(self, component)


    def collapse(self):
        """

        **Overloaded versions**

        * collapse\ ()

          Collapse a subspace and return a new function space

          *Returns*
              :py:class:`FunctionSpace`
                  The new function space.

        * collapse\ (collapsed_dofs)

          Collapse a subspace and return a new function space and a map
          from new to old dofs

          *Arguments*
              collapsed_dofs (std::unordered_map<std::size_t, std::size_t>)
                  The map from new to old dofs.

          *Returns*
              :py:class:`FunctionSpace`
                The new function space.

        """
        return _function.FunctionSpace_collapse(self)


    def has_cell(self, cell):
        """

        Check if function space has given cell

        *Arguments*
            cell (:py:class:`Cell`)
                The cell.

        *Returns*
            bool
                True if the function space has the given cell.

        """
        return _function.FunctionSpace_has_cell(self, cell)


    def has_element(self, element):
        """

        Check if function space has given element

        *Arguments*
            element (:py:class:`FiniteElement`)
                The finite element.

        *Returns*
            bool
                True if the function space has the given element.

        """
        return _function.FunctionSpace_has_element(self, element)


    def component(self):
        """

        Return component

        *Returns*
            numpy.array(int)
                The component (relative to superspace).

        """
        return _function.FunctionSpace_component(self)


    def print_dofmap(self):
        """

        Print dofmap (useful for debugging)

        """
        return _function.FunctionSpace_print_dofmap(self)


    def __contains__(self,u):
        "Check whether a function is in the FunctionSpace"
        if isinstance(u, Function):
            return u._in(self)
        return False

    def leaf_node(self):
        "Return the finest FunctionSpace in hierarchy"
        from dolfin.functions.functionspace import FunctionSpaceFromCpp
        return FunctionSpaceFromCpp(HierarchicalFunctionSpace._leaf_node(self))

    def root_node(self):
        "Return the coarsest FunctionSpace in hierarchy"
        from dolfin.functions.functionspace import FunctionSpaceFromCpp
        return FunctionSpaceFromCpp(HierarchicalFunctionSpace._root_node(self))

    def child(self):
        "Return the child FunctionSpace in the hierarchy"
        from dolfin.functions.functionspace import FunctionSpaceFromCpp
        return FunctionSpaceFromCpp(HierarchicalFunctionSpace._child(self))

    def parent(self):
        "Return the parent FunctionSpace in the hierarchy"
        from dolfin.functions.functionspace import FunctionSpaceFromCpp
        return FunctionSpaceFromCpp(HierarchicalFunctionSpace._parent(self))


FunctionSpace.assign = new_instancemethod(_function.FunctionSpace_assign, None, FunctionSpace)
FunctionSpace.__eq__ = new_instancemethod(_function.FunctionSpace___eq__, None, FunctionSpace)
FunctionSpace.__ne__ = new_instancemethod(_function.FunctionSpace___ne__, None, FunctionSpace)
FunctionSpace.mesh = new_instancemethod(_function.FunctionSpace_mesh, None, FunctionSpace)
FunctionSpace.element = new_instancemethod(_function.FunctionSpace_element, None, FunctionSpace)
FunctionSpace.dofmap = new_instancemethod(_function.FunctionSpace_dofmap, None, FunctionSpace)
FunctionSpace.dim = new_instancemethod(_function.FunctionSpace_dim, None, FunctionSpace)
FunctionSpace.interpolate = new_instancemethod(_function.FunctionSpace_interpolate, None, FunctionSpace)
FunctionSpace.sub = new_instancemethod(_function.FunctionSpace_sub, None, FunctionSpace)
FunctionSpace.extract_sub_space = new_instancemethod(_function.FunctionSpace_extract_sub_space, None, FunctionSpace)
FunctionSpace.collapse = new_instancemethod(_function.FunctionSpace_collapse, None, FunctionSpace)
FunctionSpace.has_cell = new_instancemethod(_function.FunctionSpace_has_cell, None, FunctionSpace)
FunctionSpace.has_element = new_instancemethod(_function.FunctionSpace_has_element, None, FunctionSpace)
FunctionSpace.component = new_instancemethod(_function.FunctionSpace_component, None, FunctionSpace)
FunctionSpace.print_dofmap = new_instancemethod(_function.FunctionSpace_print_dofmap, None, FunctionSpace)
FunctionSpace_swigregister = _function.FunctionSpace_swigregister
FunctionSpace_swigregister(FunctionSpace)

class SubSpace(FunctionSpace):
    """

    This class represents a subspace (component) of a function space.

    The subspace is specified by an array of indices. For example,
    the array [3, 0, 2] specifies subspace 2 of subspace 0 of
    subspace 3.

    A typical example is the function space W = V x P for Stokes.
    Here, V = W[0] is the subspace for the velocity component and
    P = W[1] is the subspace for the pressure component. Furthermore,
    W[0][0] = V[0] is the first component of the velocity space etc.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * SubSpace\ (V, component)

          Create subspace for given component (one level)

        * SubSpace\ (V, component, sub_component)

          Create subspace for given component (two levels)

        * SubSpace\ (V, component)

          Create subspace for given component (n levels)

        """
        _function.SubSpace_swiginit(self, _function.new_SubSpace(*args))
    __swig_destroy__ = _function.delete_SubSpace
SubSpace_swigregister = _function.SubSpace_swigregister
SubSpace_swigregister(SubSpace)

class Constant(Expression):
    """

    This class represents a constant-valued expression.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * Constant\ (value)

          Create scalar constant

          *Arguments*
              value (float)
                  The scalar to create a Constant object from.

          *Example*
              .. note::

                  No example code available for this function.

        * Constant\ (value0, value1)

          Create vector constant (dim = 2)

          *Arguments*
              value0 (float)
                  The first vector element.
              value1 (float)
                  The second vector element.

          *Example*
              .. note::

                  No example code available for this function.

        * Constant\ (value0, value1, value2)

          Create vector constant (dim = 3)

          *Arguments*
              value0 (float)
                  The first vector element.
              value1 (float)
                  The second vector element.
              value2 (float)
                  The third vector element.

          *Example*
              .. note::

                  No example code available for this function.

        * Constant\ (values)

          Create vector-valued constant

          *Arguments*
              values (numpy.array(float))
                  Values to create a vector-valued constant from.

        * Constant\ (value_shape, values)

          Create tensor-valued constant for flattened array of values

          *Arguments*
              value_shape (numpy.array(int))
                  Shape of tensor.
              values (numpy.array(float))
                  Values to create tensor-valued constant from.

        * Constant\ (constant)

          Copy constructor

          *Arguments*
              constant (:py:class:`Constant`)
                  Object to be copied.

        """
        _function.Constant_swiginit(self, _function.new_Constant(*args))
    __swig_destroy__ = _function.delete_Constant

    def assign(self, *args):
        """

        **Overloaded versions**

        * operator=\ (constant)

          Assignment operator

          *Arguments*
              constant (:py:class:`Constant`)
                  Another constant.

        * operator=\ (constant)

          Assignment operator

          *Arguments*
              constant (float)
                  Another constant.

        """
        return _function.Constant_assign(self, *args)


    def __float__(self):
        """

        Cast to double (for scalar constants)

        *Returns*
            float
                The scalar value.

        """
        return _function.Constant___float__(self)

Constant.assign = new_instancemethod(_function.Constant_assign, None, Constant)
Constant.__float__ = new_instancemethod(_function.Constant___float__, None, Constant)
Constant_swigregister = _function.Constant_swigregister
Constant_swigregister(Constant)

class MeshCoordinates(Expression):
    """

    This Function represents the mesh coordinates on a given mesh.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, mesh):
        """

        Constructor

        """
        _function.MeshCoordinates_swiginit(self, _function.new_MeshCoordinates(mesh))
    __swig_destroy__ = _function.delete_MeshCoordinates
MeshCoordinates_swigregister = _function.MeshCoordinates_swigregister
MeshCoordinates_swigregister(MeshCoordinates)

class FacetArea(Expression):
    """

    This function represents the area/length of a cell facet on a given mesh.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, mesh):
        """

        Constructor

        """
        _function.FacetArea_swiginit(self, _function.new_FacetArea(mesh))
    __swig_destroy__ = _function.delete_FacetArea
FacetArea_swigregister = _function.FacetArea_swigregister
FacetArea_swigregister(FacetArea)

class SpecialFacetFunction(Expression):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * SpecialFacetFunction\ (f_e)

          Create (scalar-valued) SpecialFacetFunction

          *Arguments*
              f_e (list of :py:class:`Function`)
                 Separate _Function_s for each facet

        * SpecialFacetFunction\ (f_e, dim)

          Create (vector-valued) SpecialFacetFunction

          *Arguments*
              f_e (list of :py:class:`Function`)
                 Separate _Function_s for each facet

              dim (int)
                  The value-dimension of the Functions

        """
        _function.SpecialFacetFunction_swiginit(self, _function.new_SpecialFacetFunction(*args))

    def _sub(self, i):
        """

        Extract sub-function i

        *Arguments*
            i (int)
               component

        *Returns*
            :py:class:`Function`

        """
        return _function.SpecialFacetFunction__sub(self, i)

    __swig_destroy__ = _function.delete_SpecialFacetFunction
SpecialFacetFunction._sub = new_instancemethod(_function.SpecialFacetFunction__sub, None, SpecialFacetFunction)
SpecialFacetFunction_swigregister = _function.SpecialFacetFunction_swigregister
SpecialFacetFunction_swigregister(SpecialFacetFunction)

class MultiMeshFunction(object):
    """

    This class represents a function on a cut and composite finite
    element function space (MultiMesh) defined on one or more possibly
    intersecting meshes.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * MultiMeshFunction\ (V)

          Create MultiMesh function on given MultiMesh function space

          *Arguments*
              V (:py:class:`MultiMeshFunctionSpace`)
                  The MultiMesh function space.

          *Example*
              .. note::

                  No example code available for this function.

        * MultiMeshFunction\ (V)

          Create MultiMesh function on given MultiMesh function space (shared
          pointer version)

          *Arguments*
              V (:py:class:`MultiMeshFunctionSpace`)
                  The MultiMesh function space.

        """
        _function.MultiMeshFunction_swiginit(self, _function.new_MultiMeshFunction(*args))
    __swig_destroy__ = _function.delete_MultiMeshFunction

    def part(self, i):
        """

        Return function (part) number i

        *Returns*
            :py:class:`Function`
                Function (part) number i

        """
        return _function.MultiMeshFunction_part(self, i)


    def vector(self, *args):
        """

        **Overloaded versions**

        * vector\ ()

          Return vector of expansion coefficients (non-const version)

          *Returns*
              :py:class:`GenericVector`
                  The vector of expansion coefficients.

        * vector\ ()

          Return vector of expansion coefficients (const version)

          *Returns*
              :py:class:`GenericVector`
                  The vector of expansion coefficients (const).

        """
        return _function.MultiMeshFunction_vector(self, *args)

MultiMeshFunction.part = new_instancemethod(_function.MultiMeshFunction_part, None, MultiMeshFunction)
MultiMeshFunction.vector = new_instancemethod(_function.MultiMeshFunction_vector, None, MultiMeshFunction)
MultiMeshFunction_swigregister = _function.MultiMeshFunction_swigregister
MultiMeshFunction_swigregister(MultiMeshFunction)

class MultiMeshFunctionSpace(common.Variable):
    """

    This class represents a function space on a multimesh. It may
    may be created from a set of standard function spaces by
    repeatedly calling add(), followed by a call to build(). Note
    that a multimesh function space is not useful and its data
    structures are empty until build() has been called.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """

        Create empty multimesh function space

        """
        _function.MultiMeshFunctionSpace_swiginit(self, _function.new_MultiMeshFunctionSpace())
    __swig_destroy__ = _function.delete_MultiMeshFunctionSpace

    def dim(self):
        """

        Return dimension of the multimesh function space

        *Returns*
            int
                The dimension of the multimesh function space.

        """
        return _function.MultiMeshFunctionSpace_dim(self)


    def multimesh(self):
        """

        Return multimesh

        *Returns*
            :py:class:`MultiMesh`
                The multimesh.

        """
        return _function.MultiMeshFunctionSpace_multimesh(self)


    def dofmap(self):
        """

        Return multimesh dofmap

        *Returns*
            :py:class:`MultiMeshDofMap`
                The dofmap.

        """
        return _function.MultiMeshFunctionSpace_dofmap(self)


    def num_parts(self):
        """

        Return the number of function spaces (parts) of the multimesh function space

        *Returns*
            int
                The number of function spaces (parts) of the multimesh function space.

        """
        return _function.MultiMeshFunctionSpace_num_parts(self)


    def part(self, i):
        """

        Return function space (part) number i

        *Arguments*
            i (int)
                The part number

        *Returns*
            :py:class:`FunctionSpace`
                Function space (part) number i

        """
        return _function.MultiMeshFunctionSpace_part(self, i)


    def view(self, i):
        """

        Return view of multimesh function space for part number i.
        This function differs from the part() function in that it does
        not return the original function space for a part, but rather
        a view of the common multimesh function space (dofs global to
        the collection of parts).

        *Arguments*
            i (int)
                The part number

        *Returns*
            :py:class:`FunctionSpace`
                Function space (part) number i

        """
        return _function.MultiMeshFunctionSpace_view(self, i)


    def add(self, *args):
        """

        **Overloaded versions**

        * add\ (function_space)

          Add function space (shared pointer version)

          *Arguments*
              function_space (:py:class:`FunctionSpace`)
                  The function space.

        * add\ (function_space)

          Add function space (reference version)

          *Arguments*
              function_space (:py:class:`FunctionSpace`)
                  The function space.

        """
        return _function.MultiMeshFunctionSpace_add(self, *args)


    def build(self, *args):
        """

        **Overloaded versions**

        * build\ ()

          Build multimesh function space

        * build\ (multimesh, offsets)

          Build multimesh function space. This function reuses an
          existing multimesh and uses offsets computed from the full
          function spaces on each part.

        """
        return _function.MultiMeshFunctionSpace_build(self, *args)


    def default_parameters():
        """

        Default parameter values

        """
        return _function.MultiMeshFunctionSpace_default_parameters()

    default_parameters = staticmethod(default_parameters)
MultiMeshFunctionSpace.dim = new_instancemethod(_function.MultiMeshFunctionSpace_dim, None, MultiMeshFunctionSpace)
MultiMeshFunctionSpace.multimesh = new_instancemethod(_function.MultiMeshFunctionSpace_multimesh, None, MultiMeshFunctionSpace)
MultiMeshFunctionSpace.dofmap = new_instancemethod(_function.MultiMeshFunctionSpace_dofmap, None, MultiMeshFunctionSpace)
MultiMeshFunctionSpace.num_parts = new_instancemethod(_function.MultiMeshFunctionSpace_num_parts, None, MultiMeshFunctionSpace)
MultiMeshFunctionSpace.part = new_instancemethod(_function.MultiMeshFunctionSpace_part, None, MultiMeshFunctionSpace)
MultiMeshFunctionSpace.view = new_instancemethod(_function.MultiMeshFunctionSpace_view, None, MultiMeshFunctionSpace)
MultiMeshFunctionSpace.add = new_instancemethod(_function.MultiMeshFunctionSpace_add, None, MultiMeshFunctionSpace)
MultiMeshFunctionSpace.build = new_instancemethod(_function.MultiMeshFunctionSpace_build, None, MultiMeshFunctionSpace)
MultiMeshFunctionSpace_swigregister = _function.MultiMeshFunctionSpace_swigregister
MultiMeshFunctionSpace_swigregister(MultiMeshFunctionSpace)

def MultiMeshFunctionSpace_default_parameters():
    """

    Default parameter values

    """
    return _function.MultiMeshFunctionSpace_default_parameters()

class MultiMeshSubSpace(MultiMeshFunctionSpace):
    """

    This class represents a subspace (component) of a multimesh
    function space.

    The subspace is specified by an array of indices. For example,
    the array [3, 0, 2] specifies subspace 2 of subspace 0 of
    subspace 3.

    A typical example is the function space W = V x P for Stokes.
    Here, V = W[0] is the subspace for the velocity component and
    P = W[1] is the subspace for the pressure component. Furthermore,
    W[0][0] = V[0] is the first component of the velocity space etc.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * MultiMeshSubSpace\ (V, component)

          Create subspace for given component (one level)

        * MultiMeshSubSpace\ (V, component, sub_component)

          Create subspace for given component (two levels)

        * MultiMeshSubSpace\ (V, component)

          Create subspace for given component (n levels)

        """
        _function.MultiMeshSubSpace_swiginit(self, _function.new_MultiMeshSubSpace(*args))
    __swig_destroy__ = _function.delete_MultiMeshSubSpace
MultiMeshSubSpace_swigregister = _function.MultiMeshSubSpace_swigregister
MultiMeshSubSpace_swigregister(MultiMeshSubSpace)

class FunctionAssigner(object):
    """

    This class facilitate assignments between Function and sub
    Functions. It builds and caches maps between compatible
    dofs. These maps are used in the assignment methods which
    perform the actual assignment. Optionally can a MeshFunction be
    passed together with a label, facilitating FunctionAssignment
    over sub domains.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * FunctionAssigner\ (receiving_space, assigning_space)

          Create a FunctionAssigner between functions residing in the
          same type of FunctionSpace. One or both functions can be sub
          functions.

          *Arguments*
              receiving_space (:py:class:`FunctionSpace`)
                  The function space of the receiving function
              assigning_space (:py:class:`FunctionSpace`)
                  The function space of the assigning function

        * FunctionAssigner\ (receiving_spaces, assigning_space)

          Create a FunctionAssigner between one mixed function
          (assigning) and several functions (receiving). The number of
          receiving functions must sum up to the number of sub functions
          in the assigning mixed function. The sub spaces of the
          assigning mixed space must be of the same type ans size as the
          receiving spaces.

          *Arguments*
              receiving_spaces (list of :py:class:`FunctionSpace`)
                  The receiving function spaces
              assigning_space (:py:class:`FunctionSpace`)
                  The assigning function space

        * FunctionAssigner\ (receiving_space, assigning_spaces)

          Create a FunctionAssigner between several functions
          (assigning) and one mixed function (receiving). The number of
          sub functions in the assigning mixed function must sum up to
          the number of receiving functions. The sub spaces of the
          receiving mixed space must be of the same type ans size as the
          assigning spaces.

          *Arguments*
              receiving_space (:py:class:`FunctionSpace`)
                  The receiving function space
              assigning_spaces (std::vector<std::shared_ptr<:py:class:`FunctionSpace`> >)
                  The assigning function spaces

        """
        _function.FunctionAssigner_swiginit(self, _function.new_FunctionAssigner(*args))

    def assign(self, *args):
        """

        **Overloaded versions**

        * assign\ (receiving_func, assigning_func)

          Assign one function to another

          *Arguments*
              receiving_func (:py:class:`Function`)
                  The receiving function
              assigning_func (:py:class:`Function`)
                  The assigning function

        * assign\ (receiving_func, assigning_funcs)

          Assign several functions to sub functions of a mixed receiving
          function

          *Arguments*
              receiving_func (:py:class:`Function`)
                  The receiving mixed function
              assigning_funcs (std::vector<std::shared_ptr<:py:class:`Function`> >)
                  The assigning functions

        * assign\ (receiving_funcs, assigning_func)

          Assign sub functions of a single mixed function to single
          receiving functions

          *Arguments*
              receiving_funcs (std::vector<std::shared_ptr<:py:class:`Function`> >)
                  The receiving functions
              assigning_func (:py:class:`Function`)
                  The assigning mixed function

        """
        return _function.FunctionAssigner_assign(self, *args)

    __swig_destroy__ = _function.delete_FunctionAssigner

    def num_assigning_functions(self):
        """

        Return the number of assigning functions

        """
        return _function.FunctionAssigner_num_assigning_functions(self)


    def num_receiving_functions(self):
        """

        Return the number of receiving functions

        """
        return _function.FunctionAssigner_num_receiving_functions(self)

FunctionAssigner.assign = new_instancemethod(_function.FunctionAssigner_assign, None, FunctionAssigner)
FunctionAssigner.num_assigning_functions = new_instancemethod(_function.FunctionAssigner_num_assigning_functions, None, FunctionAssigner)
FunctionAssigner.num_receiving_functions = new_instancemethod(_function.FunctionAssigner_num_receiving_functions, None, FunctionAssigner)
FunctionAssigner_swigregister = _function.FunctionAssigner_swigregister
FunctionAssigner_swigregister(FunctionAssigner)


def assign(*args):
    """

    **Overloaded versions**

    * assign\ (receiving_func, assigning_func)

      Assign one function to another. The functions must reside in the
      same type of FunctionSpace. One or both functions can be sub
      functions.

      *Arguments*
          receiving_func (:py:class:`Function`)
              The receiving function
          assigning_func (:py:class:`Function`)
              The assigning function

    * assign\ (receiving_func, assigning_funcs)

      Assign several functions to sub functions of a mixed receiving
      function. The number of receiving functions must sum up to the
      number of sub functions in the assigning mixed function. The sub
      spaces of the assigning mixed space must be of the same type ans
      size as the receiving spaces.

    * assign\ (receiving_funcs, assigning_func)

      Assign sub functions of a single mixed function to single
      receiving functions. The number of sub functions in the
      assigning mixed function must sum up to the number of receiving
      functions. The sub spaces of the receiving mixed space must be
      of the same type ans size as the assigning spaces.

    """
    return _function.assign(*args)
class lt_coordinate(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, tolerance):
        _function.lt_coordinate_swiginit(self, _function.new_lt_coordinate(tolerance))
    TOL = _swig_property(_function.lt_coordinate_TOL_get)
    __swig_destroy__ = _function.delete_lt_coordinate
lt_coordinate.__call__ = new_instancemethod(_function.lt_coordinate___call__, None, lt_coordinate)
lt_coordinate_swigregister = _function.lt_coordinate_swigregister
lt_coordinate_swigregister(lt_coordinate)

class LagrangeInterpolator(object):
    """

    This class interpolates efficiently from a GenericFunction
    to a Lagrange Function

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def interpolate(self, *args):
        """

        **Overloaded versions**

        * interpolate\ (u, u0)

          Interpolate Expression

          *Arguments*
              u (:py:class:`Function`)
                  The resulting Function
              u0 (:py:class:`Expression`)
                  The Expression to be interpolated.

        * interpolate\ (u, u0)

          Interpolate function (on possibly non-matching meshes)

          *Arguments*
              u (:py:class:`Function`)
                  The resulting Function
              u0 (:py:class:`Function`)
                  The Function to be interpolated.

        """
        return _function.LagrangeInterpolator_interpolate(self, *args)


    def __init__(self):
        _function.LagrangeInterpolator_swiginit(self, _function.new_LagrangeInterpolator())
    __swig_destroy__ = _function.delete_LagrangeInterpolator
LagrangeInterpolator.interpolate = new_instancemethod(_function.LagrangeInterpolator_interpolate, None, LagrangeInterpolator)
LagrangeInterpolator_swigregister = _function.LagrangeInterpolator_swigregister
LagrangeInterpolator_swigregister(LagrangeInterpolator)


def ipow(a, n):
    """

    Return a to the power n

    """
    return _function.ipow(a, n)

def rand():
    """

    Return a random number, uniformly distributed between [0.0, 1.0)

    """
    return _function.rand()

def seed(s):
    """

    Seed random number generator

    """
    return _function.seed(s)

def near(x, x0, eps=3.0e-16):
    """

    Check whether x is close to x0 (to within DOLFIN_EPS)

    """
    return _function.near(x, x0, eps)

def between(x, range):
    """

    Check whether x is between x0 and x1 (inclusive, to within DOLFIN_EPS)

    """
    return _function.between(x, range)
class Lagrange(common.Variable):
    """

    Lagrange polynomial (basis) with given degree q determined by
    n = q + 1 nodal points.

    Example: q = 1 (n = 2)

      Lagrange p(1);
      p.set(0, 0.0);
      p.set(1, 1.0);

    It is the callers responsibility that the points are distinct.

    This creates a Lagrange polynomial (actually two Lagrange
    polynomials):

      p(0,x) = 1 - x   (one at x = 0, zero at x = 1)
      p(1,x) = x       (zero at x = 0, one at x = 1)


    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * Lagrange\ (q)

          Constructor

        * Lagrange\ (p)

          Copy constructor

        """
        _function.Lagrange_swiginit(self, _function.new_Lagrange(*args))

    def set(self, i, x):
        """

        Specify point

        """
        return _function.Lagrange_set(self, i, x)


    def size(self):
        """

        Return number of points

        """
        return _function.Lagrange_size(self)


    def degree(self):
        """

        Return degree

        """
        return _function.Lagrange_degree(self)


    def point(self, i):
        """

        Return point

        """
        return _function.Lagrange_point(self, i)


    def eval(self, i, x):
        """

        Return value of polynomial i at given point x

        """
        return _function.Lagrange_eval(self, i, x)


    def ddx(self, i, x):
        """

        Return derivate of polynomial i at given point x

        """
        return _function.Lagrange_ddx(self, i, x)


    def dqdx(self, i):
        """

        Return derivative q (a constant) of polynomial

        """
        return _function.Lagrange_dqdx(self, i)

    __swig_destroy__ = _function.delete_Lagrange
Lagrange.set = new_instancemethod(_function.Lagrange_set, None, Lagrange)
Lagrange.size = new_instancemethod(_function.Lagrange_size, None, Lagrange)
Lagrange.degree = new_instancemethod(_function.Lagrange_degree, None, Lagrange)
Lagrange.point = new_instancemethod(_function.Lagrange_point, None, Lagrange)
Lagrange.__call__ = new_instancemethod(_function.Lagrange___call__, None, Lagrange)
Lagrange.eval = new_instancemethod(_function.Lagrange_eval, None, Lagrange)
Lagrange.ddx = new_instancemethod(_function.Lagrange_ddx, None, Lagrange)
Lagrange.dqdx = new_instancemethod(_function.Lagrange_dqdx, None, Lagrange)
Lagrange_swigregister = _function.Lagrange_swigregister
Lagrange_swigregister(Lagrange)

class Legendre(object):
    """

    Interface for computing Legendre polynomials via Boost.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def eval(n, x):
        """

        Evaluate polynomial of order n at point x

        """
        return _function.Legendre_eval(n, x)

    eval = staticmethod(eval)

    def ddx(n, x):
        """

        Evaluate first derivative of polynomial of order n at point x

        """
        return _function.Legendre_ddx(n, x)

    ddx = staticmethod(ddx)

    def d2dx(n, x):
        """

        Evaluate second derivative of polynomial of order n at point x

        """
        return _function.Legendre_d2dx(n, x)

    d2dx = staticmethod(d2dx)

    def __init__(self):
        _function.Legendre_swiginit(self, _function.new_Legendre())
    __swig_destroy__ = _function.delete_Legendre
Legendre_swigregister = _function.Legendre_swigregister
Legendre_swigregister(Legendre)

def Legendre_eval(n, x):
    """

    Evaluate polynomial of order n at point x

    """
    return _function.Legendre_eval(n, x)

def Legendre_ddx(n, x):
    """

    Evaluate first derivative of polynomial of order n at point x

    """
    return _function.Legendre_ddx(n, x)

def Legendre_d2dx(n, x):
    """

    Evaluate second derivative of polynomial of order n at point x

    """
    return _function.Legendre_d2dx(n, x)

class ALE(object):
    """

    This class provides functionality useful for implementation of
    ALE (Arbitrary Lagrangian-Eulerian) methods, in particular
    moving the boundary vertices of a mesh and then interpolating
    the new coordinates for the interior vertices accordingly.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def move(*args):
        """

        **Overloaded versions**

        * move\ (mesh, new_boundary)

          Move coordinates of mesh according to new boundary coordinates.
          Returns displacement (encapsulated in Expression subclass MeshDisplacement)

        * move\ (mesh0, mesh1)

          Move coordinates of mesh0 according to mesh1 with common global vertices.
          Returns displacement (encapsulated in Expression subclass MeshDisplacement)

        * move\ (mesh, displacement)

          Move coordinates of mesh according to displacement function

        """
        return _function.ALE_move(*args)

    move = staticmethod(move)

    def __init__(self):
        _function.ALE_swiginit(self, _function.new_ALE())
    __swig_destroy__ = _function.delete_ALE
ALE_swigregister = _function.ALE_swigregister
ALE_swigregister(ALE)

def ALE_move(*args):
    """

    **Overloaded versions**

    * move\ (mesh, new_boundary)

      Move coordinates of mesh according to new boundary coordinates.
      Returns displacement (encapsulated in Expression subclass MeshDisplacement)

    * move\ (mesh0, mesh1)

      Move coordinates of mesh0 according to mesh1 with common global vertices.
      Returns displacement (encapsulated in Expression subclass MeshDisplacement)

    * move\ (mesh, displacement)

      Move coordinates of mesh according to displacement function

    """
    return _function.ALE_move(*args)

class MeshDisplacement(Expression):
    """

    This class encapsulates the CG1 representation of the
    displacement of a mesh as an Expression. This is particularly
    useful for the displacement returned by mesh smoothers which can
    subsequently be used in evaluating forms. The value rank is 1
    and the value shape is equal to the geometric dimension of the
    mesh.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * MeshDisplacement\ (mesh)

          Create MeshDisplacement of given mesh

          *Arguments*
              mesh (:py:class:`Mesh`)
                  Mesh to be displacement defined on.

        * MeshDisplacement\ (mesh_displacement)

          Copy constructor

          *Arguments*
              mesh_displacement (:py:class:`MeshDisplacement`)
                  Object to be copied.

        """
        _function.MeshDisplacement_swiginit(self, _function.new_MeshDisplacement(*args))
    __swig_destroy__ = _function.delete_MeshDisplacement

    def sub(self, *args):
        """

        **Overloaded versions**

        * operator[]\ (i)

          Extract subfunction
          In python available as MeshDisplacement.sub(i)

          *Arguments*
              i (int)
                  Index of subfunction.

        * operator[]\ (i)

          Extract subfunction. Const version

          *Arguments*
              i (int)
                  Index of subfunction.

        """
        return _function.MeshDisplacement_sub(self, *args)

MeshDisplacement.sub = new_instancemethod(_function.MeshDisplacement_sub, None, MeshDisplacement)
MeshDisplacement_swigregister = _function.MeshDisplacement_swigregister
MeshDisplacement_swigregister(MeshDisplacement)



