# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _io.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_io', [dirname(__file__)])
        except ImportError:
            import _io
            return _io
        if fp is not None:
            try:
                _mod = imp.load_module('_io', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _io = swig_import_helper()
    del swig_import_helper
else:
    import _io
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0



def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except Exception:
    weakref_proxy = lambda x: x



_io.SHARED_PTR_DISOWN_swigconstant(_io)
SHARED_PTR_DISOWN = _io.SHARED_PTR_DISOWN
import ufc

def _attach_base_to_numpy_array(obj, owner):
    return _io._attach_base_to_numpy_array(obj, owner)
_attach_base_to_numpy_array = _io._attach_base_to_numpy_array

def dolfin_swigversion():
    return _io.dolfin_swigversion()
dolfin_swigversion = _io.dolfin_swigversion

def dolfin_pythonversion():
    return _io.dolfin_pythonversion()
dolfin_pythonversion = _io.dolfin_pythonversion

tmp = hex(dolfin_swigversion())
__swigversion__ = "%d.%d.%d"%(tuple(map(int, [tmp[-5], tmp[-3], tmp[-2:]])))
tmp = hex(dolfin_pythonversion())
__pythonversion__ = "%d.%d.%d"%(tuple(map(lambda x: int(x,16), [tmp[2], tmp[3:5], tmp[5:7]])))
del tmp, dolfin_pythonversion, dolfin_swigversion


def has_petsc4py():
    return _io.has_petsc4py()
has_petsc4py = _io.has_petsc4py

def has_slepc4py():
    return _io.has_slepc4py()
has_slepc4py = _io.has_slepc4py
import common
class HierarchicalMesh(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, arg2):
        _io.HierarchicalMesh_swiginit(self, _io.new_HierarchicalMesh(arg2))
    __swig_destroy__ = _io.delete_HierarchicalMesh
HierarchicalMesh.depth = new_instancemethod(_io.HierarchicalMesh_depth, None, HierarchicalMesh)
HierarchicalMesh.has_parent = new_instancemethod(_io.HierarchicalMesh_has_parent, None, HierarchicalMesh)
HierarchicalMesh.has_child = new_instancemethod(_io.HierarchicalMesh_has_child, None, HierarchicalMesh)
HierarchicalMesh._parent = new_instancemethod(_io.HierarchicalMesh__parent, None, HierarchicalMesh)
HierarchicalMesh._child = new_instancemethod(_io.HierarchicalMesh__child, None, HierarchicalMesh)
HierarchicalMesh._root_node = new_instancemethod(_io.HierarchicalMesh__root_node, None, HierarchicalMesh)
HierarchicalMesh._leaf_node = new_instancemethod(_io.HierarchicalMesh__leaf_node, None, HierarchicalMesh)
HierarchicalMesh.set_parent = new_instancemethod(_io.HierarchicalMesh_set_parent, None, HierarchicalMesh)
HierarchicalMesh.clear_child = new_instancemethod(_io.HierarchicalMesh_clear_child, None, HierarchicalMesh)
HierarchicalMesh.set_child = new_instancemethod(_io.HierarchicalMesh_set_child, None, HierarchicalMesh)
HierarchicalMesh._debug = new_instancemethod(_io.HierarchicalMesh__debug, None, HierarchicalMesh)
HierarchicalMesh_swigregister = _io.HierarchicalMesh_swigregister
HierarchicalMesh_swigregister(HierarchicalMesh)

import mesh
import la
class HierarchicalFunctionSpace(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, arg2):
        _io.HierarchicalFunctionSpace_swiginit(self, _io.new_HierarchicalFunctionSpace(arg2))
    __swig_destroy__ = _io.delete_HierarchicalFunctionSpace
HierarchicalFunctionSpace.depth = new_instancemethod(_io.HierarchicalFunctionSpace_depth, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace.has_parent = new_instancemethod(_io.HierarchicalFunctionSpace_has_parent, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace.has_child = new_instancemethod(_io.HierarchicalFunctionSpace_has_child, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace._parent = new_instancemethod(_io.HierarchicalFunctionSpace__parent, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace._child = new_instancemethod(_io.HierarchicalFunctionSpace__child, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace._root_node = new_instancemethod(_io.HierarchicalFunctionSpace__root_node, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace._leaf_node = new_instancemethod(_io.HierarchicalFunctionSpace__leaf_node, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace.set_parent = new_instancemethod(_io.HierarchicalFunctionSpace_set_parent, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace.clear_child = new_instancemethod(_io.HierarchicalFunctionSpace_clear_child, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace.set_child = new_instancemethod(_io.HierarchicalFunctionSpace_set_child, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace._debug = new_instancemethod(_io.HierarchicalFunctionSpace__debug, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace_swigregister = _io.HierarchicalFunctionSpace_swigregister
HierarchicalFunctionSpace_swigregister(HierarchicalFunctionSpace)

class HierarchicalFunction(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, arg2):
        _io.HierarchicalFunction_swiginit(self, _io.new_HierarchicalFunction(arg2))
    __swig_destroy__ = _io.delete_HierarchicalFunction
HierarchicalFunction.depth = new_instancemethod(_io.HierarchicalFunction_depth, None, HierarchicalFunction)
HierarchicalFunction.has_parent = new_instancemethod(_io.HierarchicalFunction_has_parent, None, HierarchicalFunction)
HierarchicalFunction.has_child = new_instancemethod(_io.HierarchicalFunction_has_child, None, HierarchicalFunction)
HierarchicalFunction._parent = new_instancemethod(_io.HierarchicalFunction__parent, None, HierarchicalFunction)
HierarchicalFunction._child = new_instancemethod(_io.HierarchicalFunction__child, None, HierarchicalFunction)
HierarchicalFunction._root_node = new_instancemethod(_io.HierarchicalFunction__root_node, None, HierarchicalFunction)
HierarchicalFunction._leaf_node = new_instancemethod(_io.HierarchicalFunction__leaf_node, None, HierarchicalFunction)
HierarchicalFunction.set_parent = new_instancemethod(_io.HierarchicalFunction_set_parent, None, HierarchicalFunction)
HierarchicalFunction.clear_child = new_instancemethod(_io.HierarchicalFunction_clear_child, None, HierarchicalFunction)
HierarchicalFunction.set_child = new_instancemethod(_io.HierarchicalFunction_set_child, None, HierarchicalFunction)
HierarchicalFunction._debug = new_instancemethod(_io.HierarchicalFunction__debug, None, HierarchicalFunction)
HierarchicalFunction_swigregister = _io.HierarchicalFunction_swigregister
HierarchicalFunction_swigregister(HierarchicalFunction)

import function
import fem

def interactive(really=False):
    """

    Make the current plots interactive. If really is set, the interactive
    mode is entered even if 'Q' has been pressed.

    """
    return _io.interactive(really)

def plot(*args):
    """

    **Overloaded versions**

    * plot\ (Variable&, title="", mode="auto")

      Plot variable of any supported type

    * plot\ (Variable>, title="", mode="auto")

      Plot variable (shared_ptr version)

    * plot\ (Variable&, parameters)

      Plot variable (parameter version)

    * plot\ (Variable>, parameters)

      Plot variable (parameter, shared_ptr version)

    * plot\ (expression, mesh, title="", mode="auto")

      Plot expression

    * plot\ (expression, mesh, title="", mode="auto")

      Plot expression (shared_ptr version)

    * plot\ (expression, mesh, parameters)

      Plot expression (parameter version)

    * plot\ (expression, mesh, parameters)

      Plot expression (parameter, shared_ptr version)

    """
    return _io.plot(*args)
class VTKPlotter(common.Variable):
    """

    This class enables visualization of various DOLFIN entities.
    It supports visualization of meshes, functions, expressions, boundary
    conditions and mesh functions. It can plot data wrapped in classes
    conforming to the GenericVTKPlottable interface.
    The plotter has several parameters that the user can set and adjust to
    affect the appearance and behavior of the plot.

    A plotter can be created and used in the following way:

      Mesh mesh = ...;
      VTKPlotter plotter(mesh);
      plotter.plot();

    Parameters can be adjusted at any time and will take effect on the next
    call to the plot() method. The following parameters exist:

    ============== ============ ================ ====================================
     Name           Value type   Default value              Description
    ============== ============ ================ ====================================
     mode            String        "auto"         For vector valued functions,
                                                  this parameter may be set to
                                                  "glyphs" or "displacement".
                                                  Scalars may be set to "warp" in
                                                  2D only. A value of "color" is
                                                  valid in all cases; for vectors,
                                                  the norms are used. See below for
                                                  a summary of default modes,
                                                  used when set to "auto".
     interactive     Boolean     False            Enable/disable interactive mode
                                                  for the rendering window.
                                                  For repeated plots of the same
                                                  object (animated plots), this
                                                  parameter should be set to false.
     wireframe       Boolean     True for         Enable/disable wireframe
                                 meshes, else     rendering of the object.
                                 false
     title           String      Inherited        The title of the rendering
                                 from the         window
                                 name/label of
                                 the object
     scale           Double      1.0              Adjusts the scaling of the
                                                  warping and glyphs
     scalarbar       Boolean     False for        Hide/show the colormapping bar
                                 meshes, else
                                 true
     axes            Boolean     False            Show X-Y-Z axes.

     rescale         Boolean     True             Enable/disable recomputation
                                                  of the scalar to color mapping
                                                  on every iteration when performing
                                                  repeated/animated plots of the same
                                                  data. If both range_min and
                                                  range_max are set, this parameter
                                                  is ignored.
     range_min       Double                       Set lower range of data values.
                                                  Disables automatic (re-)computation
                                                  of the lower range.
     range_max       Double                       Set upper range of data values.
                                                  Disables automatic (re-)computation
                                                  of the upper range.
     elevate         Double      -65.0 for 2D     Set camera elevation.
                                 warped scalars,
                                 0.0 otherwise
     prefix          String      "dolfin_plot_"   Filename prefix used when
                                                  saving plots to file in
                                                  interactive mode. An integer
                                                  counter is appended after the
                                                  prefix.
     helptext        Boolean     True             Enable/disable the hover-over
                                                  help-text in interactive
                                                  mode
     window_width    Integer     600              The width of the plotting window
                                                  in pixels
     window_height   Integer     400              The height of the plotting window
                                                  in pixels
     tile_windows    Boolean     True             Automatically tile plot windows.

     key             String                       Key (id) of the plot window, used to
                                                  decide if a new plotter should be
                                                  created or a current one updated
                                                  when called through the static
                                                  plot() interface (in plot.h).
                                                  If not set, the object's unique
                                                  id (Variable::id) is used.
     input_keys      String      ""               Synthesize key presses, as if these
                                                  keys are pressed by the user in
                                                  the plot window.
                                                  For example: "ww++m" shows the data
                                                  as large points on a wireframe
                                                  mesh.
     hide_above      Double                       If either of these are set, scalar
     hide_below      Double                       values above or below will not be
                                                  shown in the plot.
    ============== ============ ================ ====================================

    The default visualization mode for the different plot types are as follows:

    =========================  ============================ =====================
     Plot type                  Default visualization mode   Alternatives
    =========================  ============================ =====================
     Meshes                     Wireframe rendering          None
     2D scalar functions        Scalar warping               Color mapping
     3D scalar functions        Color mapping                None
     2D/3D vector functions     Glyphs (vector arrows)       Displacements,
                                                             Color mapping (norm)
    =========================  ============================ =====================

    Expressions and boundary conditions are also visualized according to the
    above table.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * VTKPlotter\ (Variable>, NULL)

          Create plotter for a variable. If a widget is supplied, this widget
          will be used for drawing, instead of a new top-level widget. Ownership
          is transferred.

        * VTKPlotter\ (expression, mesh, NULL)

          Create plotter for an Expression with associated Mesh. If a widget is
          supplied, this widget will be used for drawing, instead of a new
          top-level widget. Ownership is transferred.

        """
        _io.VTKPlotter_swiginit(self, _io.new_VTKPlotter(*args))
    __swig_destroy__ = _io.delete_VTKPlotter

    def default_parameters():
        """

        Default parameter values

        """
        return _io.VTKPlotter_default_parameters()

    default_parameters = staticmethod(default_parameters)

    def plot(self, *args):
        """

        Plot the object

        """
        return _io.VTKPlotter_plot(self, *args)


    def interactive(self, enter_eventloop=True):
        """

        Make the current plot interactive

        """
        return _io.VTKPlotter_interactive(self, enter_eventloop)


    def write_png(self, *args):
        """

        Save plot to PNG file (file suffix appended automatically, filename
        optionally built from prefix)

        """
        return _io.VTKPlotter_write_png(self, *args)


    def write_pdf(self, *args):
        """

        Save plot to PDF file (file suffix appended automatically, filename
        optionally built from prefix)

        """
        return _io.VTKPlotter_write_pdf(self, *args)


    def key(self):
        """

        Return key (i.e., plotter id) of the object to plot

        """
        return _io.VTKPlotter_key(self)


    def set_key(self, key):
        """

        Set the key (plotter id)

        """
        return _io.VTKPlotter_set_key(self, key)


    def to_key(var):
        """

        Return default key (plotter id) of a Variable (object to plot).

        """
        return _io.VTKPlotter_to_key(var)

    to_key = staticmethod(to_key)

    def azimuth(self, angle):
        """

        Camera control

        """
        return _io.VTKPlotter_azimuth(self, angle)


    def all_interactive(really=False):
        """

        Make all plot windows interactive. If really is set, the interactive
        mode is entered even if 'Q' has been pressed.

        """
        return _io.VTKPlotter_all_interactive(really)

    all_interactive = staticmethod(all_interactive)
    SHIFT = _io.VTKPlotter_SHIFT
    ALT = _io.VTKPlotter_ALT
    CONTROL = _io.VTKPlotter_CONTROL
VTKPlotter.is_compatible = new_instancemethod(_io.VTKPlotter_is_compatible, None, VTKPlotter)
VTKPlotter.plot = new_instancemethod(_io.VTKPlotter_plot, None, VTKPlotter)
VTKPlotter.update = new_instancemethod(_io.VTKPlotter_update, None, VTKPlotter)
VTKPlotter.interactive = new_instancemethod(_io.VTKPlotter_interactive, None, VTKPlotter)
VTKPlotter.write_png = new_instancemethod(_io.VTKPlotter_write_png, None, VTKPlotter)
VTKPlotter.write_pdf = new_instancemethod(_io.VTKPlotter_write_pdf, None, VTKPlotter)
VTKPlotter.key = new_instancemethod(_io.VTKPlotter_key, None, VTKPlotter)
VTKPlotter.set_key = new_instancemethod(_io.VTKPlotter_set_key, None, VTKPlotter)
VTKPlotter.azimuth = new_instancemethod(_io.VTKPlotter_azimuth, None, VTKPlotter)
VTKPlotter.elevate = new_instancemethod(_io.VTKPlotter_elevate, None, VTKPlotter)
VTKPlotter.dolly = new_instancemethod(_io.VTKPlotter_dolly, None, VTKPlotter)
VTKPlotter.zoom = new_instancemethod(_io.VTKPlotter_zoom, None, VTKPlotter)
VTKPlotter.set_viewangle = new_instancemethod(_io.VTKPlotter_set_viewangle, None, VTKPlotter)
VTKPlotter.set_min_max = new_instancemethod(_io.VTKPlotter_set_min_max, None, VTKPlotter)
VTKPlotter.add_polygon = new_instancemethod(_io.VTKPlotter_add_polygon, None, VTKPlotter)
VTKPlotter.key_pressed = new_instancemethod(_io.VTKPlotter_key_pressed, None, VTKPlotter)
VTKPlotter.get_widget = new_instancemethod(_io.VTKPlotter_get_widget, None, VTKPlotter)
VTKPlotter_swigregister = _io.VTKPlotter_swigregister
VTKPlotter_swigregister(VTKPlotter)

def VTKPlotter_default_parameters():
    """

    Default parameter values

    """
    return _io.VTKPlotter_default_parameters()

def VTKPlotter_to_key(var):
    """

    Return default key (plotter id) of a Variable (object to plot).

    """
    return _io.VTKPlotter_to_key(var)

def VTKPlotter_all_interactive(really=False):
    """

    Make all plot windows interactive. If really is set, the interactive
    mode is entered even if 'Q' has been pressed.

    """
    return _io.VTKPlotter_all_interactive(really)

class GenericFile(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, filename, filetype):
        """

        Constructor

        """
        _io.GenericFile_swiginit(self, _io.new_GenericFile(filename, filetype))
    __swig_destroy__ = _io.delete_GenericFile
GenericFile.__rshift__ = new_instancemethod(_io.GenericFile___rshift__, None, GenericFile)
GenericFile.__lshift__ = new_instancemethod(_io.GenericFile___lshift__, None, GenericFile)
GenericFile.read = new_instancemethod(_io.GenericFile_read, None, GenericFile)
GenericFile.write = new_instancemethod(_io.GenericFile_write, None, GenericFile)
GenericFile.name = new_instancemethod(_io.GenericFile_name, None, GenericFile)
GenericFile_swigregister = _io.GenericFile_swigregister
GenericFile_swigregister(GenericFile)

class File(object):
    """

    A File represents a data file for reading and writing objects.
    Unless specified explicitly, the format is determined by the
    file name suffix.
    A list of objects that can be read/written to file can be found in
    GenericFile.h. Compatible file formats include:
        * Binary (.bin)
        * RAW    (.raw)
        * SVG    (.svg)
        * XD3    (.xd3)
        * XDMF   (.xdmf)
        * XML    (.xml)
        * XYZ    (.xyz)
        * VTK    (.pvd)

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    x3d = _io.File_x3d
    xdmf = _io.File_xdmf
    xml = _io.File_xml
    vtk = _io.File_vtk
    raw = _io.File_raw
    xyz = _io.File_xyz
    binary = _io.File_binary
    svg = _io.File_svg

    def __init__(self, *args):
        """

        **Overloaded versions**

        * File\ (filename, encoding="ascii")

          Create a file with given name

          *Arguments*
              filename (str)
                  Name of file.
              encoding (str)
                  Optional argument specifying encoding, ASCII is default.

          *Example*
              .. note::

                  No example code available for this function.

        * File\ (comm, filename, encoding="ascii")

          Create a file with given name with MPI communicator

          *Arguments*
              communicator (:py:class:`MPI`)
                  The MPI communicator.
              filename (str)
                  Name of file.
              encoding (str)
                  Optional argument specifying encoding, ascii is default.

          *Example*
              .. note::

                  No example code available for this function.

        * File\ (filename, type, encoding="ascii")

          Create a file with given name and type (format)

          *Arguments*
              filename (str)
                  Name of file.
              type (Type)
                  File format.
              encoding (str)
                  Optional argument specifying encoding, ascii is default.

          *Example*
              .. note::

                  No example code available for this function.

        * File\ (comm, filename, type, encoding="ascii")

          Create a file with given name and type (format) with MPI communicator

          *Arguments*
              communicator (:py:class:`MPI`)
                  The MPI communicator.
              filename (str)
                  Name of file.
              type (Type)
                  File format.
              encoding (str)
                  Optional argument specifying encoding, ascii is default.

          *Example*
              .. note::

                  No example code available for this function.

        * File\ (outstream)

          Create an outfile object writing to stream

          *Arguments*
              outstream (std::ostream)
                  The stream.

        """
        _io.File_swiginit(self, _io.new_File(*args))
    __swig_destroy__ = _io.delete_File

    def exists(filename):
        """

        Check if file exists

        *Arguments*
            filename (str)
                Name of file.

        *Returns*
            bool
                True if the file exists.

        """
        return _io.File_exists(filename)

    exists = staticmethod(exists)

    def create_parent_path(filename):
        """


        *Arguments*
            filename (str)
                Name of file / path.

        """
        return _io.File_create_parent_path(filename)

    create_parent_path = staticmethod(create_parent_path)

    def __rshift__(self, *args):
        """

        Read from file

        """
        return _io.File___rshift__(self, *args)


    def __lshift__(self, *args):
        """

        **Overloaded versions**

        * operator<<\ (Mesh*, mesh)

          Write Mesh to file with time

          *Example*
              .. note::

                  No example code available for this function.

        * operator<<\ (MeshFunction<int>*, f)

          Write MeshFunction to file with time

          *Example*
              .. note::

                  No example code available for this function.

        * operator<<\ (f)

          Write MeshFunction to file with time

          *Example*
              .. note::

                  No example code available for this function.

        * operator<<\ (MeshFunction<double>*, f)

          Write MeshFunction to file with time

          *Example*
              .. note::

                  No example code available for this function.

        * operator<<\ (MeshFunction<bool>*, f)

          Write MeshFunction to file with time

          *Example*
              .. note::

                  No example code available for this function.

        * operator<<\ (Function*, u)

          Write Function to file with time

          *Example*
              .. note::

                  No example code available for this function.

        * operator<<\ (t)

          Write object to file

        """
        return _io.File___lshift__(self, *args)


    def __enter__(self) :
        return self

    def __exit__(self, type, value, traceback) :
        pass
    # Do Nothing...
    #self.close()

File.__rshift__ = new_instancemethod(_io.File___rshift__, None, File)
File.__lshift__ = new_instancemethod(_io.File___lshift__, None, File)
File_swigregister = _io.File_swigregister
File_swigregister(File)

def File_exists(filename):
    """

    Check if file exists

    *Arguments*
        filename (str)
            Name of file.

    *Returns*
        bool
            True if the file exists.

    """
    return _io.File_exists(filename)

def File_create_parent_path(filename):
    """


    *Arguments*
        filename (str)
            Name of file / path.

    """
    return _io.File_create_parent_path(filename)

class XDMFFile(GenericFile, common.Variable):
    """

    This class supports the output of meshes and functions in XDMF
    (http://www.xdmf.org) format. It creates an XML file that describes
    the data and points to a HDF5 file that stores the actual problem
    data. Output of data in parallel is supported.

    XDMF is not suitable for checkpointing as it may decimate
    some data.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, comm, filename):
        """

        Constructor

        """
        _io.XDMFFile_swiginit(self, _io.new_XDMFFile(comm, filename))
    __swig_destroy__ = _io.delete_XDMFFile

    def read(self, mesh, use_partition_from_file):
        """

        Read in a mesh from the associated HDF5 file,
        optionally using stored partitioning, if possible
        when the same number of processes are being used.

        """
        return _io.XDMFFile_read(self, mesh, use_partition_from_file)


    def write_quadratic(self, u_geom, u_val):
        """

        Save a quadratic Function to a quadratic Mesh defined
        by a geometry Function

        """
        return _io.XDMFFile_write_quadratic(self, u_geom, u_val)


    def __lshift__(self, *args):
        """

        **Overloaded versions**

        * operator<<\ (mesh)

          Save a mesh for visualisation, with e.g. ParaView. Creates a HDF5
          file to store the mesh, and a related XDMF file with metadata.

        * operator<<\ (u)

          Save a Function to XDMF/HDF5 files for visualisation.

        * operator<<\ (Function*, ut)

          Save Function + time stamp to file

        * operator<<\ (meshfunction)

          Save MeshFunction to file

        """
        return _io.XDMFFile___lshift__(self, *args)


    def __rshift__(self, *args):
        """

        **Overloaded versions**

        * operator>>\ (mesh)

          Read in a mesh from the associated HDF5 file

        * operator>>\ (meshfunction)

          Read first MeshFunction from file

        """
        return _io.XDMFFile___rshift__(self, *args)

XDMFFile.read = new_instancemethod(_io.XDMFFile_read, None, XDMFFile)
XDMFFile.write_quadratic = new_instancemethod(_io.XDMFFile_write_quadratic, None, XDMFFile)
XDMFFile.__lshift__ = new_instancemethod(_io.XDMFFile___lshift__, None, XDMFFile)
XDMFFile.write = new_instancemethod(_io.XDMFFile_write, None, XDMFFile)
XDMFFile.__rshift__ = new_instancemethod(_io.XDMFFile___rshift__, None, XDMFFile)
XDMFFile_swigregister = _io.XDMFFile_swigregister
XDMFFile_swigregister(XDMFFile)

class HDF5File(common.Variable):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, comm, filename, file_mode):
        """

        Constructor. file_mode should "a" (append), "w" (write) or "r"
        (read).

        """
        _io.HDF5File_swiginit(self, _io.new_HDF5File(comm, filename, file_mode))
    __swig_destroy__ = _io.delete_HDF5File

    def close(self):
        """

        Close file

        """
        return _io.HDF5File_close(self)


    def write(self, *args):
        """

        **Overloaded versions**

        * write\ (points, name)

          Write points to file

        * write\ (values, name)

          Write simple vector of double to file

        * write\ (x, name)

          Write Vector to file in a format suitable for re-reading

        * write\ (mesh, name)

          Write Mesh to file in a format suitable for re-reading

        * write\ (mesh, cell_dim, name)

          Write Mesh of given cell dimension to file in a format
          suitable for re-reading

        * write\ (u, name)

          Write Function to file in a format suitable for re-reading

        * write\ (u, name, timestamp)

          Write Function to file with a timestamp

        * write\ (meshfunction, name)

          Write MeshFunction to file in a format suitable for re-reading

        * write\ (meshfunction, name)

          Write MeshFunction to file in a format suitable for re-reading

        * write\ (meshfunction, name)

          Write MeshFunction to file in a format suitable for re-reading

        * write\ (meshfunction, name)

          Write MeshFunction to file in a format suitable for re-reading

        * write\ (mesh_values, name)

          Write MeshValueCollection to file

        * write\ (mesh_values, name)

          Write MeshValueCollection to file

        * write\ (mesh_values, name)

          Write MeshValueCollection to file

        """
        return _io.HDF5File_write(self, *args)


    def read(self, *args):
        """

        **Overloaded versions**

        * read\ (x, dataset_name, use_partition_from_file)

          Read vector from file and optionally re-use any partitioning
          that is available in the file

        * read\ (u, name)

          Read Function from file and distribute data according to
          the Mesh and dofmap associated with the Function.
          If the 'name' refers to a HDF5 group, then it is assumed
          that the Function data is stored in the datasets within that group.
          If the 'name' refers to a HDF5 dataset within a group, then
          it is assumed that it is a Vector, and the Function will be filled from
          that Vector

        * read\ (mesh, name, use_partition_from_file)

          Read Mesh from file and optionally re-use any partition data
          in the file

        * read\ (meshfunction, name)

          Read MeshFunction from file

        * read\ (meshfunction, name)

          Read MeshFunction from file

        * read\ (meshfunction, name)

          Read MeshFunction from file

        * read\ (meshfunction, name)

          Read MeshFunction from file

        * read\ (mesh_values, name)

          Read MeshValueCollection from file

        * read\ (mesh_values, name)

          Read MeshValueCollection from file

        * read\ (mesh_values, name)

          Read MeshValueCollection from file

        """
        return _io.HDF5File_read(self, *args)


    def has_dataset(self, dataset_name):
        """

        Check if dataset exists in HDF5 file

        """
        return _io.HDF5File_has_dataset(self, dataset_name)


    def flush(self):
        """

        Flush buffered I/O to disk

        """
        return _io.HDF5File_flush(self)


    def __enter__(self) :
        return self

    def __exit__(self, type, value, traceback) :
        self.close()

HDF5File.close = new_instancemethod(_io.HDF5File_close, None, HDF5File)
HDF5File.write = new_instancemethod(_io.HDF5File_write, None, HDF5File)
HDF5File.read = new_instancemethod(_io.HDF5File_read, None, HDF5File)
HDF5File.has_dataset = new_instancemethod(_io.HDF5File_has_dataset, None, HDF5File)
HDF5File.attributes = new_instancemethod(_io.HDF5File_attributes, None, HDF5File)
HDF5File.flush = new_instancemethod(_io.HDF5File_flush, None, HDF5File)
HDF5File_swigregister = _io.HDF5File_swigregister
HDF5File_swigregister(HDF5File)

class HDF5Attribute(object):
    """

    HDF5Attribute gives access to the attributes of a dataset
    via set() and get() methods

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, hdf5_file_id, dataset_name):
        """

        Constructor

        """
        _io.HDF5Attribute_swiginit(self, _io.new_HDF5Attribute(hdf5_file_id, dataset_name))
    __swig_destroy__ = _io.delete_HDF5Attribute

    def exists(self, attribute_name):
        """

        Check for the existence of an attribute on a dataset

        """
        return _io.HDF5Attribute_exists(self, attribute_name)


    def type_str(self, attribute_name):
        """

        Get the type of the attribute "string", "float", "int"
        "vectorfloat", "vectorint" or "unsupported"

        """
        return _io.HDF5Attribute_type_str(self, attribute_name)


    def str(self, *args):
        """

        **Overloaded versions**

        * str\ (attribute_name)

          Get the value of the attribute in the HDF5 file
          as a string representation

        * str\ ()

          Get the names of all the attributes on this dataset

        """
        return _io.HDF5Attribute_str(self, *args)


    def list_attributes(self):
        """

        Get the names of all the attributes on this dataset as a
        std::vector<std::string>

        """
        return _io.HDF5Attribute_list_attributes(self)


    def __getitem__(self, key):
        attr_type = self.type_str(key)
        if attr_type=="string":
            return self.str(key)
        elif attr_type=="float":
            return float(self.str(key))
        elif attr_type=="int":
            return int(self.str(key))
        elif attr_type=="vectorfloat":
            return [float(x) for x in self.str(key).split(",")]
        elif attr_type=="vectorint":
            return [int(x) for x in self.str(key).split(",")]
        return None

    def __contains__(self, key):
        return self.exists(key)

    def __len__(self, key):
        return len(self.list_attributes())

    def __iter__(self):
        for key in self.list_attributes():
            yield key

    def items(self):
        "Returns a list of all key and value pairs"
        return [(key, self[key]) for key in self]

    def values(self):
        "Returns a list of all values"
        return [self[key] for key in self]

    def keys(self):
        "Returns a list of all values"
        return self.list_attributes()

    def to_dict(self):
        "Return a dict representation (copy) of all data"
        return dict(t for t in self.items())

HDF5Attribute.exists = new_instancemethod(_io.HDF5Attribute_exists, None, HDF5Attribute)
HDF5Attribute.type_str = new_instancemethod(_io.HDF5Attribute_type_str, None, HDF5Attribute)
HDF5Attribute.str = new_instancemethod(_io.HDF5Attribute_str, None, HDF5Attribute)
HDF5Attribute.list_attributes = new_instancemethod(_io.HDF5Attribute_list_attributes, None, HDF5Attribute)
HDF5Attribute.__setitem__ = new_instancemethod(_io.HDF5Attribute___setitem__, None, HDF5Attribute)
HDF5Attribute_swigregister = _io.HDF5Attribute_swigregister
HDF5Attribute_swigregister(HDF5Attribute)



