# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _fem.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_fem', [dirname(__file__)])
        except ImportError:
            import _fem
            return _fem
        if fp is not None:
            try:
                _mod = imp.load_module('_fem', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _fem = swig_import_helper()
    del swig_import_helper
else:
    import _fem
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0



def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except Exception:
    weakref_proxy = lambda x: x



_fem.SHARED_PTR_DISOWN_swigconstant(_fem)
SHARED_PTR_DISOWN = _fem.SHARED_PTR_DISOWN
import ufc

def _attach_base_to_numpy_array(obj, owner):
    return _fem._attach_base_to_numpy_array(obj, owner)
_attach_base_to_numpy_array = _fem._attach_base_to_numpy_array

def dolfin_swigversion():
    return _fem.dolfin_swigversion()
dolfin_swigversion = _fem.dolfin_swigversion

def dolfin_pythonversion():
    return _fem.dolfin_pythonversion()
dolfin_pythonversion = _fem.dolfin_pythonversion

tmp = hex(dolfin_swigversion())
__swigversion__ = "%d.%d.%d"%(tuple(map(int, [tmp[-5], tmp[-3], tmp[-2:]])))
tmp = hex(dolfin_pythonversion())
__pythonversion__ = "%d.%d.%d"%(tuple(map(lambda x: int(x,16), [tmp[2], tmp[3:5], tmp[5:7]])))
del tmp, dolfin_pythonversion, dolfin_swigversion


def has_petsc4py():
    return _fem.has_petsc4py()
has_petsc4py = _fem.has_petsc4py

def has_slepc4py():
    return _fem.has_slepc4py()
has_slepc4py = _fem.has_slepc4py
import common
class HierarchicalMesh(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, arg2):
        _fem.HierarchicalMesh_swiginit(self, _fem.new_HierarchicalMesh(arg2))
    __swig_destroy__ = _fem.delete_HierarchicalMesh
HierarchicalMesh.depth = new_instancemethod(_fem.HierarchicalMesh_depth, None, HierarchicalMesh)
HierarchicalMesh.has_parent = new_instancemethod(_fem.HierarchicalMesh_has_parent, None, HierarchicalMesh)
HierarchicalMesh.has_child = new_instancemethod(_fem.HierarchicalMesh_has_child, None, HierarchicalMesh)
HierarchicalMesh._parent = new_instancemethod(_fem.HierarchicalMesh__parent, None, HierarchicalMesh)
HierarchicalMesh._child = new_instancemethod(_fem.HierarchicalMesh__child, None, HierarchicalMesh)
HierarchicalMesh._root_node = new_instancemethod(_fem.HierarchicalMesh__root_node, None, HierarchicalMesh)
HierarchicalMesh._leaf_node = new_instancemethod(_fem.HierarchicalMesh__leaf_node, None, HierarchicalMesh)
HierarchicalMesh.set_parent = new_instancemethod(_fem.HierarchicalMesh_set_parent, None, HierarchicalMesh)
HierarchicalMesh.clear_child = new_instancemethod(_fem.HierarchicalMesh_clear_child, None, HierarchicalMesh)
HierarchicalMesh.set_child = new_instancemethod(_fem.HierarchicalMesh_set_child, None, HierarchicalMesh)
HierarchicalMesh._debug = new_instancemethod(_fem.HierarchicalMesh__debug, None, HierarchicalMesh)
HierarchicalMesh_swigregister = _fem.HierarchicalMesh_swigregister
HierarchicalMesh_swigregister(HierarchicalMesh)

import mesh
import la
class HierarchicalFunctionSpace(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, arg2):
        _fem.HierarchicalFunctionSpace_swiginit(self, _fem.new_HierarchicalFunctionSpace(arg2))
    __swig_destroy__ = _fem.delete_HierarchicalFunctionSpace
HierarchicalFunctionSpace.depth = new_instancemethod(_fem.HierarchicalFunctionSpace_depth, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace.has_parent = new_instancemethod(_fem.HierarchicalFunctionSpace_has_parent, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace.has_child = new_instancemethod(_fem.HierarchicalFunctionSpace_has_child, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace._parent = new_instancemethod(_fem.HierarchicalFunctionSpace__parent, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace._child = new_instancemethod(_fem.HierarchicalFunctionSpace__child, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace._root_node = new_instancemethod(_fem.HierarchicalFunctionSpace__root_node, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace._leaf_node = new_instancemethod(_fem.HierarchicalFunctionSpace__leaf_node, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace.set_parent = new_instancemethod(_fem.HierarchicalFunctionSpace_set_parent, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace.clear_child = new_instancemethod(_fem.HierarchicalFunctionSpace_clear_child, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace.set_child = new_instancemethod(_fem.HierarchicalFunctionSpace_set_child, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace._debug = new_instancemethod(_fem.HierarchicalFunctionSpace__debug, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace_swigregister = _fem.HierarchicalFunctionSpace_swigregister
HierarchicalFunctionSpace_swigregister(HierarchicalFunctionSpace)

class HierarchicalFunction(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, arg2):
        _fem.HierarchicalFunction_swiginit(self, _fem.new_HierarchicalFunction(arg2))
    __swig_destroy__ = _fem.delete_HierarchicalFunction
HierarchicalFunction.depth = new_instancemethod(_fem.HierarchicalFunction_depth, None, HierarchicalFunction)
HierarchicalFunction.has_parent = new_instancemethod(_fem.HierarchicalFunction_has_parent, None, HierarchicalFunction)
HierarchicalFunction.has_child = new_instancemethod(_fem.HierarchicalFunction_has_child, None, HierarchicalFunction)
HierarchicalFunction._parent = new_instancemethod(_fem.HierarchicalFunction__parent, None, HierarchicalFunction)
HierarchicalFunction._child = new_instancemethod(_fem.HierarchicalFunction__child, None, HierarchicalFunction)
HierarchicalFunction._root_node = new_instancemethod(_fem.HierarchicalFunction__root_node, None, HierarchicalFunction)
HierarchicalFunction._leaf_node = new_instancemethod(_fem.HierarchicalFunction__leaf_node, None, HierarchicalFunction)
HierarchicalFunction.set_parent = new_instancemethod(_fem.HierarchicalFunction_set_parent, None, HierarchicalFunction)
HierarchicalFunction.clear_child = new_instancemethod(_fem.HierarchicalFunction_clear_child, None, HierarchicalFunction)
HierarchicalFunction.set_child = new_instancemethod(_fem.HierarchicalFunction_set_child, None, HierarchicalFunction)
HierarchicalFunction._debug = new_instancemethod(_fem.HierarchicalFunction__debug, None, HierarchicalFunction)
HierarchicalFunction_swigregister = _fem.HierarchicalFunction_swigregister
HierarchicalFunction_swigregister(HierarchicalFunction)

import function
class HierarchicalForm(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, arg2):
        _fem.HierarchicalForm_swiginit(self, _fem.new_HierarchicalForm(arg2))
    __swig_destroy__ = _fem.delete_HierarchicalForm
HierarchicalForm.depth = new_instancemethod(_fem.HierarchicalForm_depth, None, HierarchicalForm)
HierarchicalForm.has_parent = new_instancemethod(_fem.HierarchicalForm_has_parent, None, HierarchicalForm)
HierarchicalForm.has_child = new_instancemethod(_fem.HierarchicalForm_has_child, None, HierarchicalForm)
HierarchicalForm._parent = new_instancemethod(_fem.HierarchicalForm__parent, None, HierarchicalForm)
HierarchicalForm._child = new_instancemethod(_fem.HierarchicalForm__child, None, HierarchicalForm)
HierarchicalForm._root_node = new_instancemethod(_fem.HierarchicalForm__root_node, None, HierarchicalForm)
HierarchicalForm._leaf_node = new_instancemethod(_fem.HierarchicalForm__leaf_node, None, HierarchicalForm)
HierarchicalForm.set_parent = new_instancemethod(_fem.HierarchicalForm_set_parent, None, HierarchicalForm)
HierarchicalForm.clear_child = new_instancemethod(_fem.HierarchicalForm_clear_child, None, HierarchicalForm)
HierarchicalForm.set_child = new_instancemethod(_fem.HierarchicalForm_set_child, None, HierarchicalForm)
HierarchicalForm._debug = new_instancemethod(_fem.HierarchicalForm__debug, None, HierarchicalForm)
HierarchicalForm_swigregister = _fem.HierarchicalForm_swigregister
HierarchicalForm_swigregister(HierarchicalForm)

class HierarchicalLinearVariationalProblem(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, arg2):
        _fem.HierarchicalLinearVariationalProblem_swiginit(self, _fem.new_HierarchicalLinearVariationalProblem(arg2))
    __swig_destroy__ = _fem.delete_HierarchicalLinearVariationalProblem
HierarchicalLinearVariationalProblem.depth = new_instancemethod(_fem.HierarchicalLinearVariationalProblem_depth, None, HierarchicalLinearVariationalProblem)
HierarchicalLinearVariationalProblem.has_parent = new_instancemethod(_fem.HierarchicalLinearVariationalProblem_has_parent, None, HierarchicalLinearVariationalProblem)
HierarchicalLinearVariationalProblem.has_child = new_instancemethod(_fem.HierarchicalLinearVariationalProblem_has_child, None, HierarchicalLinearVariationalProblem)
HierarchicalLinearVariationalProblem._parent = new_instancemethod(_fem.HierarchicalLinearVariationalProblem__parent, None, HierarchicalLinearVariationalProblem)
HierarchicalLinearVariationalProblem._child = new_instancemethod(_fem.HierarchicalLinearVariationalProblem__child, None, HierarchicalLinearVariationalProblem)
HierarchicalLinearVariationalProblem._root_node = new_instancemethod(_fem.HierarchicalLinearVariationalProblem__root_node, None, HierarchicalLinearVariationalProblem)
HierarchicalLinearVariationalProblem._leaf_node = new_instancemethod(_fem.HierarchicalLinearVariationalProblem__leaf_node, None, HierarchicalLinearVariationalProblem)
HierarchicalLinearVariationalProblem.set_parent = new_instancemethod(_fem.HierarchicalLinearVariationalProblem_set_parent, None, HierarchicalLinearVariationalProblem)
HierarchicalLinearVariationalProblem.clear_child = new_instancemethod(_fem.HierarchicalLinearVariationalProblem_clear_child, None, HierarchicalLinearVariationalProblem)
HierarchicalLinearVariationalProblem.set_child = new_instancemethod(_fem.HierarchicalLinearVariationalProblem_set_child, None, HierarchicalLinearVariationalProblem)
HierarchicalLinearVariationalProblem._debug = new_instancemethod(_fem.HierarchicalLinearVariationalProblem__debug, None, HierarchicalLinearVariationalProblem)
HierarchicalLinearVariationalProblem_swigregister = _fem.HierarchicalLinearVariationalProblem_swigregister
HierarchicalLinearVariationalProblem_swigregister(HierarchicalLinearVariationalProblem)

class HierarchicalNonlinearVariationalProblem(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, arg2):
        _fem.HierarchicalNonlinearVariationalProblem_swiginit(self, _fem.new_HierarchicalNonlinearVariationalProblem(arg2))
    __swig_destroy__ = _fem.delete_HierarchicalNonlinearVariationalProblem
HierarchicalNonlinearVariationalProblem.depth = new_instancemethod(_fem.HierarchicalNonlinearVariationalProblem_depth, None, HierarchicalNonlinearVariationalProblem)
HierarchicalNonlinearVariationalProblem.has_parent = new_instancemethod(_fem.HierarchicalNonlinearVariationalProblem_has_parent, None, HierarchicalNonlinearVariationalProblem)
HierarchicalNonlinearVariationalProblem.has_child = new_instancemethod(_fem.HierarchicalNonlinearVariationalProblem_has_child, None, HierarchicalNonlinearVariationalProblem)
HierarchicalNonlinearVariationalProblem._parent = new_instancemethod(_fem.HierarchicalNonlinearVariationalProblem__parent, None, HierarchicalNonlinearVariationalProblem)
HierarchicalNonlinearVariationalProblem._child = new_instancemethod(_fem.HierarchicalNonlinearVariationalProblem__child, None, HierarchicalNonlinearVariationalProblem)
HierarchicalNonlinearVariationalProblem._root_node = new_instancemethod(_fem.HierarchicalNonlinearVariationalProblem__root_node, None, HierarchicalNonlinearVariationalProblem)
HierarchicalNonlinearVariationalProblem._leaf_node = new_instancemethod(_fem.HierarchicalNonlinearVariationalProblem__leaf_node, None, HierarchicalNonlinearVariationalProblem)
HierarchicalNonlinearVariationalProblem.set_parent = new_instancemethod(_fem.HierarchicalNonlinearVariationalProblem_set_parent, None, HierarchicalNonlinearVariationalProblem)
HierarchicalNonlinearVariationalProblem.clear_child = new_instancemethod(_fem.HierarchicalNonlinearVariationalProblem_clear_child, None, HierarchicalNonlinearVariationalProblem)
HierarchicalNonlinearVariationalProblem.set_child = new_instancemethod(_fem.HierarchicalNonlinearVariationalProblem_set_child, None, HierarchicalNonlinearVariationalProblem)
HierarchicalNonlinearVariationalProblem._debug = new_instancemethod(_fem.HierarchicalNonlinearVariationalProblem__debug, None, HierarchicalNonlinearVariationalProblem)
HierarchicalNonlinearVariationalProblem_swigregister = _fem.HierarchicalNonlinearVariationalProblem_swigregister
HierarchicalNonlinearVariationalProblem_swigregister(HierarchicalNonlinearVariationalProblem)

class HierarchicalDirichletBC(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, arg2):
        _fem.HierarchicalDirichletBC_swiginit(self, _fem.new_HierarchicalDirichletBC(arg2))
    __swig_destroy__ = _fem.delete_HierarchicalDirichletBC
HierarchicalDirichletBC.depth = new_instancemethod(_fem.HierarchicalDirichletBC_depth, None, HierarchicalDirichletBC)
HierarchicalDirichletBC.has_parent = new_instancemethod(_fem.HierarchicalDirichletBC_has_parent, None, HierarchicalDirichletBC)
HierarchicalDirichletBC.has_child = new_instancemethod(_fem.HierarchicalDirichletBC_has_child, None, HierarchicalDirichletBC)
HierarchicalDirichletBC._parent = new_instancemethod(_fem.HierarchicalDirichletBC__parent, None, HierarchicalDirichletBC)
HierarchicalDirichletBC._child = new_instancemethod(_fem.HierarchicalDirichletBC__child, None, HierarchicalDirichletBC)
HierarchicalDirichletBC._root_node = new_instancemethod(_fem.HierarchicalDirichletBC__root_node, None, HierarchicalDirichletBC)
HierarchicalDirichletBC._leaf_node = new_instancemethod(_fem.HierarchicalDirichletBC__leaf_node, None, HierarchicalDirichletBC)
HierarchicalDirichletBC.set_parent = new_instancemethod(_fem.HierarchicalDirichletBC_set_parent, None, HierarchicalDirichletBC)
HierarchicalDirichletBC.clear_child = new_instancemethod(_fem.HierarchicalDirichletBC_clear_child, None, HierarchicalDirichletBC)
HierarchicalDirichletBC.set_child = new_instancemethod(_fem.HierarchicalDirichletBC_set_child, None, HierarchicalDirichletBC)
HierarchicalDirichletBC._debug = new_instancemethod(_fem.HierarchicalDirichletBC__debug, None, HierarchicalDirichletBC)
HierarchicalDirichletBC_swigregister = _fem.HierarchicalDirichletBC_swigregister
HierarchicalDirichletBC_swigregister(HierarchicalDirichletBC)

class GenericDofMap(common.Variable):
    """

    This class provides a generic interface for dof maps

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def is_view(self):
        """

        True if dof map is a view into another map (is a sub-dofmap)

        """
        return _fem.GenericDofMap_is_view(self)


    def global_dimension(self):
        """

        Return the dimension of the global finite element function
        space

        """
        return _fem.GenericDofMap_global_dimension(self)


    def local_dimension(self, type):
        """

        Return number of owned (type="owned"), unowned
        (type="unowned"), or all (type="all") dofs in the map on this
        process

        """
        return _fem.GenericDofMap_local_dimension(self, type)


    def cell_dimension(self, index):
        """

        Return the dimension of the local finite element function
        space on a cell (deprecated API)

        """
        return _fem.GenericDofMap_cell_dimension(self, index)


    def max_cell_dimension(self):
        """

        Return the maximum dimension of the local finite element
        function space (deprecated API)

        """
        return _fem.GenericDofMap_max_cell_dimension(self)


    def num_element_dofs(self, index):
        """

        Return the dimension of the local finite element function
        space on a cell

        """
        return _fem.GenericDofMap_num_element_dofs(self, index)


    def max_element_dofs(self):
        """

        Return the maximum dimension of the local finite element
        function space

        """
        return _fem.GenericDofMap_max_element_dofs(self)


    def num_entity_dofs(self, dim):
        """

        Return the number of dofs for a given entity dimension

        """
        return _fem.GenericDofMap_num_entity_dofs(self, dim)


    def num_facet_dofs(self):
        """

        Return number of facet dofs

        """
        return _fem.GenericDofMap_num_facet_dofs(self)


    def ownership_range(self):
        """

        Return the ownership range (dofs in this range are owned by
        this process)

        """
        return _fem.GenericDofMap_ownership_range(self)


    def off_process_owner(self):
        """

        Return map from nonlocal-dofs (that appear in local dof map)
        to owning process

        """
        return _fem.GenericDofMap_off_process_owner(self)


    def tabulate_facet_dofs(self, local_facet):
        """

        Tabulate local-local facet dofs

        """
        return _fem.GenericDofMap_tabulate_facet_dofs(self, local_facet)


    def tabulate_entity_dofs(self, dim, local_entity):
        """

        Tabulate the local-to-local mapping of dofs on entity
        (dim, local_entity)

        """
        return _fem.GenericDofMap_tabulate_entity_dofs(self, dim, local_entity)


    def tabulate_all_coordinates(self, mesh):
        """

        Tabulate the coordinates of all dofs owned by this
        process. This function is typically used by preconditioners
        that require the spatial coordinates of dofs, for example
        for re-partitioning or nullspace computations. The format for
        the return vector is [x0, y0, z0, x1, y1, z1, . . .].

        """
        return _fem.GenericDofMap_tabulate_all_coordinates(self, mesh)


    def copy(self):
        """

        Create a copy of the dof map

        """
        return _fem.GenericDofMap_copy(self)


    def create(self, new_mesh):
        """

        Create a new dof map on new mesh

        """
        return _fem.GenericDofMap_create(self, new_mesh)


    def extract_sub_dofmap(self, component, mesh):
        """

        Extract sub dofmap component

        """
        return _fem.GenericDofMap_extract_sub_dofmap(self, component, mesh)


    def collapse(self, mesh):
        """

        Create a "collapsed" a dofmap (collapses from a sub-dofmap view)

        """
        return _fem.GenericDofMap_collapse(self, mesh)


    def dofs(self, *args):
        """

        **Overloaded versions**

        * dofs\ (mesh, dim)

          Return list of dof indices on this process that belong to mesh
          entities of dimension dim

        * dofs\ ()

          Return list of global dof indices on this process

        """
        return _fem.GenericDofMap_dofs(self, *args)


    def set(self, x, value):
        """

        Set dof entries in vector to a specified value. Parallel
        layout of vector must be consistent with dof map range. This
        function is typically used to construct the null space of a
        matrix operator

        """
        return _fem.GenericDofMap_set(self, x, value)


    def set_x(self, x, value, component, mesh):
        """

        Set dof entries in vector to the value*x[i], where x[i] is the
        spatial coordinate of the dof. Parallel layout of vector must
        be consistent with dof map range. This function is typically
        used to construct the null space of a matrix operator, e.g. rigid
        body rotations.

        """
        return _fem.GenericDofMap_set_x(self, x, value, component, mesh)


    def local_to_global_unowned(self):
        """

        Return the map from unowned local dofmap nodes to global dofmap
        nodes. Dofmap node is dof index modulo block size.

        """
        return _fem.GenericDofMap_local_to_global_unowned(self)


    def tabulate_local_to_global_dofs(self):
        """

        Tabulate map between local (process) and global dof indices

        """
        return _fem.GenericDofMap_tabulate_local_to_global_dofs(self)


    def local_to_global_index(self, local_index):
        """

        Return global dof index corresponding to a given local index

        """
        return _fem.GenericDofMap_local_to_global_index(self, local_index)


    def shared_nodes(self):
        """

        Return map from shared nodes to the processes (not including
        the current process) that share it.

        """
        return _fem.GenericDofMap_shared_nodes(self)


    def neighbours(self):
        """

        Return set of processes that share dofs with the this process

        """
        return _fem.GenericDofMap_neighbours(self)


    def clear_sub_map_data(self):
        """

        Clear any data required to build sub-dofmaps (this is to
        reduce memory use)

        """
        return _fem.GenericDofMap_clear_sub_map_data(self)

    constrained_domain = _swig_property(_fem.GenericDofMap_constrained_domain_get, _fem.GenericDofMap_constrained_domain_set)
    block_size = _swig_property(_fem.GenericDofMap_block_size_get, _fem.GenericDofMap_block_size_set)

    def cell_dofs(self, i):
        "Return the dofmap for a cell"
        return self._cell_dofs(i)


    def tabulate_coordinates(self, cell, coordinates=None):
        """ Tabulate the coordinates of all dofs on a cell

        *Arguments*
            cell (_Cell_)
                 The cell.
            coordinates (NumPy array)
                 Optional argument: The coordinates of all dofs on a cell.
        *Returns*
            coordinates
                 The coordinates of all dofs on a cell.
        """
        import numpy as np

    # Check coordinate argument
        gdim = cell.mesh().geometry().dim()
        shape = (self.max_element_dofs(), gdim)
        if coordinates is None:
            coordinates = np.zeros(shape, 'd')
        if not isinstance(coordinates, np.ndarray) or \
           not (coordinates.flags.c_contiguous and \
                coordinates.dtype == np.dtype('d') and \
                coordinates.shape==shape):
            raise TypeError("expected a C-contiguous numpy array " \
                  "of 'double' (dtype='d') with shape %s"%str(shape))

    # Call the extended method
        self._tabulate_coordinates(coordinates, cell)
        return coordinates

    __swig_destroy__ = _fem.delete_GenericDofMap
GenericDofMap.is_view = new_instancemethod(_fem.GenericDofMap_is_view, None, GenericDofMap)
GenericDofMap.global_dimension = new_instancemethod(_fem.GenericDofMap_global_dimension, None, GenericDofMap)
GenericDofMap.local_dimension = new_instancemethod(_fem.GenericDofMap_local_dimension, None, GenericDofMap)
GenericDofMap.cell_dimension = new_instancemethod(_fem.GenericDofMap_cell_dimension, None, GenericDofMap)
GenericDofMap.max_cell_dimension = new_instancemethod(_fem.GenericDofMap_max_cell_dimension, None, GenericDofMap)
GenericDofMap.num_element_dofs = new_instancemethod(_fem.GenericDofMap_num_element_dofs, None, GenericDofMap)
GenericDofMap.max_element_dofs = new_instancemethod(_fem.GenericDofMap_max_element_dofs, None, GenericDofMap)
GenericDofMap.num_entity_dofs = new_instancemethod(_fem.GenericDofMap_num_entity_dofs, None, GenericDofMap)
GenericDofMap.num_facet_dofs = new_instancemethod(_fem.GenericDofMap_num_facet_dofs, None, GenericDofMap)
GenericDofMap.ownership_range = new_instancemethod(_fem.GenericDofMap_ownership_range, None, GenericDofMap)
GenericDofMap.off_process_owner = new_instancemethod(_fem.GenericDofMap_off_process_owner, None, GenericDofMap)
GenericDofMap.tabulate_facet_dofs = new_instancemethod(_fem.GenericDofMap_tabulate_facet_dofs, None, GenericDofMap)
GenericDofMap.tabulate_entity_dofs = new_instancemethod(_fem.GenericDofMap_tabulate_entity_dofs, None, GenericDofMap)
GenericDofMap.tabulate_all_coordinates = new_instancemethod(_fem.GenericDofMap_tabulate_all_coordinates, None, GenericDofMap)
GenericDofMap.copy = new_instancemethod(_fem.GenericDofMap_copy, None, GenericDofMap)
GenericDofMap.create = new_instancemethod(_fem.GenericDofMap_create, None, GenericDofMap)
GenericDofMap.extract_sub_dofmap = new_instancemethod(_fem.GenericDofMap_extract_sub_dofmap, None, GenericDofMap)
GenericDofMap.collapse = new_instancemethod(_fem.GenericDofMap_collapse, None, GenericDofMap)
GenericDofMap.dofs = new_instancemethod(_fem.GenericDofMap_dofs, None, GenericDofMap)
GenericDofMap.set = new_instancemethod(_fem.GenericDofMap_set, None, GenericDofMap)
GenericDofMap.set_x = new_instancemethod(_fem.GenericDofMap_set_x, None, GenericDofMap)
GenericDofMap.local_to_global_unowned = new_instancemethod(_fem.GenericDofMap_local_to_global_unowned, None, GenericDofMap)
GenericDofMap.tabulate_local_to_global_dofs = new_instancemethod(_fem.GenericDofMap_tabulate_local_to_global_dofs, None, GenericDofMap)
GenericDofMap.local_to_global_index = new_instancemethod(_fem.GenericDofMap_local_to_global_index, None, GenericDofMap)
GenericDofMap.shared_nodes = new_instancemethod(_fem.GenericDofMap_shared_nodes, None, GenericDofMap)
GenericDofMap.neighbours = new_instancemethod(_fem.GenericDofMap_neighbours, None, GenericDofMap)
GenericDofMap.clear_sub_map_data = new_instancemethod(_fem.GenericDofMap_clear_sub_map_data, None, GenericDofMap)
GenericDofMap._cell_dofs = new_instancemethod(_fem.GenericDofMap__cell_dofs, None, GenericDofMap)
GenericDofMap._tabulate_coordinates = new_instancemethod(_fem.GenericDofMap__tabulate_coordinates, None, GenericDofMap)
GenericDofMap_swigregister = _fem.GenericDofMap_swigregister
GenericDofMap_swigregister(GenericDofMap)

class DofMap(GenericDofMap):
    """

    This class handles the mapping of degrees of freedom. It builds
    a dof map based on a ufc::dofmap on a specific mesh. It will
    reorder the dofs when running in parallel. Sub-dofmaps, both
    views and copies, are supported.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * DofMap\ (ufc_dofmap, mesh)

          Create dof map on mesh (mesh is not stored)

          *Arguments*
              ufc_dofmap (ufc::dofmap)
                  The ufc::dofmap.
              mesh (:py:class:`Mesh`)
                  The mesh.

        * DofMap\ (ufc_dofmap, mesh, constrained_domain)

          Create a periodic dof map on mesh (mesh is not stored)

          *Arguments*
              ufc_dofmap (ufc::dofmap)
                  The ufc::dofmap.
              mesh (:py:class:`Mesh`)
                  The mesh.
              constrained_boundary (:py:class:`SubDomain`)
                  The subdomain marking the constrained (tied) boundaries.

        """
        _fem.DofMap_swiginit(self, _fem.new_DofMap(*args))
    __swig_destroy__ = _fem.delete_DofMap

    def dofs(self, *args):
        """

        Return list of dof indices on this process that belong to mesh
        entities of dimension dim

        """
        return _fem.DofMap_dofs(self, *args)

DofMap.dofs = new_instancemethod(_fem.DofMap_dofs, None, DofMap)
DofMap_swigregister = _fem.DofMap_swigregister
DofMap_swigregister(DofMap)


def dof_to_vertex_map(space):
    """

    Return a map between dofs indices and vertex indices

    Only works for FunctionSpace with dofs exclusively on vertices.
    For MixedFunctionSpaces vertex index is offset with the number
    of dofs per vertex. In parallel the returned map only maps local
    (to processor) dofs.

    *Arguments*
        space (:py:class:`FunctionSpace`)
            The FunctionSpace for what the dof to vertex map should be computed for

    *Returns*
        numpy.array(int)
            The dof to vertex map

    """
    return _fem.dof_to_vertex_map(space)

def vertex_to_dof_map(space):
    """

    Return a map between vertex indices and dofs indices

    Only works for FunctionSpace with dofs exclusively on vertices.
    For MixedFunctionSpaces dof index is offset with the number of
    dofs per vertex.

    *Arguments*
        space (:py:class:`FunctionSpace`)
            The FunctionSpace for what the vertex to dof map should be computed for

    *Returns*
        std::vector<dolfin::la_index>
            The vertex to dof map

    """
    return _fem.vertex_to_dof_map(space)
class Equation(object):
    """

    This class represents a variational equation lhs == rhs.
    The equation can be either linear or nonlinear:

    1. Linear (a == L), in which case a must be a bilinear form
       and L must be a linear form.

    2. Nonlinear (F == 0), in which case F must be a linear form.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * Equation\ (a, L)

          Create equation a == L

        * Equation\ (F, rhs)

          Create equation F == 0

        """
        _fem.Equation_swiginit(self, _fem.new_Equation(*args))
    __swig_destroy__ = _fem.delete_Equation

    def is_linear(self):
        """

        Check whether equation is linear

        """
        return _fem.Equation_is_linear(self)


    def lhs(self):
        """

        Return form for left-hand side

        """
        return _fem.Equation_lhs(self)


    def rhs(self):
        """

        Return form for right-hand side

        """
        return _fem.Equation_rhs(self)


    def rhs_int(self):
        """

        Return value for right-hand side

        """
        return _fem.Equation_rhs_int(self)

Equation.is_linear = new_instancemethod(_fem.Equation_is_linear, None, Equation)
Equation.lhs = new_instancemethod(_fem.Equation_lhs, None, Equation)
Equation.rhs = new_instancemethod(_fem.Equation_rhs, None, Equation)
Equation.rhs_int = new_instancemethod(_fem.Equation_rhs_int, None, Equation)
Equation_swigregister = _fem.Equation_swigregister
Equation_swigregister(Equation)

class FiniteElement(object):
    """

    This is a wrapper for a UFC finite element (ufc::finite_element).

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, element):
        """

        Create finite element from UFC finite element (data may be shared)

        """
        _fem.FiniteElement_swiginit(self, _fem.new_FiniteElement(element))
    __swig_destroy__ = _fem.delete_FiniteElement

    def signature(self):
        """

        Return a string identifying the finite element

        """
        return _fem.FiniteElement_signature(self)


    def cell_shape(self):
        """

        Return the cell shape

        """
        return _fem.FiniteElement_cell_shape(self)


    def space_dimension(self):
        """

        Return the dimension of the finite element function space

        """
        return _fem.FiniteElement_space_dimension(self)


    def value_rank(self):
        """

        Return the rank of the value space

        """
        return _fem.FiniteElement_value_rank(self)


    def value_dimension(self, i):
        """

        Return the dimension of the value space for axis i

        """
        return _fem.FiniteElement_value_dimension(self, i)


    def evaluate_basis(self, i, values, x, vertex_coordinates, cell_orientation):
        """

        Evaluate basis function i at given point in cell

        """
        return _fem.FiniteElement_evaluate_basis(self, i, values, x, vertex_coordinates, cell_orientation)


    def evaluate_basis_all(self, values, x, vertex_coordinates, cell_orientation):
        """

        Evaluate all basis functions at given point in cell

        """
        return _fem.FiniteElement_evaluate_basis_all(self, values, x, vertex_coordinates, cell_orientation)


    def evaluate_basis_derivatives(self, i, n, values, x, vertex_coordinates, cell_orientation):
        """

        Evaluate order n derivatives of basis function i at given point in cell

        """
        return _fem.FiniteElement_evaluate_basis_derivatives(self, i, n, values, x, vertex_coordinates, cell_orientation)


    def evaluate_basis_derivatives_all(self, n, values, x, vertex_coordinates, cell_orientation):
        """

        Evaluate order n derivatives of all basis functions at given
        point in cell

        """
        return _fem.FiniteElement_evaluate_basis_derivatives_all(self, n, values, x, vertex_coordinates, cell_orientation)


    def evaluate_dof(self, i, function, vertex_coordinates, cell_orientation, c):
        """

        Evaluate linear functional for dof i on the function f

        """
        return _fem.FiniteElement_evaluate_dof(self, i, function, vertex_coordinates, cell_orientation, c)


    def evaluate_dofs(self, values, f, vertex_coordinates, cell_orientation, c):
        """

        Evaluate linear functionals for all dofs on the function f

        """
        return _fem.FiniteElement_evaluate_dofs(self, values, f, vertex_coordinates, cell_orientation, c)


    def interpolate_vertex_values(self, vertex_values, coefficients, vertex_coordinates, cell_orientation, cell):
        """

        Interpolate vertex values from dof values

        """
        return _fem.FiniteElement_interpolate_vertex_values(self, vertex_values, coefficients, vertex_coordinates, cell_orientation, cell)


    def map_from_reference_cell(self, x, xhat, c):
        """

        Map coordinate xhat from reference cell to coordinate x in cell

        """
        return _fem.FiniteElement_map_from_reference_cell(self, x, xhat, c)


    def map_to_reference_cell(self, xhat, x, c):
        """

        Map from coordinate x in cell to coordinate xhat in reference cell

        """
        return _fem.FiniteElement_map_to_reference_cell(self, xhat, x, c)


    def num_sub_elements(self):
        """

        Return the number of sub elements (for a mixed element)

        """
        return _fem.FiniteElement_num_sub_elements(self)


    def hash(self):
        """

        Return simple hash of the signature string

        """
        return _fem.FiniteElement_hash(self)


    def create_sub_element(self, i):
        """

        Create a new finite element for sub element i (for a mixed element)

        """
        return _fem.FiniteElement_create_sub_element(self, i)


    def create(self):
        """

        Create a new class instance

        """
        return _fem.FiniteElement_create(self)


    def extract_sub_element(self, component):
        """

        Extract sub finite element for component

        """
        return _fem.FiniteElement_extract_sub_element(self, component)


    def ufc_element(self):
        """

        Return underlying UFC element. Intended for libray usage only
        and may change.

        """
        return _fem.FiniteElement_ufc_element(self)

FiniteElement.signature = new_instancemethod(_fem.FiniteElement_signature, None, FiniteElement)
FiniteElement.cell_shape = new_instancemethod(_fem.FiniteElement_cell_shape, None, FiniteElement)
FiniteElement.topological_dimension = new_instancemethod(_fem.FiniteElement_topological_dimension, None, FiniteElement)
FiniteElement.geometric_dimension = new_instancemethod(_fem.FiniteElement_geometric_dimension, None, FiniteElement)
FiniteElement.space_dimension = new_instancemethod(_fem.FiniteElement_space_dimension, None, FiniteElement)
FiniteElement.value_rank = new_instancemethod(_fem.FiniteElement_value_rank, None, FiniteElement)
FiniteElement.value_dimension = new_instancemethod(_fem.FiniteElement_value_dimension, None, FiniteElement)
FiniteElement.evaluate_basis = new_instancemethod(_fem.FiniteElement_evaluate_basis, None, FiniteElement)
FiniteElement.evaluate_basis_all = new_instancemethod(_fem.FiniteElement_evaluate_basis_all, None, FiniteElement)
FiniteElement.evaluate_basis_derivatives = new_instancemethod(_fem.FiniteElement_evaluate_basis_derivatives, None, FiniteElement)
FiniteElement.evaluate_basis_derivatives_all = new_instancemethod(_fem.FiniteElement_evaluate_basis_derivatives_all, None, FiniteElement)
FiniteElement.evaluate_dof = new_instancemethod(_fem.FiniteElement_evaluate_dof, None, FiniteElement)
FiniteElement.evaluate_dofs = new_instancemethod(_fem.FiniteElement_evaluate_dofs, None, FiniteElement)
FiniteElement.interpolate_vertex_values = new_instancemethod(_fem.FiniteElement_interpolate_vertex_values, None, FiniteElement)
FiniteElement.map_from_reference_cell = new_instancemethod(_fem.FiniteElement_map_from_reference_cell, None, FiniteElement)
FiniteElement.map_to_reference_cell = new_instancemethod(_fem.FiniteElement_map_to_reference_cell, None, FiniteElement)
FiniteElement.num_sub_elements = new_instancemethod(_fem.FiniteElement_num_sub_elements, None, FiniteElement)
FiniteElement.hash = new_instancemethod(_fem.FiniteElement_hash, None, FiniteElement)
FiniteElement.create_sub_element = new_instancemethod(_fem.FiniteElement_create_sub_element, None, FiniteElement)
FiniteElement.create = new_instancemethod(_fem.FiniteElement_create, None, FiniteElement)
FiniteElement.extract_sub_element = new_instancemethod(_fem.FiniteElement_extract_sub_element, None, FiniteElement)
FiniteElement.ufc_element = new_instancemethod(_fem.FiniteElement_ufc_element, None, FiniteElement)
FiniteElement_swigregister = _fem.FiniteElement_swigregister
FiniteElement_swigregister(FiniteElement)

class BasisFunction(ufc.function):
    """

    This class represents a finite element basis function. It can be
    used for computation of basis function values and derivatives.

    Evaluation of basis functions is also possible through the use
    of the functions ``evaluate_basis`` and ``evaluate_basis_derivatives``
    available in the :py:class:`FiniteElement` class. The BasisFunction class
    relies on these functions for evaluation but also implements the
    ufc::function interface which allows evaluate_dof to be
    evaluated for a basis function (on a possibly different
    element).

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, index, element, vertex_coordinates):
        """

        Create basis function with given index on element on given cell

        *Arguments*
            index (int)
                The index of the basis function.
            element (:py:class:`FiniteElement`)
                The element to create basis function on.
            cell (ufc::cell)
                The cell.

        """
        _fem.BasisFunction_swiginit(self, _fem.new_BasisFunction(index, element, vertex_coordinates))
    __swig_destroy__ = _fem.delete_BasisFunction

    def eval(self, values, x):
        """

        Evaluate basis function at given point

        *Arguments*
            values (float)
                The values of the function at the point.
            x (float)
                The coordinates of the point.

        """
        return _fem.BasisFunction_eval(self, values, x)


    def eval_derivatives(self, values, x, n):
        """

        Evaluate all order n derivatives at given point

        *Arguments*
            values (float)
                The values of derivatives at the point.
            x (float)
                The coordinates of the point.
            n (int)
                The order of derivation.

        """
        return _fem.BasisFunction_eval_derivatives(self, values, x, n)

BasisFunction.eval = new_instancemethod(_fem.BasisFunction_eval, None, BasisFunction)
BasisFunction.eval_derivatives = new_instancemethod(_fem.BasisFunction_eval_derivatives, None, BasisFunction)
BasisFunction_swigregister = _fem.BasisFunction_swigregister
BasisFunction_swigregister(BasisFunction)

class DirichletBC(HierarchicalDirichletBC, common.Variable):
    """

    This class specifies the interface for setting (strong)
    Dirichlet boundary conditions for partial differential
    equations,

    .. math::

        u = g \hbox{ on } G,

    where :math:`u` is the solution to be computed, :math:`g` is a function
    and :math:`G` is a sub domain of the mesh.

    A DirichletBC is specified by the function g, the function space
    (trial space) and boundary indicators on (a subset of) the mesh
    boundary.

    The boundary indicators may be specified in a number of
    different ways.

    The simplest approach is to specify the boundary by a :py:class:`SubDomain`
    object, using the inside() function to specify on which facets
    the boundary conditions should be applied. The boundary facets
    will then be searched for and marked *only* on the first call to
    apply. This means that the mesh could be moved after the first
    apply and the boundary markers would still remain intact.

    Alternatively, the boundary may be specified by a :py:class:`MeshFunction`
    over facets labeling all mesh facets together with a number that
    specifies which facets should be included in the boundary.

    The third option is to attach the boundary information to the
    mesh. This is handled automatically when exporting a mesh from
    for example VMTK.

    The 'method' variable may be used to specify the type of method
    used to identify degrees of freedom on the boundary. Available
    methods are: topological approach (default), geometric approach,
    and pointwise approach. The topological approach is faster, but
    will only identify degrees of freedom that are located on a
    facet that is entirely on the boundary. In particular, the
    topological approach will not identify degrees of freedom for
    discontinuous elements (which are all internal to the cell). A
    remedy for this is to use the geometric approach. In the
    geometric approach, each dof on each facet that matches the
    boundary condition will be checked. To apply pointwise boundary
    conditions e.g. pointloads, one will have to use the pointwise
    approach. The three possibilities are "topological", "geometric"
    and "pointwise".

    Note: when using "pointwise", the boolean argument `on_boundary`
    in SubDomain::inside will always be false.

    The 'check_midpoint' variable can be used to decide whether or
    not the midpoint of each facet should be checked when a
    user-defined :py:class:`SubDomain` is used to define the domain of the
    boundary condition. By default, midpoints are always checked.
    Note that this variable may be of importance close to corners,
    in which case it is sometimes important to check the midpoint to
    avoid including facets "on the diagonal close" to a corner. This
    variable is also of importance for curved boundaries (like on a
    sphere or cylinder), in which case it is important *not* to
    check the midpoint which will be located in the interior of a
    domain defined relative to a radius.

    Note that there may be caching employed in BC computation for
    performance reasons. In particular, applicable DOFs are cached
    by some methods on a first apply(). This means that changing a
    supplied object (defining boundary subdomain) after first use may
    have no effect. But this is implementation and method specific.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * DirichletBC\ (V, g, sub_domain, method="topological", check_midpoint=true)

          Create boundary condition for subdomain

          *Arguments*
              V (:py:class:`FunctionSpace`)
                  The function space.
              g (:py:class:`GenericFunction`)
                  The value.
              sub_domain (:py:class:`SubDomain`)
                  The subdomain.
              method (str)
                  Optional argument: A string specifying
                  the method to identify dofs.

        * DirichletBC\ (V, g, sub_domain, method="topological", check_midpoint=true)

          Create boundary condition for subdomain

          *Arguments*
              V (:py:class:`FunctionSpace`)
                  The function space
              g (:py:class:`GenericFunction`)
                  The value
              sub_domain (:py:class:`SubDomain`)
                  The subdomain
              method (str)
                  Optional argument: A string specifying
                  the method to identify dofs

        * DirichletBC\ (V, g, sub_domains, sub_domain, method="topological")

          Create boundary condition for subdomain specified by index

          *Arguments*
              V (:py:class:`FunctionSpace`)
                  The function space.
              g (:py:class:`GenericFunction`)
                  The value.
              sub_domains (:py:class:`MeshFunction`)
                  Subdomain markers
              sub_domain (int)
                  The subdomain index (number)
              method (str)
                  Optional argument: A string specifying the
                  method to identify dofs.

        * DirichletBC\ (V, g, sub_domains, sub_domain, method="topological")

          Create boundary condition for subdomain specified by index

          *Arguments*
              V (:py:class:`FunctionSpace`)
                  The function space.
              g (:py:class:`GenericFunction`)
                  The value.
              sub_domains (:py:class:`MeshFunction`)
                  Subdomain markers
              sub_domain (int)
                  The subdomain index (number)
              method (str)
                  Optional argument: A string specifying the
                  method to identify dofs.

        * DirichletBC\ (V, g, sub_domain, method="topological")

          Create boundary condition for boundary data included in the mesh

          *Arguments*
              V (:py:class:`FunctionSpace`)
                  The function space.
              g (:py:class:`GenericFunction`)
                  The value.
              sub_domain (int)
                  The subdomain index (number)
              method (str)
                  Optional argument: A string specifying the
                  method to identify dofs.

        * DirichletBC\ (V, g, sub_domain, method="topological")

          Create boundary condition for boundary data included in the mesh

          *Arguments*
              V (:py:class:`FunctionSpace`)
                  The function space.
              g (:py:class:`GenericFunction`)
                  The value.
              sub_domain (int)
                  The subdomain index (number)
              method (str)
                  Optional argument: A string specifying the
                  method to identify dofs.

        * DirichletBC\ (V, g, markers, method="topological")

          Create boundary condition for subdomain by boundary markers
          (cells, local facet numbers)

          *Arguments*
              V (:py:class:`FunctionSpace`)
                  The function space.
              g (:py:class:`GenericFunction`)
                  The value.
              markers (numpy.array(int))
                  Subdomain markers (facet index local to process)
              method (str)
                  Optional argument: A string specifying the
                  method to identify dofs.

        * DirichletBC\ (bc)

          Copy constructor. Either cached DOF data are copied.

          *Arguments*
              bc (:py:class:`DirichletBC`)
                  The object to be copied.

        """
        _fem.DirichletBC_swiginit(self, _fem.new_DirichletBC(*args))
    __swig_destroy__ = _fem.delete_DirichletBC

    def apply(self, *args):
        """

        **Overloaded versions**

        * apply\ (A)

          Apply boundary condition to a matrix

          *Arguments*
              A (:py:class:`GenericMatrix`)
                  The matrix to apply boundary condition to.

        * apply\ (b)

          Apply boundary condition to a vector

          *Arguments*
              b (:py:class:`GenericVector`)
                  The vector to apply boundary condition to.

        * apply\ (A, b)

          Apply boundary condition to a linear system

          *Arguments*
              A (:py:class:`GenericMatrix`)
                  The matrix to apply boundary condition to.
              b (:py:class:`GenericVector`)
                  The vector to apply boundary condition to.

        * apply\ (b, x)

          Apply boundary condition to vectors for a nonlinear problem

          *Arguments*
              b (:py:class:`GenericVector`)
                  The vector to apply boundary conditions to.
              x (:py:class:`GenericVector`)
                  Another vector (nonlinear problem).

        * apply\ (A, b, x)

          Apply boundary condition to a linear system for a nonlinear problem

          *Arguments*
              A (:py:class:`GenericMatrix`)
                  The matrix to apply boundary conditions to.
              b (:py:class:`GenericVector`)
                  The vector to apply boundary conditions to.
              x (:py:class:`GenericVector`)
                  Another vector (nonlinear problem).

        """
        return _fem.DirichletBC_apply(self, *args)


    def get_boundary_values(self, *args):
        """

        Get Dirichlet dofs and values. If a method other than 'pointwise' is
        used in parallel, the map may not be complete for local vertices since
        a vertex can have a bc applied, but the partition might not have a
        facet on the boundary. To ensure all local boundary dofs are marked,
        it is necessary to call gather() on the returned boundary values.

        *Arguments*
            boundary_values (std::unordered_map<std::size_t, double>)
                Map from dof to boundary value.
            method (str)
                Optional argument: A string specifying which
                method to use.

        """
        return _fem.DirichletBC_get_boundary_values(self, *args)


    def zero(self, A):
        """

        Make rows of matrix associated with boundary condition zero,
        useful for non-diagonal matrices in a block matrix.

        *Arguments*
            A (:py:class:`GenericMatrix`)
                The matrix

        """
        return _fem.DirichletBC_zero(self, A)


    def zero_columns(self, A, b, diag_val=0):
        """

        Make columns of matrix associated with boundary condition
        zero, and update a (right-hand side) vector to reflect the
        changes. Useful for non-diagonals.

        *Arguments*
            A (:py:class:`GenericMatrix`)
                The matrix
            b (:py:class:`GenericVector`)
                The vector
            diag_val (float)
                This parameter would normally be -1, 0 or 1.

        """
        return _fem.DirichletBC_zero_columns(self, A, b, diag_val)


    def markers(self):
        """

        Return boundary markers

        *Returns*
            numpy.array((int, int))
                Boundary markers (facets stored as pairs of cells and
                local facet numbers).

        """
        return _fem.DirichletBC_markers(self)


    def _function_space(self):
        """

        Return function space V

        *Returns*
            :py:class:`FunctionSpace`
                The function space to which boundary conditions are applied.

        """
        return _fem.DirichletBC__function_space(self)


    def value(self):
        """

        Return boundary value g

        *Returns*
            :py:class:`GenericFunction`
                The boundary values.

        """
        return _fem.DirichletBC_value(self)


    def user_sub_domain(self):
        """

        Return shared pointer to subdomain

        *Returns*
            :py:class:`SubDomain`
                Shared pointer to subdomain.

        """
        return _fem.DirichletBC_user_sub_domain(self)


    def is_compatible(self, v):
        """

        Check if given function is compatible with boundary condition
        (checking only vertex values)

        *Arguments*
            v (:py:class:`GenericFunction`)
                The function to check for compatibility
                with boundary condition.

        *Returns*
            bool
                True if compatible.

        """
        return _fem.DirichletBC_is_compatible(self, v)


    def set_value(self, g):
        """

        **Overloaded versions**

        * set_value\ (g)

          Set value g for boundary condition, domain remains unchanged

          *Arguments*
              g (:py:class:`GenericFunction`)
                  The value.

        * set_value\ (g)

          Set value g for boundary condition, domain remains unchanged

          *Arguments*
              g (:py:class:`GenericFunction`)
                  The value.

        """
        return _fem.DirichletBC_set_value(self, g)


    def homogenize(self):
        """

        Set value to 0.0

        """
        return _fem.DirichletBC_homogenize(self)


    def method(self):
        """

        Return method used for computing Dirichlet dofs

        *Returns*
            str
                Method used for computing Dirichlet dofs ("topological",
                "geometric" or "pointwise").

        """
        return _fem.DirichletBC_method(self)


    def default_parameters():
        """

        Default parameter values

        """
        return _fem.DirichletBC_default_parameters()

    default_parameters = staticmethod(default_parameters)
    _user_sub_domain = _swig_property(_fem.DirichletBC__user_sub_domain_get, _fem.DirichletBC__user_sub_domain_set)

    def function_space(self):
        "Return the FunctionSpace"
        from dolfin.functions.functionspace import FunctionSpaceFromCpp
        return FunctionSpaceFromCpp(self._function_space())

DirichletBC.apply = new_instancemethod(_fem.DirichletBC_apply, None, DirichletBC)
DirichletBC.get_boundary_values = new_instancemethod(_fem.DirichletBC_get_boundary_values, None, DirichletBC)
DirichletBC.zero = new_instancemethod(_fem.DirichletBC_zero, None, DirichletBC)
DirichletBC.zero_columns = new_instancemethod(_fem.DirichletBC_zero_columns, None, DirichletBC)
DirichletBC.markers = new_instancemethod(_fem.DirichletBC_markers, None, DirichletBC)
DirichletBC._function_space = new_instancemethod(_fem.DirichletBC__function_space, None, DirichletBC)
DirichletBC.value = new_instancemethod(_fem.DirichletBC_value, None, DirichletBC)
DirichletBC.user_sub_domain = new_instancemethod(_fem.DirichletBC_user_sub_domain, None, DirichletBC)
DirichletBC.is_compatible = new_instancemethod(_fem.DirichletBC_is_compatible, None, DirichletBC)
DirichletBC.set_value = new_instancemethod(_fem.DirichletBC_set_value, None, DirichletBC)
DirichletBC.homogenize = new_instancemethod(_fem.DirichletBC_homogenize, None, DirichletBC)
DirichletBC.method = new_instancemethod(_fem.DirichletBC_method, None, DirichletBC)
DirichletBC_swigregister = _fem.DirichletBC_swigregister
DirichletBC_swigregister(DirichletBC)

def DirichletBC_default_parameters():
    """

    Default parameter values

    """
    return _fem.DirichletBC_default_parameters()

class PointSource(object):
    """

    This class provides an easy mechanism for adding a point source
    (Dirac delta function) to the right-hand side vector in a
    variational problem. The associated function space must be
    scalar in order for the inner product with the (scalar) Dirac
    delta function to be well defined.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * PointSource\ (V, p, magnitude=1.0)

          Create point source at given point of given magnitude

        * PointSource\ (V, p, magnitude=1.0)

          Create point source at given point of given magnitude

        """
        _fem.PointSource_swiginit(self, _fem.new_PointSource(*args))
    __swig_destroy__ = _fem.delete_PointSource

    def apply(self, b):
        """

        Apply (add) point source to right-hand side vector

        """
        return _fem.PointSource_apply(self, b)

PointSource.apply = new_instancemethod(_fem.PointSource_apply, None, PointSource)
PointSource_swigregister = _fem.PointSource_swigregister
PointSource_swigregister(PointSource)


def assemble_system(*args):
    """

    **Overloaded versions**

    * assemble_system\ (A, b, a, L)

      Assemble system (A, b)

    * assemble_system\ (A, b, a, L, bc)

      Assemble system (A, b) and apply Dirichlet boundary condition

    * assemble_system\ (A, b, a, L, bcs)

      Assemble system (A, b) and apply Dirichlet boundary conditions

    * assemble_system\ (A, b, a, L, bcs, x0)

      Assemble system (A, b) on sub domains and apply Dirichlet boundary
      conditions

    """
    return _fem.assemble_system(*args)

def assemble(*args):
    """

    **Overloaded versions**

    * assemble\ (A, a)

      Assemble tensor

    * assemble\ (a)

      Assemble scalar

    """
    return _fem.assemble(*args)
class LocalSolver(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    LU = _fem.LocalSolver_LU
    Cholesky = _fem.LocalSolver_Cholesky

    def __init__(self, *args):
        """

        **Overloaded versions**

        * LocalSolver\ (a, L, solver_type=LU)

          Constructor (shared pointer version)

        * LocalSolver\ (a, solver_type=LU)

          Constructor (shared pointer version)

        """
        _fem.LocalSolver_swiginit(self, _fem.new_LocalSolver(*args))

    def solve_global_rhs(self, u):
        """

        Solve local (cell-wise) problems A_e x_e = b_e, where A_e is
        the cell matrix LHS and b_e is the global RHS vector b
        restricted to the cell, i.e. b_e may contain contributions
        from neighbouring cells. The solution is exact for the case in
        which there is no coupling between cell contributions to the
        global matrix A, e.g. the discontinuous Galerkin matrix. The
        result is copied into x.

        """
        return _fem.LocalSolver_solve_global_rhs(self, u)


    def solve_local_rhs(self, u):
        """

        Solve local (cell-wise) problems A_e x_e = b_e where A_e and
        b_e are the cell element tensors. This function is useful for
        computing (approximate) cell-wise projections, for example for
        post-processing. It much more efficient than computing global
        projections.

        """
        return _fem.LocalSolver_solve_local_rhs(self, u)


    def solve_local(self, x, b, dofmap_b):
        """

        Solve local problems for given RHS and corresponding dofmap
        for RHS

        """
        return _fem.LocalSolver_solve_local(self, x, b, dofmap_b)


    def factorize(self):
        """

        Factorise LHS for all cells and store

        """
        return _fem.LocalSolver_factorize(self)


    def clear_factorization(self):
        """

        Reset (clear) any stored factorisations

        """
        return _fem.LocalSolver_clear_factorization(self)

    __swig_destroy__ = _fem.delete_LocalSolver
LocalSolver.solve_global_rhs = new_instancemethod(_fem.LocalSolver_solve_global_rhs, None, LocalSolver)
LocalSolver.solve_local_rhs = new_instancemethod(_fem.LocalSolver_solve_local_rhs, None, LocalSolver)
LocalSolver.solve_local = new_instancemethod(_fem.LocalSolver_solve_local, None, LocalSolver)
LocalSolver.factorize = new_instancemethod(_fem.LocalSolver_factorize, None, LocalSolver)
LocalSolver.clear_factorization = new_instancemethod(_fem.LocalSolver_clear_factorization, None, LocalSolver)
LocalSolver_swigregister = _fem.LocalSolver_swigregister
LocalSolver_swigregister(LocalSolver)

class Form(HierarchicalForm):
    """

    Base class for UFC code generated by FFC for DOLFIN with option -l.

    A note on the order of trial and test spaces: FEniCS numbers
    argument spaces starting with the leading dimension of the
    corresponding tensor (matrix). In other words, the test space is
    numbered 0 and the trial space is numbered 1. However, in order
    to have a notation that agrees with most existing finite element
    literature, in particular

        a = a(u, v)

    the spaces are numbered from right to

        a: V_1 x V_0 -> R

    .. note::

        Figure out how to write this in math mode without it getting
        messed up in the Python version.

    This is reflected in the ordering of the spaces that should be
    supplied to generated subclasses. In particular, when a bilinear
    form is initialized, it should be initialized as

    .. code-block:: c++

        a(V_1, V_0) = ...

    where ``V_1`` is the trial space and ``V_0`` is the test space.
    However, when a form is initialized by a list of argument spaces
    (the variable ``function_spaces`` in the constructors below, the
    list of spaces should start with space number 0 (the test space)
    and then space number 1 (the trial space).

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * Form\ (rank, num_coefficients)

          Create form of given rank with given number of coefficients

          *Arguments*
              rank (int)
                  The rank.
              num_coefficients (int)
                  The number of coefficients.

        * Form\ (ufc_form, function_spaces, coefficients)

          Create form (shared data)

          *Arguments*
              ufc_form (ufc::form)
                  The UFC form.
              function_spaces (list of :py:class:`FunctionSpace`)
                  Vector of function spaces.
              coefficients (list of :py:class:`GenericFunction`)
                  Vector of coefficients.

        """
        _fem.Form_swiginit(self, _fem.new_Form(*args))
    __swig_destroy__ = _fem.delete_Form

    def rank(self):
        """

        Return rank of form (bilinear form = 2, linear form = 1,
        functional = 0, etc)

        *Returns*
            int
                The rank of the form.

        """
        return _fem.Form_rank(self)


    def num_coefficients(self):
        """

        Return number of coefficients

        *Returns*
            int
                The number of coefficients.

        """
        return _fem.Form_num_coefficients(self)


    def coloring(self, entity_dim):
        """

        Return coloring type for colored (multi-threaded) assembly of form
        over a mesh entity of a given dimension

        *Arguments*
            entity_dim (int)
                Dimension.

        *Returns*
            numpy.array(int)
                Coloring type.

        """
        return _fem.Form_coloring(self, entity_dim)


    def set_mesh(self, mesh):
        """

        Set mesh, necessary for functionals when there are no function spaces

        *Arguments*
            mesh (:py:class:`Mesh`)
                The mesh.

        """
        return _fem.Form_set_mesh(self, mesh)


    def mesh(self):
        """

        Extract common mesh from form

        *Returns*
            :py:class:`Mesh`
                The mesh.

        """
        return _fem.Form_mesh(self)


    def mesh_shared_ptr(self):
        """

        Return mesh shared pointer (if any)

        *Returns*
            :py:class:`Mesh`
                The mesh shared pointer.

        """
        return _fem.Form_mesh_shared_ptr(self)


    def _function_space(self, i):
        """

        Return function space for given argument

        *Arguments*
            i (int)
                Index

        *Returns*
            :py:class:`FunctionSpace`
                Function space shared pointer.

        """
        return _fem.Form__function_space(self, i)


    def function_spaces(self):
        """

        Return function spaces for arguments

        *Returns*
            list of :py:class:`FunctionSpace`
                Vector of function space shared pointers.

        """
        return _fem.Form_function_spaces(self)


    def set_coefficient(self, *args):
        """

        **Overloaded versions**

        * set_coefficient\ (i, coefficient)

          Set coefficient with given number (shared pointer version)

          *Arguments*
              i (int)
                  The given number.
              coefficient (:py:class:`GenericFunction`)
                  The coefficient.

        * set_coefficient\ (name, coefficient)

          Set coefficient with given name (shared pointer version)

          *Arguments*
              name (str)
                  The name.
              coefficient (:py:class:`GenericFunction`)
                  The coefficient.

        """
        return _fem.Form_set_coefficient(self, *args)


    def set_coefficients(self, coefficients):
        """

        Set all coefficients in given map. All coefficients in the
        given map, which may contain only a subset of the coefficients
        of the form, will be set.

        *Arguments*
            coefficients (:py:class:`GenericFunction`)
                The map of coefficients.

        """
        return _fem.Form_set_coefficients(self, coefficients)


    def set_some_coefficients(self, coefficients):
        """

        Set some coefficients in given map. Each coefficient in the
        given map will be set, if the name of the coefficient matches
        the name of a coefficient in the form.

        This is useful when reusing the same coefficient map for
        several forms, or when some part of the form has been
        outcommented (for testing) in the UFL file, which means that
        the coefficient and attaching it to the form does not need to
        be outcommented in a C++ program using code from the generated
        UFL file.

        *Arguments*
            coefficients (:py:class:`GenericFunction`)
                The map of coefficients.

        """
        return _fem.Form_set_some_coefficients(self, coefficients)


    def coefficient(self, *args):
        """

        **Overloaded versions**

        * coefficient\ (i)

          Return coefficient with given number

          *Arguments*
              i (int)
                  Index

          *Returns*
              :py:class:`GenericFunction`
                  The coefficient.

        * coefficient\ (name)

          Return coefficient with given name

          *Arguments*
              name (str)
                  The name.

          *Returns*
              :py:class:`GenericFunction`
                  The coefficient.

        """
        return _fem.Form_coefficient(self, *args)


    def coefficients(self):
        """

        Return all coefficients

        *Returns*
            list of :py:class:`GenericFunction`
                All coefficients.

        """
        return _fem.Form_coefficients(self)


    def coefficient_number(self, name):
        """

        Return the number of the coefficient with this name

        *Arguments*
            name (str)
                The name.

        *Returns*
            int
                The number of the coefficient with the given name.

        """
        return _fem.Form_coefficient_number(self, name)


    def coefficient_name(self, i):
        """

        Return the name of the coefficient with this number

        *Arguments*
            i (int)
                The number

        *Returns*
            str
                The name of the coefficient with the given number.

        """
        return _fem.Form_coefficient_name(self, i)


    def cell_domains(self):
        """

        Return cell domains (zero pointer if no domains have been
        specified)

        *Returns*
            :py:class:`MeshFunction`
                The cell domains.

        """
        return _fem.Form_cell_domains(self)


    def exterior_facet_domains(self):
        """

        Return exterior facet domains (zero pointer if no domains have
        been specified)

        *Returns*
            :py:class:`MeshFunction`
                The exterior facet domains.

        """
        return _fem.Form_exterior_facet_domains(self)


    def interior_facet_domains(self):
        """

        Return interior facet domains (zero pointer if no domains have
        been specified)

        *Returns*
            :py:class:`MeshFunction`
                The interior facet domains.

        """
        return _fem.Form_interior_facet_domains(self)


    def vertex_domains(self):
        """

        Return vertex domains (zero pointer if no domains have been
        specified)

        *Returns*
            :py:class:`MeshFunction`
                The vertex domains.

        """
        return _fem.Form_vertex_domains(self)


    def set_cell_domains(self, cell_domains):
        """

        Set cell domains

        *Arguments*
            cell_domains (:py:class:`MeshFunction`)
                The cell domains.

        """
        return _fem.Form_set_cell_domains(self, cell_domains)


    def set_exterior_facet_domains(self, exterior_facet_domains):
        """

        Set exterior facet domains

        *Arguments*
            exterior_facet_domains (:py:class:`MeshFunction`)
                The exterior facet domains.

        """
        return _fem.Form_set_exterior_facet_domains(self, exterior_facet_domains)


    def set_interior_facet_domains(self, interior_facet_domains):
        """

        Set interior facet domains

        *Arguments*
            interior_facet_domains (:py:class:`MeshFunction`)
                The interior facet domains.

        """
        return _fem.Form_set_interior_facet_domains(self, interior_facet_domains)


    def set_vertex_domains(self, vertex_domains):
        """

        Set vertex domains

        *Arguments*
            vertex_domains (:py:class:`MeshFunction`)
                The vertex domains.

        """
        return _fem.Form_set_vertex_domains(self, vertex_domains)


    def ufc_form(self):
        """

        Return UFC form shared pointer

        *Returns*
            ufc::form
                The UFC form.

        """
        return _fem.Form_ufc_form(self)


    def check(self):
        """

        Check function spaces and coefficients

        """
        return _fem.Form_check(self)


    def function_space(self, i):
        """
        Return function space for given argument

         *Arguments*
             i (std::size_t)
                 Index

         *Returns*
             _FunctionSpace_
                 Function space shared pointer.
        """
        from dolfin.functions.functionspace import FunctionSpaceFromCpp
        return FunctionSpaceFromCpp(self._function_space(i))

Form.rank = new_instancemethod(_fem.Form_rank, None, Form)
Form.num_coefficients = new_instancemethod(_fem.Form_num_coefficients, None, Form)
Form.coloring = new_instancemethod(_fem.Form_coloring, None, Form)
Form.set_mesh = new_instancemethod(_fem.Form_set_mesh, None, Form)
Form.mesh = new_instancemethod(_fem.Form_mesh, None, Form)
Form.mesh_shared_ptr = new_instancemethod(_fem.Form_mesh_shared_ptr, None, Form)
Form._function_space = new_instancemethod(_fem.Form__function_space, None, Form)
Form.function_spaces = new_instancemethod(_fem.Form_function_spaces, None, Form)
Form.set_coefficient = new_instancemethod(_fem.Form_set_coefficient, None, Form)
Form.set_coefficients = new_instancemethod(_fem.Form_set_coefficients, None, Form)
Form.set_some_coefficients = new_instancemethod(_fem.Form_set_some_coefficients, None, Form)
Form.coefficient = new_instancemethod(_fem.Form_coefficient, None, Form)
Form.coefficients = new_instancemethod(_fem.Form_coefficients, None, Form)
Form.coefficient_number = new_instancemethod(_fem.Form_coefficient_number, None, Form)
Form.coefficient_name = new_instancemethod(_fem.Form_coefficient_name, None, Form)
Form.cell_domains = new_instancemethod(_fem.Form_cell_domains, None, Form)
Form.exterior_facet_domains = new_instancemethod(_fem.Form_exterior_facet_domains, None, Form)
Form.interior_facet_domains = new_instancemethod(_fem.Form_interior_facet_domains, None, Form)
Form.vertex_domains = new_instancemethod(_fem.Form_vertex_domains, None, Form)
Form.set_cell_domains = new_instancemethod(_fem.Form_set_cell_domains, None, Form)
Form.set_exterior_facet_domains = new_instancemethod(_fem.Form_set_exterior_facet_domains, None, Form)
Form.set_interior_facet_domains = new_instancemethod(_fem.Form_set_interior_facet_domains, None, Form)
Form.set_vertex_domains = new_instancemethod(_fem.Form_set_vertex_domains, None, Form)
Form.ufc_form = new_instancemethod(_fem.Form_ufc_form, None, Form)
Form.check = new_instancemethod(_fem.Form_check, None, Form)
Form_swigregister = _fem.Form_swigregister
Form_swigregister(Form)

class AssemblerBase(object):
    """

    This class provides some common functions used in assembler
    classes.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """

        Constructor

        """
        _fem.AssemblerBase_swiginit(self, _fem.new_AssemblerBase())
    add_values = _swig_property(_fem.AssemblerBase_add_values_get, _fem.AssemblerBase_add_values_set)
    finalize_tensor = _swig_property(_fem.AssemblerBase_finalize_tensor_get, _fem.AssemblerBase_finalize_tensor_set)
    keep_diagonal = _swig_property(_fem.AssemblerBase_keep_diagonal_get, _fem.AssemblerBase_keep_diagonal_set)
    __swig_destroy__ = _fem.delete_AssemblerBase
AssemblerBase.init_global_tensor = new_instancemethod(_fem.AssemblerBase_init_global_tensor, None, AssemblerBase)
AssemblerBase_swigregister = _fem.AssemblerBase_swigregister
AssemblerBase_swigregister(AssemblerBase)

class Assembler(AssemblerBase):
    """

    This class provides automated assembly of linear systems, or
    more generally, assembly of a sparse tensor from a given
    variational form.

    Subdomains for cells and facets may be specified by assigning
    subdomain indicators specified by :py:class:`MeshFunction` to the :py:class:`Form`
    being assembled:

       .. code-block:: c++

           form.dx = cell_domains
           form.ds = exterior_facet_domains
           form.dS = interior_facet_domains

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """

        Constructor

        """
        _fem.Assembler_swiginit(self, _fem.new_Assembler())

    def assemble(self, A, a):
        """

        Assemble tensor from given form

        *Arguments*
            A (:py:class:`GenericTensor`)
                The tensor to assemble.
            a (:py:class:`Form`)
                The form to assemble the tensor from.

        """
        return _fem.Assembler_assemble(self, A, a)


    def assemble_cells(self, A, a, ufc, domains, values):
        """

        Assemble tensor from given form over cells. This function is
        provided for users who wish to build a customized assembler.

        """
        return _fem.Assembler_assemble_cells(self, A, a, ufc, domains, values)


    def assemble_exterior_facets(self, A, a, ufc, domains, values):
        """

        Assemble tensor from given form over exterior facets. This
        function is provided for users who wish to build a customized
        assembler.

        """
        return _fem.Assembler_assemble_exterior_facets(self, A, a, ufc, domains, values)


    def assemble_interior_facets(self, A, a, ufc, domains, cell_domains, values):
        """

        Assemble tensor from given form over interior facets. This
        function is provided for users who wish to build a customized
        assembler.

        """
        return _fem.Assembler_assemble_interior_facets(self, A, a, ufc, domains, cell_domains, values)


    def assemble_vertices(self, A, a, ufc, domains):
        """

        Assemble tensor from given form over vertices. This function is
        provided for users who wish to build a customized assembler.

        """
        return _fem.Assembler_assemble_vertices(self, A, a, ufc, domains)

    __swig_destroy__ = _fem.delete_Assembler
Assembler.assemble = new_instancemethod(_fem.Assembler_assemble, None, Assembler)
Assembler.assemble_cells = new_instancemethod(_fem.Assembler_assemble_cells, None, Assembler)
Assembler.assemble_exterior_facets = new_instancemethod(_fem.Assembler_assemble_exterior_facets, None, Assembler)
Assembler.assemble_interior_facets = new_instancemethod(_fem.Assembler_assemble_interior_facets, None, Assembler)
Assembler.assemble_vertices = new_instancemethod(_fem.Assembler_assemble_vertices, None, Assembler)
Assembler_swigregister = _fem.Assembler_swigregister
Assembler_swigregister(Assembler)

class SparsityPatternBuilder(object):
    """

    This class provides functions to compute the sparsity pattern
    based on DOF maps

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def build(sparsity_pattern, mesh, dofmaps, cells, interior_facets, exterior_facets, vertices, diagonal, init=True, finalize=True):
        """

        Build sparsity pattern for assembly of given form

        """
        return _fem.SparsityPatternBuilder_build(sparsity_pattern, mesh, dofmaps, cells, interior_facets, exterior_facets, vertices, diagonal, init, finalize)

    build = staticmethod(build)

    def build_multimesh_sparsity_pattern(sparsity_pattern, form):
        """

        Build sparsity pattern for assembly of given multimesh form

        """
        return _fem.SparsityPatternBuilder_build_multimesh_sparsity_pattern(sparsity_pattern, form)

    build_multimesh_sparsity_pattern = staticmethod(build_multimesh_sparsity_pattern)

    def __init__(self):
        _fem.SparsityPatternBuilder_swiginit(self, _fem.new_SparsityPatternBuilder())
    __swig_destroy__ = _fem.delete_SparsityPatternBuilder
SparsityPatternBuilder_swigregister = _fem.SparsityPatternBuilder_swigregister
SparsityPatternBuilder_swigregister(SparsityPatternBuilder)

def SparsityPatternBuilder_build(sparsity_pattern, mesh, dofmaps, cells, interior_facets, exterior_facets, vertices, diagonal, init=True, finalize=True):
    """

    Build sparsity pattern for assembly of given form

    """
    return _fem.SparsityPatternBuilder_build(sparsity_pattern, mesh, dofmaps, cells, interior_facets, exterior_facets, vertices, diagonal, init, finalize)

def SparsityPatternBuilder_build_multimesh_sparsity_pattern(sparsity_pattern, form):
    """

    Build sparsity pattern for assembly of given multimesh form

    """
    return _fem.SparsityPatternBuilder_build_multimesh_sparsity_pattern(sparsity_pattern, form)

class SystemAssembler(AssemblerBase):
    """

    This class provides an assembler for systems of the form
    Ax = b. It differs from the default DOLFIN assembler in that it
    applies boundary conditions at the time of assembly, which
    preserves any symmetries in A.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * SystemAssembler\ (a, L)

          Constructor

        * SystemAssembler\ (a, L, bc)

          Constructor

        * SystemAssembler\ (a, L, bcs)

          Constructor

        * SystemAssembler\ (a, L)

          Constructor

        * SystemAssembler\ (a, L, bc)

          Constructor

        * SystemAssembler\ (a, L, bcs)

          Constructor

        """
        _fem.SystemAssembler_swiginit(self, _fem.new_SystemAssembler(*args))

    def assemble(self, *args):
        """

        **Overloaded versions**

        * assemble\ (A, b)

          Assemble system (A, b)

        * assemble\ (A)

          Assemble matrix A

        * assemble\ (b)

          Assemble vector b

        * assemble\ (A, b, x0)

          Assemble system (A, b) for (negative) increment dx, where x =
          x0 - dx is solution to system a == -L subject to bcs.
          Suitable for use inside a (quasi-)Newton solver.

        * assemble\ (b, x0)

          Assemble rhs vector b for (negative) increment dx, where x =
          x0 - dx is solution to system a == -L subject to bcs.
          Suitable for use inside a (quasi-)Newton solver.

        """
        return _fem.SystemAssembler_assemble(self, *args)

    __swig_destroy__ = _fem.delete_SystemAssembler
SystemAssembler.assemble = new_instancemethod(_fem.SystemAssembler_assemble, None, SystemAssembler)
SystemAssembler_swigregister = _fem.SystemAssembler_swigregister
SystemAssembler_swigregister(SystemAssembler)

class LinearVariationalProblem(HierarchicalLinearVariationalProblem):
    """

    This class represents a linear variational problem:

    Find u in V such that

        a(u, v) = L(v)  for all v in V^,

    where V is the trial space and V^ is the test space.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, a, L, u, bcs):
        """

        **Overloaded versions**

        * LinearVariationalProblem\ (a, L, u)

          Create linear variational problem without boundary conditions

        * LinearVariationalProblem\ (a, L, u, bc)

          Create linear variational problem with a single boundary condition

        * LinearVariationalProblem\ (a, L, u, bcs)

          Create linear variational problem with a list of boundary conditions

        * LinearVariationalProblem\ (a, L, u, bcs)

          Create linear variational problem with a list of boundary conditions
          (shared pointer version)

        """
        _fem.LinearVariationalProblem_swiginit(self, _fem.new_LinearVariationalProblem(a, L, u, bcs))

    def bilinear_form(self):
        """

        Return bilinear form

        """
        return _fem.LinearVariationalProblem_bilinear_form(self)


    def linear_form(self):
        """

        Return linear form

        """
        return _fem.LinearVariationalProblem_linear_form(self)


    def _solution(self, *args):
        """

        **Overloaded versions**

        * solution\ ()

          Return solution variable

        * solution\ ()

          Return solution variable (const version)

        """
        return _fem.LinearVariationalProblem__solution(self, *args)


    def bcs(self):
        """

        Return boundary conditions

        """
        return _fem.LinearVariationalProblem_bcs(self)


    def _trial_space(self):
        """

        Return trial space

        """
        return _fem.LinearVariationalProblem__trial_space(self)


    def _test_space(self):
        """

        Return test space

        """
        return _fem.LinearVariationalProblem__test_space(self)


    def solution(self):
        """
        Return the solution
        """
        from dolfin.functions.function import Function
        return Function(self._solution())

    def trial_space(self):
        """
        Return the trial space
        """
        from dolfin.functions.functionspace import FunctionSpaceFromCpp
        return FunctionSpaceFromCpp(self._trial_space())

    def test_space(self):
        """
        Return the test space
        """
        from dolfin.functions.functionspace import FunctionSpaceFromCpp
        return FunctionSpaceFromCpp(self._test_space())


    __swig_destroy__ = _fem.delete_LinearVariationalProblem
LinearVariationalProblem.bilinear_form = new_instancemethod(_fem.LinearVariationalProblem_bilinear_form, None, LinearVariationalProblem)
LinearVariationalProblem.linear_form = new_instancemethod(_fem.LinearVariationalProblem_linear_form, None, LinearVariationalProblem)
LinearVariationalProblem._solution = new_instancemethod(_fem.LinearVariationalProblem__solution, None, LinearVariationalProblem)
LinearVariationalProblem.bcs = new_instancemethod(_fem.LinearVariationalProblem_bcs, None, LinearVariationalProblem)
LinearVariationalProblem._trial_space = new_instancemethod(_fem.LinearVariationalProblem__trial_space, None, LinearVariationalProblem)
LinearVariationalProblem._test_space = new_instancemethod(_fem.LinearVariationalProblem__test_space, None, LinearVariationalProblem)
LinearVariationalProblem_swigregister = _fem.LinearVariationalProblem_swigregister
LinearVariationalProblem_swigregister(LinearVariationalProblem)

class LinearVariationalSolver(common.Variable):
    """

    This class implements a solver for linear variational problems.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, problem):
        """

        **Overloaded versions**

        * LinearVariationalSolver\ (problem)

          Create linear variational solver for given problem

        * LinearVariationalSolver\ (problem)

          Create linear variational solver for given problem (shared
          pointer version)

        """
        _fem.LinearVariationalSolver_swiginit(self, _fem.new_LinearVariationalSolver(problem))

    def solve(self):
        """

        Solve variational problem

        """
        return _fem.LinearVariationalSolver_solve(self)


    def default_parameters():
        """

        Default parameter values

        """
        return _fem.LinearVariationalSolver_default_parameters()

    default_parameters = staticmethod(default_parameters)
    __swig_destroy__ = _fem.delete_LinearVariationalSolver
LinearVariationalSolver.solve = new_instancemethod(_fem.LinearVariationalSolver_solve, None, LinearVariationalSolver)
LinearVariationalSolver_swigregister = _fem.LinearVariationalSolver_swigregister
LinearVariationalSolver_swigregister(LinearVariationalSolver)

def LinearVariationalSolver_default_parameters():
    """

    Default parameter values

    """
    return _fem.LinearVariationalSolver_default_parameters()

class NonlinearVariationalProblem(HierarchicalNonlinearVariationalProblem):
    """

    This class represents a nonlinear variational problem:

    Find u in V such that

        F(u; v) = 0  for all v in V^,

    where V is the trial space and V^ is the test space.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * NonlinearVariationalProblem\ (F, u)

          Create nonlinear variational problem without boundary
          conditions.  The Jacobian form is not specified which requires
          the use of a nonlinear solver that does not rely on the
          Jacobian.

        * NonlinearVariationalProblem\ (F, u, J)

          Create nonlinear variational problem without boundary
          conditions.  The Jacobian form is specified which allows the
          use of a nonlinear solver that relies on the Jacobian (using
          Newton's method).

        * NonlinearVariationalProblem\ (F, u, bc)

          Create nonlinear variational problem with a single boundary
          condition.  The Jacobian form is not specified which requires
          the use of a nonlinear solver that does not rely on the
          Jacobian.

        * NonlinearVariationalProblem\ (F, u, bc, J)

          Create nonlinear variational problem with a single boundary
          condition.  The Jacobian form is specified which allows the
          use of a nonlinear solver that relies on the Jacobian (using
          Newton's method).

        * NonlinearVariationalProblem\ (F, u, bcs)

          Create nonlinear variational problem with a list of boundary
          conditions.  The Jacobian form is not specified which requires
          the use of a nonlinear solver that does not rely on the
          Jacobian.

        * NonlinearVariationalProblem\ (F, u, bcs, J)

          Create nonlinear variational problem with a list of boundary
          conditions.  The Jacobian form is specified which allows the
          use of a nonlinear solver that relies on the Jacobian (using
          Newton's method).

        * NonlinearVariationalProblem\ (F, u, bcs)

          Create nonlinear variational problem, shared pointer version.
          The Jacobian form is not specified which requires the use of a
          nonlinear solver that does not rely on the Jacobian.

        * NonlinearVariationalProblem\ (F, u, bcs, J)

          Create nonlinear variational problem, shared pointer version.
          The Jacobian form is specified which allows the use of a
          nonlinear solver that relies on the Jacobian (using Newton's
          method).

        """
        _fem.NonlinearVariationalProblem_swiginit(self, _fem.new_NonlinearVariationalProblem(*args))

    def set_bounds(self, *args):
        """

        **Overloaded versions**

        * set_bounds\ (lb, ub)

          Set the bounds for bound constrained solver

        * set_bounds\ (lb, ub)

          Set the bounds for bound constrained solver

        * set_bounds\ (lb_func, ub_func)

          Set the bounds for bound constrained solver

        * set_bounds\ (lb_func, ub_func)

          Set the bounds for bound constrained solver

        """
        return _fem.NonlinearVariationalProblem_set_bounds(self, *args)


    def residual_form(self):
        """

        Return residual form

        """
        return _fem.NonlinearVariationalProblem_residual_form(self)


    def jacobian_form(self):
        """

        Return Jacobian form

        """
        return _fem.NonlinearVariationalProblem_jacobian_form(self)


    def _solution(self, *args):
        """

        **Overloaded versions**

        * solution\ ()

          Return solution variable

        * solution\ ()

          Return solution variable (const version)

        """
        return _fem.NonlinearVariationalProblem__solution(self, *args)


    def bcs(self):
        """

        Return boundary conditions

        """
        return _fem.NonlinearVariationalProblem_bcs(self)


    def _trial_space(self):
        """

        Return trial space

        """
        return _fem.NonlinearVariationalProblem__trial_space(self)


    def _test_space(self):
        """

        Return test space

        """
        return _fem.NonlinearVariationalProblem__test_space(self)


    def lower_bound(self):
        """

        Return lower bound

        """
        return _fem.NonlinearVariationalProblem_lower_bound(self)


    def upper_bound(self):
        """

        Return upper bound

        """
        return _fem.NonlinearVariationalProblem_upper_bound(self)


    def has_jacobian(self):
        """

        Check whether Jacobian has been defined

        """
        return _fem.NonlinearVariationalProblem_has_jacobian(self)


    def has_lower_bound(self):
        """

        Check whether lower bound has been defined

        """
        return _fem.NonlinearVariationalProblem_has_lower_bound(self)


    def has_upper_bound(self):
        """

        Check whether upper bound have has defined

        """
        return _fem.NonlinearVariationalProblem_has_upper_bound(self)


    def solution(self):
        """
        Return the solution
        """
        from dolfin.functions.function import Function
        return Function(self._solution())

    def trial_space(self):
        """
        Return the trial space
        """
        from dolfin.functions.functionspace import FunctionSpaceFromCpp
        return FunctionSpaceFromCpp(self._trial_space())

    def test_space(self):
        """
        Return the test space
        """
        from dolfin.functions.functionspace import FunctionSpaceFromCpp
        return FunctionSpaceFromCpp(self._test_space())


    __swig_destroy__ = _fem.delete_NonlinearVariationalProblem
NonlinearVariationalProblem.set_bounds = new_instancemethod(_fem.NonlinearVariationalProblem_set_bounds, None, NonlinearVariationalProblem)
NonlinearVariationalProblem.residual_form = new_instancemethod(_fem.NonlinearVariationalProblem_residual_form, None, NonlinearVariationalProblem)
NonlinearVariationalProblem.jacobian_form = new_instancemethod(_fem.NonlinearVariationalProblem_jacobian_form, None, NonlinearVariationalProblem)
NonlinearVariationalProblem._solution = new_instancemethod(_fem.NonlinearVariationalProblem__solution, None, NonlinearVariationalProblem)
NonlinearVariationalProblem.bcs = new_instancemethod(_fem.NonlinearVariationalProblem_bcs, None, NonlinearVariationalProblem)
NonlinearVariationalProblem._trial_space = new_instancemethod(_fem.NonlinearVariationalProblem__trial_space, None, NonlinearVariationalProblem)
NonlinearVariationalProblem._test_space = new_instancemethod(_fem.NonlinearVariationalProblem__test_space, None, NonlinearVariationalProblem)
NonlinearVariationalProblem.lower_bound = new_instancemethod(_fem.NonlinearVariationalProblem_lower_bound, None, NonlinearVariationalProblem)
NonlinearVariationalProblem.upper_bound = new_instancemethod(_fem.NonlinearVariationalProblem_upper_bound, None, NonlinearVariationalProblem)
NonlinearVariationalProblem.has_jacobian = new_instancemethod(_fem.NonlinearVariationalProblem_has_jacobian, None, NonlinearVariationalProblem)
NonlinearVariationalProblem.has_lower_bound = new_instancemethod(_fem.NonlinearVariationalProblem_has_lower_bound, None, NonlinearVariationalProblem)
NonlinearVariationalProblem.has_upper_bound = new_instancemethod(_fem.NonlinearVariationalProblem_has_upper_bound, None, NonlinearVariationalProblem)
NonlinearVariationalProblem_swigregister = _fem.NonlinearVariationalProblem_swigregister
NonlinearVariationalProblem_swigregister(NonlinearVariationalProblem)

class NonlinearVariationalSolver(common.Variable):
    """

    This class implements a solver for nonlinear variational problems.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, problem):
        """

        **Overloaded versions**

        * NonlinearVariationalSolver\ (problem)

          Create nonlinear variational solver for given problem

        * NonlinearVariationalSolver\ (problem)

          Create nonlinear variational solver for given problem (shared
          pointer version)

        """
        _fem.NonlinearVariationalSolver_swiginit(self, _fem.new_NonlinearVariationalSolver(problem))

    def solve(self, *args):
        """

        **Overloaded versions**

        * solve\ (lb, ub)

          Solve variational problem with bound constraints defined by
          GenericVectors

          *Arguments*
              lb (:py:class:`GenericVector`)
                  The linear solver.
              ub (:py:class:`GenericVector`)
                  The factory.
          *Returns*
              (int, bool)
                  Pair of number of Newton iterations, and whether
                  iteration converged)

        * solve\ (lb, ub)

          Solve variational problem with bound constraints defined by
          GenericVectors (shared pointer version)

          *Arguments*
              lb (_std::shared_ptr<const GenericVector>_)
                  The linear solver.
              ub (_std::shared_ptr<const GenericVector>_)
                  The factory.
          *Returns*
              (int, bool)
                  Pair of number of Newton iterations, and whether
                  iteration converged)

        * solve\ (lb, ub)

          Solve variational problem with bound constraints defined by Functions

          *Arguments*
              lb (:py:class:`Function`)
                  The linear solver.
              ub (:py:class:`Function`)
                  The factory.
          *Returns*
              (int, bool)
                  Pair of number of Newton iterations, and whether
                  iteration converged)

        * solve\ (lb, ub)

          Solve variational problem with bound constraints defined by
          Functions (shared pointer version)

          *Arguments*
              lb (_std::shared_ptr<const Function>_)
                  The linear solver.
              ub (_std::shared_ptr<const Function>_)
                  The factory.
          *Returns*
              (int, bool)
                  Pair of number of Newton iterations, and whether
                  iteration converged)

        * solve\ ()

          Solve variational problem

          *Returns*
              (int, bool)
                  Pair of number of Newton iterations, and whether
                  iteration converged)

        """
        return _fem.NonlinearVariationalSolver_solve(self, *args)


    def default_parameters():
        """

        Default parameter values

        """
        return _fem.NonlinearVariationalSolver_default_parameters()

    default_parameters = staticmethod(default_parameters)
    __swig_destroy__ = _fem.delete_NonlinearVariationalSolver
NonlinearVariationalSolver.solve = new_instancemethod(_fem.NonlinearVariationalSolver_solve, None, NonlinearVariationalSolver)
NonlinearVariationalSolver_swigregister = _fem.NonlinearVariationalSolver_swigregister
NonlinearVariationalSolver_swigregister(NonlinearVariationalSolver)

def NonlinearVariationalSolver_default_parameters():
    """

    Default parameter values

    """
    return _fem.NonlinearVariationalSolver_default_parameters()

class MultiMeshAssembler(AssemblerBase):
    """

    This class implements functionality for finite element assembly
    over cut and composite finite element (MultiMesh) function spaces.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """

        Constructor

        """
        _fem.MultiMeshAssembler_swiginit(self, _fem.new_MultiMeshAssembler())

    def assemble(self, A, a):
        """

        Assemble tensor from given form

        *Arguments*
            A (:py:class:`GenericTensor`)
                The tensor to assemble.
            a (:py:class:`Form`)
                The form to assemble the tensor from.

        """
        return _fem.MultiMeshAssembler_assemble(self, A, a)

    extend_cut_cell_integration = _swig_property(_fem.MultiMeshAssembler_extend_cut_cell_integration_get, _fem.MultiMeshAssembler_extend_cut_cell_integration_set)
    __swig_destroy__ = _fem.delete_MultiMeshAssembler
MultiMeshAssembler.assemble = new_instancemethod(_fem.MultiMeshAssembler_assemble, None, MultiMeshAssembler)
MultiMeshAssembler_swigregister = _fem.MultiMeshAssembler_swigregister
MultiMeshAssembler_swigregister(MultiMeshAssembler)

class MultiMeshDirichletBC(object):
    """

    This class is used to set Dirichlet boundary conditions for
    multimesh function spaces.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * MultiMeshDirichletBC\ (V, g, sub_domain, method="topological", check_midpoint=true)

          Create boundary condition for subdomain

          *Arguments*
              V (:py:class:`MultiMeshFunctionSpace`)
                  The function space.
              g (:py:class:`GenericFunction`)
                  The value.
              sub_domain (:py:class:`SubDomain`)
                  The subdomain.
              method (str)
                  Optional argument: A string specifying
                  the method to identify dofs.

        * MultiMeshDirichletBC\ (V, g, sub_domain, method="topological", check_midpoint=true)

          Create boundary condition for subdomain

          *Arguments*
              V (:py:class:`MultiMeshFunctionSpace`)
                  The function space
              g (:py:class:`GenericFunction`)
                  The value
              sub_domain (:py:class:`SubDomain`)
                  The subdomain
              method (str)
                  Optional argument: A string specifying
                  the method to identify dofs

        """
        _fem.MultiMeshDirichletBC_swiginit(self, _fem.new_MultiMeshDirichletBC(*args))
    __swig_destroy__ = _fem.delete_MultiMeshDirichletBC

    def apply(self, *args):
        """

        **Overloaded versions**

        * apply\ (A)

          Apply boundary condition to a matrix

          *Arguments*
              A (:py:class:`GenericMatrix`)
                  The matrix to apply boundary condition to.

        * apply\ (b)

          Apply boundary condition to a vector

          *Arguments*
              b (:py:class:`GenericVector`)
                  The vector to apply boundary condition to.

        * apply\ (A, b)

          Apply boundary condition to a linear system

          *Arguments*
              A (:py:class:`GenericMatrix`)
                  The matrix to apply boundary condition to.
              b (:py:class:`GenericVector`)
                  The vector to apply boundary condition to.

        * apply\ (b, x)

          Apply boundary condition to vectors for a nonlinear problem

          *Arguments*
              b (:py:class:`GenericVector`)
                  The vector to apply boundary conditions to.
              x (:py:class:`GenericVector`)
                  Another vector (nonlinear problem).

        * apply\ (A, b, x)

          Apply boundary condition to a linear system for a nonlinear problem

          *Arguments*
              A (:py:class:`GenericMatrix`)
                  The matrix to apply boundary conditions to.
              b (:py:class:`GenericVector`)
                  The vector to apply boundary conditions to.
              x (:py:class:`GenericVector`)
                  Another vector (nonlinear problem).

        """
        return _fem.MultiMeshDirichletBC_apply(self, *args)

MultiMeshDirichletBC.apply = new_instancemethod(_fem.MultiMeshDirichletBC_apply, None, MultiMeshDirichletBC)
MultiMeshDirichletBC_swigregister = _fem.MultiMeshDirichletBC_swigregister
MultiMeshDirichletBC_swigregister(MultiMeshDirichletBC)

class MultiMeshDofMap(object):
    """

    This class handles the mapping of degrees of freedom for MultiMesh
    function spaces.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        Constructor

        """
        _fem.MultiMeshDofMap_swiginit(self, _fem.new_MultiMeshDofMap(*args))
    __swig_destroy__ = _fem.delete_MultiMeshDofMap

    def num_parts(self):
        """

        Return the number dofmaps (parts) of the MultiMesh dofmap

        *Returns*
            int
                The number of dofmaps (parts) of the MultiMesh dofmap

        """
        return _fem.MultiMeshDofMap_num_parts(self)


    def part(self, i):
        """

        Return dofmap (part) number i

        *Returns*
            :py:class:`GenericDofMap`
                Dofmap (part) number i

        """
        return _fem.MultiMeshDofMap_part(self, i)


    def add(self, *args):
        """

        **Overloaded versions**

        * add\ (dofmap)

          Add dofmap (shared pointer version)

          *Arguments*
              dofmap (:py:class:`GenericDofMap`)
                  The dofmap.

        * add\ (dofmap)

          Add dofmap (reference version)

          *Arguments*
              dofmap (:py:class:`DofMap`)
                  The dofmap.

        """
        return _fem.MultiMeshDofMap_add(self, *args)


    def build(self, function_space, offsets):
        """

        Build MultiMesh dofmap

        """
        return _fem.MultiMeshDofMap_build(self, function_space, offsets)


    def clear(self):
        """

        Clear MultiMesh dofmap

        """
        return _fem.MultiMeshDofMap_clear(self)


    def global_dimension(self):
        """

        Return the dimension of the global finite element function
        space

        """
        return _fem.MultiMeshDofMap_global_dimension(self)


    def ownership_range(self):
        """

        Return the ownership range (dofs in this range are owned by
        this process)

        """
        return _fem.MultiMeshDofMap_ownership_range(self)


    def off_process_owner(self):
        """

        Return map from nonlocal-dofs (that appear in local dof map)
        to owning process

        """
        return _fem.MultiMeshDofMap_off_process_owner(self)


    def str(self, verbose):
        """

        Return informal string representation (pretty-print)

        """
        return _fem.MultiMeshDofMap_str(self, verbose)

MultiMeshDofMap.num_parts = new_instancemethod(_fem.MultiMeshDofMap_num_parts, None, MultiMeshDofMap)
MultiMeshDofMap.part = new_instancemethod(_fem.MultiMeshDofMap_part, None, MultiMeshDofMap)
MultiMeshDofMap.add = new_instancemethod(_fem.MultiMeshDofMap_add, None, MultiMeshDofMap)
MultiMeshDofMap.build = new_instancemethod(_fem.MultiMeshDofMap_build, None, MultiMeshDofMap)
MultiMeshDofMap.clear = new_instancemethod(_fem.MultiMeshDofMap_clear, None, MultiMeshDofMap)
MultiMeshDofMap.global_dimension = new_instancemethod(_fem.MultiMeshDofMap_global_dimension, None, MultiMeshDofMap)
MultiMeshDofMap.ownership_range = new_instancemethod(_fem.MultiMeshDofMap_ownership_range, None, MultiMeshDofMap)
MultiMeshDofMap.off_process_owner = new_instancemethod(_fem.MultiMeshDofMap_off_process_owner, None, MultiMeshDofMap)
MultiMeshDofMap.str = new_instancemethod(_fem.MultiMeshDofMap_str, None, MultiMeshDofMap)
MultiMeshDofMap_swigregister = _fem.MultiMeshDofMap_swigregister
MultiMeshDofMap_swigregister(MultiMeshDofMap)

class MultiMeshForm(object):
    """

    This class represents a variational form on a cut and composite
    finite element function space (MultiMesh) defined on one or more
    possibly intersecting meshes.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * MultiMeshForm\ (multimesh)

          Create empty multimesh functional (shared pointer version)

        * MultiMeshForm\ (multimesh)

          Create empty multimesh functional (reference version)

        * MultiMeshForm\ (function_space)

          Create empty linear multimesh variational form (shared pointer version)

        * MultiMeshForm\ (function_space)

          Create empty linear multimesh variational form (reference version)

        * MultiMeshForm\ (function_space_0, function_space_1)

          Create empty bilinear multimesh variational form (shared pointer version)

        * MultiMeshForm\ (function_space_0, function_space_1)

          Create empty bilinear multimesh variational form (reference version)

        """
        _fem.MultiMeshForm_swiginit(self, _fem.new_MultiMeshForm(*args))
    __swig_destroy__ = _fem.delete_MultiMeshForm

    def rank(self):
        """

        Return rank of form (bilinear form = 2, linear form = 1,
        functional = 0, etc)

        *Returns*
            int
                The rank of the form.

        """
        return _fem.MultiMeshForm_rank(self)


    def num_parts(self):
        """

        Return the number of forms (parts) of the MultiMesh form

        *Returns*
            int
                The number of forms (parts) of the MultiMesh form.

        """
        return _fem.MultiMeshForm_num_parts(self)


    def multimesh(self):
        """

        Extract common multimesh from form

        *Returns*
            :py:class:`MultiMesh`
                The mesh.

        """
        return _fem.MultiMeshForm_multimesh(self)


    def part(self, i):
        """

        Return form (part) number i

        *Returns*
            :py:class:`Form`
                Form (part) number i.

        """
        return _fem.MultiMeshForm_part(self, i)


    def function_space(self, i):
        """

        Return function space for given argument

        *Arguments*
            i (int)
                Index

        *Returns*
            :py:class:`MultiMeshFunctionSpace`
                Function space shared pointer.

        """
        return _fem.MultiMeshForm_function_space(self, i)


    def add(self, *args):
        """

        **Overloaded versions**

        * add\ (form)

          Add form (shared pointer version)

          *Arguments*
              form (:py:class:`Form`)
                  The form.

        * add\ (form)

          Add form (reference version)

          *Arguments*
              form (:py:class:`Form`)
                  The form.

        """
        return _fem.MultiMeshForm_add(self, *args)


    def build(self):
        """

        Build MultiMesh form

        """
        return _fem.MultiMeshForm_build(self)


    def clear(self):
        """

        Clear MultiMesh form

        """
        return _fem.MultiMeshForm_clear(self)

MultiMeshForm.rank = new_instancemethod(_fem.MultiMeshForm_rank, None, MultiMeshForm)
MultiMeshForm.num_parts = new_instancemethod(_fem.MultiMeshForm_num_parts, None, MultiMeshForm)
MultiMeshForm.multimesh = new_instancemethod(_fem.MultiMeshForm_multimesh, None, MultiMeshForm)
MultiMeshForm.part = new_instancemethod(_fem.MultiMeshForm_part, None, MultiMeshForm)
MultiMeshForm.function_space = new_instancemethod(_fem.MultiMeshForm_function_space, None, MultiMeshForm)
MultiMeshForm.add = new_instancemethod(_fem.MultiMeshForm_add, None, MultiMeshForm)
MultiMeshForm.build = new_instancemethod(_fem.MultiMeshForm_build, None, MultiMeshForm)
MultiMeshForm.clear = new_instancemethod(_fem.MultiMeshForm_clear, None, MultiMeshForm)
MultiMeshForm_swigregister = _fem.MultiMeshForm_swigregister
MultiMeshForm_swigregister(MultiMeshForm)

class OpenMpAssembler(AssemblerBase):
    """

    This class provides automated assembly of linear systems, or
    more generally, assembly of a sparse tensor from a given
    variational form.

    The MeshFunction arguments can be used to specify assembly over
    subdomains of the mesh cells, exterior facets or interior
    facets. Either a null pointer or an empty MeshFunction may be
    used to specify that the tensor should be assembled over the
    entire set of cells or facets.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """

        Constructor

        """
        _fem.OpenMpAssembler_swiginit(self, _fem.new_OpenMpAssembler())

    def assemble(self, A, a):
        """

        Assemble tensor from given form

        """
        return _fem.OpenMpAssembler_assemble(self, A, a)

    __swig_destroy__ = _fem.delete_OpenMpAssembler
OpenMpAssembler.assemble = new_instancemethod(_fem.OpenMpAssembler_assemble, None, OpenMpAssembler)
OpenMpAssembler_swigregister = _fem.OpenMpAssembler_swigregister
OpenMpAssembler_swigregister(OpenMpAssembler)


HierarchicalLinearVariationalProblem.leaf_node = HierarchicalLinearVariationalProblem._leaf_node
HierarchicalLinearVariationalProblem.root_node = HierarchicalLinearVariationalProblem._root_node
HierarchicalLinearVariationalProblem.child = HierarchicalLinearVariationalProblem._child
HierarchicalLinearVariationalProblem.parent = HierarchicalLinearVariationalProblem._parent


HierarchicalNonlinearVariationalProblem.leaf_node = HierarchicalNonlinearVariationalProblem._leaf_node
HierarchicalNonlinearVariationalProblem.root_node = HierarchicalNonlinearVariationalProblem._root_node
HierarchicalNonlinearVariationalProblem.child = HierarchicalNonlinearVariationalProblem._child
HierarchicalNonlinearVariationalProblem.parent = HierarchicalNonlinearVariationalProblem._parent


HierarchicalForm.leaf_node = HierarchicalForm._leaf_node
HierarchicalForm.root_node = HierarchicalForm._root_node
HierarchicalForm.child = HierarchicalForm._child
HierarchicalForm.parent = HierarchicalForm._parent


HierarchicalDirichletBC.leaf_node = HierarchicalDirichletBC._leaf_node
HierarchicalDirichletBC.root_node = HierarchicalDirichletBC._root_node
HierarchicalDirichletBC.child = HierarchicalDirichletBC._child
HierarchicalDirichletBC.parent = HierarchicalDirichletBC._parent

class MultiStageScheme(common.Variable):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * MultiStageScheme\ (stage_forms, last_stage, stage_solutions, u, t, dt, dt_stage_offset, jacobian_indices, order, name, human_form)

          Constructor
          FIXME: This constructor is a MESS. Needs clean up...

        * MultiStageScheme\ (stage_forms, last_stage, stage_solutions, u, t, dt, dt_stage_offset, jacobian_indices, order, name, human_form, bcs)

          Constructor with Boundary conditions

        """
        _fem.MultiStageScheme_swiginit(self, _fem.new_MultiStageScheme(*args))

    def dt_stage_offset(self):
        """

        Return local timestep

        """
        return _fem.MultiStageScheme_dt_stage_offset(self)


    def order(self):
        """

        Return the order of the scheme

        """
        return _fem.MultiStageScheme_order(self)


    def bcs(self):
        """

        Return boundary conditions

        """
        return _fem.MultiStageScheme_bcs(self)


    def implicit(self, *args):
        """

        **Overloaded versions**

        * implicit\ (stage)

          Return true if stage is implicit

        * implicit\ ()

          Return true if the whole scheme is implicit

        """
        return _fem.MultiStageScheme_implicit(self, *args)

    __swig_destroy__ = _fem.delete_MultiStageScheme
MultiStageScheme.dt_stage_offset = new_instancemethod(_fem.MultiStageScheme_dt_stage_offset, None, MultiStageScheme)
MultiStageScheme.order = new_instancemethod(_fem.MultiStageScheme_order, None, MultiStageScheme)
MultiStageScheme.bcs = new_instancemethod(_fem.MultiStageScheme_bcs, None, MultiStageScheme)
MultiStageScheme.implicit = new_instancemethod(_fem.MultiStageScheme_implicit, None, MultiStageScheme)
MultiStageScheme.jacobian_index = new_instancemethod(_fem.MultiStageScheme_jacobian_index, None, MultiStageScheme)
MultiStageScheme_swigregister = _fem.MultiStageScheme_swigregister
MultiStageScheme_swigregister(MultiStageScheme)

class RKSolver(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, scheme):
        """

        Constructor
        FIXME: Include version where one can pass a Solver and/or Parameters

        """
        _fem.RKSolver_swiginit(self, _fem.new_RKSolver(scheme))

    def step(self, dt):
        """

        Step solver with time step dt

        """
        return _fem.RKSolver_step(self, dt)


    def step_interval(self, t0, t1, dt):
        """

        Step solver an interval using dt as time step

        """
        return _fem.RKSolver_step_interval(self, t0, t1, dt)

    __swig_destroy__ = _fem.delete_RKSolver
RKSolver.step = new_instancemethod(_fem.RKSolver_step, None, RKSolver)
RKSolver.step_interval = new_instancemethod(_fem.RKSolver_step_interval, None, RKSolver)
RKSolver_swigregister = _fem.RKSolver_swigregister
RKSolver_swigregister(RKSolver)

class PointIntegralSolver(common.Variable):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, scheme):
        """

        Constructor
        FIXME: Include version where one can pass a Solver and/or
        Parameters

        """
        _fem.PointIntegralSolver_swiginit(self, _fem.new_PointIntegralSolver(scheme))
    __swig_destroy__ = _fem.delete_PointIntegralSolver

    def step(self, dt):
        """

        Step solver with time step dt

        """
        return _fem.PointIntegralSolver_step(self, dt)


    def step_interval(self, t0, t1, dt):
        """

        Step solver an interval using dt as time step

        """
        return _fem.PointIntegralSolver_step_interval(self, t0, t1, dt)


    def default_parameters():
        """

        Default parameter values

        """
        return _fem.PointIntegralSolver_default_parameters()

    default_parameters = staticmethod(default_parameters)
PointIntegralSolver.step = new_instancemethod(_fem.PointIntegralSolver_step, None, PointIntegralSolver)
PointIntegralSolver.step_interval = new_instancemethod(_fem.PointIntegralSolver_step_interval, None, PointIntegralSolver)
PointIntegralSolver.reset_newton_solver = new_instancemethod(_fem.PointIntegralSolver_reset_newton_solver, None, PointIntegralSolver)
PointIntegralSolver.reset_stage_solutions = new_instancemethod(_fem.PointIntegralSolver_reset_stage_solutions, None, PointIntegralSolver)
PointIntegralSolver.num_jacobian_computations = new_instancemethod(_fem.PointIntegralSolver_num_jacobian_computations, None, PointIntegralSolver)
PointIntegralSolver_swigregister = _fem.PointIntegralSolver_swigregister
PointIntegralSolver_swigregister(PointIntegralSolver)

def PointIntegralSolver_default_parameters():
    """

    Default parameter values

    """
    return _fem.PointIntegralSolver_default_parameters()

class HierarchicalErrorControl(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, arg2):
        _fem.HierarchicalErrorControl_swiginit(self, _fem.new_HierarchicalErrorControl(arg2))
    __swig_destroy__ = _fem.delete_HierarchicalErrorControl
HierarchicalErrorControl.depth = new_instancemethod(_fem.HierarchicalErrorControl_depth, None, HierarchicalErrorControl)
HierarchicalErrorControl.has_parent = new_instancemethod(_fem.HierarchicalErrorControl_has_parent, None, HierarchicalErrorControl)
HierarchicalErrorControl.has_child = new_instancemethod(_fem.HierarchicalErrorControl_has_child, None, HierarchicalErrorControl)
HierarchicalErrorControl._parent = new_instancemethod(_fem.HierarchicalErrorControl__parent, None, HierarchicalErrorControl)
HierarchicalErrorControl._child = new_instancemethod(_fem.HierarchicalErrorControl__child, None, HierarchicalErrorControl)
HierarchicalErrorControl._root_node = new_instancemethod(_fem.HierarchicalErrorControl__root_node, None, HierarchicalErrorControl)
HierarchicalErrorControl._leaf_node = new_instancemethod(_fem.HierarchicalErrorControl__leaf_node, None, HierarchicalErrorControl)
HierarchicalErrorControl.set_parent = new_instancemethod(_fem.HierarchicalErrorControl_set_parent, None, HierarchicalErrorControl)
HierarchicalErrorControl.clear_child = new_instancemethod(_fem.HierarchicalErrorControl_clear_child, None, HierarchicalErrorControl)
HierarchicalErrorControl.set_child = new_instancemethod(_fem.HierarchicalErrorControl_set_child, None, HierarchicalErrorControl)
HierarchicalErrorControl._debug = new_instancemethod(_fem.HierarchicalErrorControl__debug, None, HierarchicalErrorControl)
HierarchicalErrorControl_swigregister = _fem.HierarchicalErrorControl_swigregister
HierarchicalErrorControl_swigregister(HierarchicalErrorControl)

class GenericAdaptiveVariationalSolver(common.Variable):
    """

    An abstract class for goal-oriented adaptive solution of
    variational problems.


    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fem.delete_GenericAdaptiveVariationalSolver

    def solve(self, tol):
        """

        Solve such that the functional error is less than the given
        tolerance. Note that each call to solve is based on the
        leaf-node of the variational problem

        *Arguments*
            tol (float)
                The error tolerance

        """
        return _fem.GenericAdaptiveVariationalSolver_solve(self, tol)


    def solve_primal(self):
        """

        Solve the primal problem. Must be overloaded in subclass.

        *Returns*
            :py:class:`Function`
                The solution to the primal problem

        """
        return _fem.GenericAdaptiveVariationalSolver_solve_primal(self)


    def extract_bcs(self):
        """

        Extract the boundary conditions for the primal problem. Must
        be overloaded in subclass.

        *Returns*
            list of :py:class:`DirichletBC`
                The primal boundary conditions

        """
        return _fem.GenericAdaptiveVariationalSolver_extract_bcs(self)


    def evaluate_goal(self, M, u):
        """

        Evaluate the goal functional. Must be overloaded in subclass.

        *Arguments*
           M (:py:class:`Form`)
               The functional to be evaluated
           u (:py:class:`Function`)
               The function of which to evaluate the functional

        *Returns*
            float
                The value of M evaluated at u

        """
        return _fem.GenericAdaptiveVariationalSolver_evaluate_goal(self, M, u)


    def adapt_problem(self, mesh):
        """

        Adapt the problem to other mesh. Must be overloaded in subclass.

        *Arguments*
           mesh (:py:class:`Mesh`)
               The other mesh

        """
        return _fem.GenericAdaptiveVariationalSolver_adapt_problem(self, mesh)


    def adaptive_data(self):
        """

        Return stored adaptive data

        *Returns*
           list of :py:class:`Parameters`
               The data stored in the adaptive loop

        """
        return _fem.GenericAdaptiveVariationalSolver_adaptive_data(self)


    def default_parameters():
        """

        Default parameter values:

            "max_iterations"     (int)
            "max_dimension"      (int)
            "plot_mesh"          (bool)
            "save_data"          (bool)
            "data_label"         (std::string)
            "reference"          (double)
            "marking_strategy"   (std::string)
            "marking_fraction"   (double)

        """
        return _fem.GenericAdaptiveVariationalSolver_default_parameters()

    default_parameters = staticmethod(default_parameters)

    def summary(self):
        """

        Present summary of all adaptive data and parameters

        """
        return _fem.GenericAdaptiveVariationalSolver_summary(self)

GenericAdaptiveVariationalSolver.solve = new_instancemethod(_fem.GenericAdaptiveVariationalSolver_solve, None, GenericAdaptiveVariationalSolver)
GenericAdaptiveVariationalSolver.solve_primal = new_instancemethod(_fem.GenericAdaptiveVariationalSolver_solve_primal, None, GenericAdaptiveVariationalSolver)
GenericAdaptiveVariationalSolver.extract_bcs = new_instancemethod(_fem.GenericAdaptiveVariationalSolver_extract_bcs, None, GenericAdaptiveVariationalSolver)
GenericAdaptiveVariationalSolver.evaluate_goal = new_instancemethod(_fem.GenericAdaptiveVariationalSolver_evaluate_goal, None, GenericAdaptiveVariationalSolver)
GenericAdaptiveVariationalSolver.adapt_problem = new_instancemethod(_fem.GenericAdaptiveVariationalSolver_adapt_problem, None, GenericAdaptiveVariationalSolver)
GenericAdaptiveVariationalSolver.adaptive_data = new_instancemethod(_fem.GenericAdaptiveVariationalSolver_adaptive_data, None, GenericAdaptiveVariationalSolver)
GenericAdaptiveVariationalSolver.summary = new_instancemethod(_fem.GenericAdaptiveVariationalSolver_summary, None, GenericAdaptiveVariationalSolver)
GenericAdaptiveVariationalSolver_swigregister = _fem.GenericAdaptiveVariationalSolver_swigregister
GenericAdaptiveVariationalSolver_swigregister(GenericAdaptiveVariationalSolver)

def GenericAdaptiveVariationalSolver_default_parameters():
    """

    Default parameter values:

        "max_iterations"     (int)
        "max_dimension"      (int)
        "plot_mesh"          (bool)
        "save_data"          (bool)
        "data_label"         (std::string)
        "reference"          (double)
        "marking_strategy"   (std::string)
        "marking_fraction"   (double)

    """
    return _fem.GenericAdaptiveVariationalSolver_default_parameters()

class AdaptiveLinearVariationalSolver(GenericAdaptiveVariationalSolver):
    """

    A class for goal-oriented adaptive solution of linear
    variational problems.

    For a linear variational problem of the form: find u in V
    satisfying

        a(u, v) = L(v) for all v in :math:`\hat V`

    and a corresponding conforming discrete problem: find u_h in V_h
    satisfying

        a(u_h, v) = L(v) for all v in :math:`\hat V_h`

    and a given goal functional M and tolerance tol, the aim is to
    find a V_H and a u_H in V_H satisfying the discrete problem such
    that

        \|M(u) - M(u_H)\| < tol

    This strategy is based on dual-weighted residual error
    estimators designed and automatically generated for the primal
    problem and subsequent h-adaptivity.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * AdaptiveLinearVariationalSolver\ (problem, goal)

          Create AdaptiveLinearVariationalSolver

          *Arguments*
              problem (:py:class:`LinearVariationalProblem`)
                  The primal problem
              goal (:py:class:`GoalFunctional`)
                  The goal functional

        * AdaptiveLinearVariationalSolver\ (problem, goal)

          Create AdaptiveLinearVariationalSolver (shared ptr version)

          *Arguments*
              problem (:py:class:`LinearVariationalProblem`)
                  The primal problem
              goal (:py:class:`GoalFunctional`)
                  The goal functional

        * AdaptiveLinearVariationalSolver\ (problem, goal, control)

          Create AdaptiveLinearVariationalSolver from variational
          problem, goal form and error control instance

          *Arguments*
              problem (:py:class:`LinearVariationalProblem`)
                  The primal problem
              goal (:py:class:`Form`)
                  The goal functional
              control (:py:class:`ErrorControl`)
                  An error controller object

        """
        _fem.AdaptiveLinearVariationalSolver_swiginit(self, _fem.new_AdaptiveLinearVariationalSolver(*args))
    __swig_destroy__ = _fem.delete_AdaptiveLinearVariationalSolver
AdaptiveLinearVariationalSolver_swigregister = _fem.AdaptiveLinearVariationalSolver_swigregister
AdaptiveLinearVariationalSolver_swigregister(AdaptiveLinearVariationalSolver)

class AdaptiveNonlinearVariationalSolver(GenericAdaptiveVariationalSolver):
    """

    A class for goal-oriented adaptive solution of nonlinear
    variational problems.

    For a nonlinear variational problem of the form: find u in V
    satisfying

        F(u; v) = 0 for all v in :math:`\hat V`

    and a corresponding conforming discrete problem: find u_h in V_h
    satisfying (at least approximately)

        F(u_h; v) = 0 for all v in :math:`\hat V_h`

    and a given goal functional M and tolerance tol, the aim is to
    find a V_H and a u_H in V_H satisfying the discrete problem such
    that

        \|M(u) - M(u_H)\| < tol

    This strategy is based on dual-weighted residual error
    estimators designed and automatically generated for the primal
    problem and subsequent h-adaptivity.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * AdaptiveNonlinearVariationalSolver\ (problem, goal)

          Create AdaptiveNonlinearVariationalSolver

          *Arguments*
              problem (:py:class:`NonlinearVariationalProblem`)
                  The primal problem
              goal (:py:class:`GoalFunctional`)
                  The goal functional

        * AdaptiveNonlinearVariationalSolver\ (problem, goal)

          Create AdaptiveNonlinearVariationalSolver (shared ptr version)

          *Arguments*
              problem (:py:class:`NonlinearVariationalProblem`)
                  The primal problem
              goal (:py:class:`GoalFunctional`)
                  The goal functional

        * AdaptiveNonlinearVariationalSolver\ (problem, goal, control)

          Create AdaptiveLinearVariationalSolver from variational
          problem, goal form and error control instance

          *Arguments*
              problem (:py:class:`NonlinearVariationalProblem`)
                  The primal problem
              goal (:py:class:`Form`)
                  The goal functional
              control (:py:class:`ErrorControl`)
                  An error controller object

        """
        _fem.AdaptiveNonlinearVariationalSolver_swiginit(self, _fem.new_AdaptiveNonlinearVariationalSolver(*args))
    __swig_destroy__ = _fem.delete_AdaptiveNonlinearVariationalSolver
AdaptiveNonlinearVariationalSolver_swigregister = _fem.AdaptiveNonlinearVariationalSolver_swigregister
AdaptiveNonlinearVariationalSolver_swigregister(AdaptiveNonlinearVariationalSolver)

class ErrorControl(HierarchicalErrorControl, common.Variable):
    """

    (Goal-oriented) Error Control class.
    The notation used here follows the notation in "Automated
    goal-oriented error control I: stationary variational problems",
    ME Rognes and A Logg, 2010-2011.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, a_star, L_star, residual, a_R_T, L_R_T, a_R_dT, L_R_dT, eta_T, is_linear):
        """

        Create error control object

        *Arguments*
            a_star (:py:class:`Form`)
               the bilinear form for the dual problem
            L_star (:py:class:`Form`)
               the linear form for the dual problem
            residual (:py:class:`Form`)
               a functional for the residual (error estimate)
            a_R_T (:py:class:`Form`)
               the bilinear form for the strong cell residual problem
            L_R_T (:py:class:`Form`)
               the linear form for the strong cell residual problem
            a_R_dT (:py:class:`Form`)
               the bilinear form for the strong facet residual problem
            L_R_dT (:py:class:`Form`)
               the linear form for the strong facet residual problem
            eta_T (:py:class:`Form`)
               a linear form over DG_0 for error indicators
            is_linear (bool)
               true iff primal problem is linear

        """
        _fem.ErrorControl_swiginit(self, _fem.new_ErrorControl(a_star, L_star, residual, a_R_T, L_R_T, a_R_dT, L_R_dT, eta_T, is_linear))
    __swig_destroy__ = _fem.delete_ErrorControl

    def default_parameters():
        """

        Default parameter values:

        """
        return _fem.ErrorControl_default_parameters()

    default_parameters = staticmethod(default_parameters)

    def estimate_error(self, u, bcs):
        """

        Estimate the error relative to the goal M of the discrete
        approximation 'u' relative to the variational formulation by
        evaluating the weak residual at an approximation to the dual
        solution.

        *Arguments*
            u (:py:class:`Function`)
               the primal approximation

            bcs (list of :py:class:`DirichletBC`)
                the primal boundary conditions

        *Returns*
            float
                error estimate

        """
        return _fem.ErrorControl_estimate_error(self, u, bcs)


    def compute_indicators(self, indicators, u):
        """

        Compute error indicators

        *Arguments*
            indicators (:py:class:`MeshFunction`)
                the error indicators (to be computed)

            u (:py:class:`Function`)
                the primal approximation

        """
        return _fem.ErrorControl_compute_indicators(self, indicators, u)


    def residual_representation(self, R_T, R_dT, u):
        """

        Compute strong representation (strong cell and facet
        residuals) of the weak residual.

        *Arguments*
            R_T (:py:class:`Function`)
                the strong cell residual (to be computed)

            R_dT (:py:class:`SpecialFacetFunction`)
                the strong facet residual (to be computed)

            u (:py:class:`Function`)
                the primal approximation

        """
        return _fem.ErrorControl_residual_representation(self, R_T, R_dT, u)


    def compute_cell_residual(self, R_T, u):
        """

        Compute representation for the strong cell residual
        from the weak residual

        *Arguments*
            R_T (:py:class:`Function`)
                the strong cell residual (to be computed)

            u (:py:class:`Function`)
                the primal approximation

        """
        return _fem.ErrorControl_compute_cell_residual(self, R_T, u)


    def compute_facet_residual(self, R_dT, u, R_T):
        """

        Compute representation for the strong facet residual from the
        weak residual and the strong cell residual

        *Arguments*
            R_dT (:py:class:`SpecialFacetFunction`)
                the strong facet residual (to be computed)

            u (:py:class:`Function`)
                the primal approximation

            R_T (:py:class:`Function`)
                the strong cell residual

        """
        return _fem.ErrorControl_compute_facet_residual(self, R_dT, u, R_T)


    def compute_dual(self, z, bcs):
        """

        Compute dual approximation defined by dual variational
        problem and dual boundary conditions given by homogenized primal
        boundary conditions.

        *Arguments*
            z (:py:class:`Function`)
                the dual approximation (to be computed)

            bcs (list of :py:class:`DirichletBC`)
                the primal boundary conditions

        """
        return _fem.ErrorControl_compute_dual(self, z, bcs)


    def compute_extrapolation(self, z, bcs):
        """

        Compute extrapolation with boundary conditions

        *Arguments*
            z (:py:class:`Function`)
                the extrapolated function (to be computed)

            bcs (list of :py:class:`DirichletBC`)
                the dual boundary conditions

        """
        return _fem.ErrorControl_compute_extrapolation(self, z, bcs)

ErrorControl.estimate_error = new_instancemethod(_fem.ErrorControl_estimate_error, None, ErrorControl)
ErrorControl.compute_indicators = new_instancemethod(_fem.ErrorControl_compute_indicators, None, ErrorControl)
ErrorControl.residual_representation = new_instancemethod(_fem.ErrorControl_residual_representation, None, ErrorControl)
ErrorControl.compute_cell_residual = new_instancemethod(_fem.ErrorControl_compute_cell_residual, None, ErrorControl)
ErrorControl.compute_facet_residual = new_instancemethod(_fem.ErrorControl_compute_facet_residual, None, ErrorControl)
ErrorControl.compute_dual = new_instancemethod(_fem.ErrorControl_compute_dual, None, ErrorControl)
ErrorControl.compute_extrapolation = new_instancemethod(_fem.ErrorControl_compute_extrapolation, None, ErrorControl)
ErrorControl_swigregister = _fem.ErrorControl_swigregister
ErrorControl_swigregister(ErrorControl)

def ErrorControl_default_parameters():
    """

    Default parameter values:

    """
    return _fem.ErrorControl_default_parameters()

class Extrapolation(object):
    """

    This class implements an algorithm for extrapolating a function
    on a given function space from an approximation of that function
    on a possibly lower-order function space.

    This can be used to obtain a higher-order approximation of a
    computed dual solution, which is necessary when the computed
    dual approximation is in the test space of the primal problem,
    thereby being orthogonal to the residual.

    It is assumed that the extrapolation is computed on the same
    mesh as the original function.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def extrapolate(w, v):
        """

        Compute extrapolation w from v

        """
        return _fem.Extrapolation_extrapolate(w, v)

    extrapolate = staticmethod(extrapolate)

    def __init__(self):
        _fem.Extrapolation_swiginit(self, _fem.new_Extrapolation())
    __swig_destroy__ = _fem.delete_Extrapolation
Extrapolation_swigregister = _fem.Extrapolation_swigregister
Extrapolation_swigregister(Extrapolation)

def Extrapolation_extrapolate(w, v):
    """

    Compute extrapolation w from v

    """
    return _fem.Extrapolation_extrapolate(w, v)

class LocalAssembler(object):
    """



    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def assemble(A, ufc, vertex_coordinates, ufc_cell, cell, cell_domains, exterior_facet_domains, interior_facet_domains):
        """



        """
        return _fem.LocalAssembler_assemble(A, ufc, vertex_coordinates, ufc_cell, cell, cell_domains, exterior_facet_domains, interior_facet_domains)

    assemble = staticmethod(assemble)

    def assemble_cell(A, ufc, vertex_coordinates, ufc_cell, cell, domains):
        """



        """
        return _fem.LocalAssembler_assemble_cell(A, ufc, vertex_coordinates, ufc_cell, cell, domains)

    assemble_cell = staticmethod(assemble_cell)

    def assemble_exterior_facet(A, ufc, vertex_coordinates, ufc_cell, cell, facet, local_facet, domains):
        """



        """
        return _fem.LocalAssembler_assemble_exterior_facet(A, ufc, vertex_coordinates, ufc_cell, cell, facet, local_facet, domains)

    assemble_exterior_facet = staticmethod(assemble_exterior_facet)

    def assemble_interior_facet(A, ufc, vertex_coordinates, ufc_cell, cell, facet, local_facet, domains):
        """



        """
        return _fem.LocalAssembler_assemble_interior_facet(A, ufc, vertex_coordinates, ufc_cell, cell, facet, local_facet, domains)

    assemble_interior_facet = staticmethod(assemble_interior_facet)

    def __init__(self):
        _fem.LocalAssembler_swiginit(self, _fem.new_LocalAssembler())
    __swig_destroy__ = _fem.delete_LocalAssembler
LocalAssembler_swigregister = _fem.LocalAssembler_swigregister
LocalAssembler_swigregister(LocalAssembler)

def LocalAssembler_assemble(A, ufc, vertex_coordinates, ufc_cell, cell, cell_domains, exterior_facet_domains, interior_facet_domains):
    """



    """
    return _fem.LocalAssembler_assemble(A, ufc, vertex_coordinates, ufc_cell, cell, cell_domains, exterior_facet_domains, interior_facet_domains)

def LocalAssembler_assemble_cell(A, ufc, vertex_coordinates, ufc_cell, cell, domains):
    """



    """
    return _fem.LocalAssembler_assemble_cell(A, ufc, vertex_coordinates, ufc_cell, cell, domains)

def LocalAssembler_assemble_exterior_facet(A, ufc, vertex_coordinates, ufc_cell, cell, facet, local_facet, domains):
    """



    """
    return _fem.LocalAssembler_assemble_exterior_facet(A, ufc, vertex_coordinates, ufc_cell, cell, facet, local_facet, domains)

def LocalAssembler_assemble_interior_facet(A, ufc, vertex_coordinates, ufc_cell, cell, facet, local_facet, domains):
    """



    """
    return _fem.LocalAssembler_assemble_interior_facet(A, ufc, vertex_coordinates, ufc_cell, cell, facet, local_facet, domains)

class TimeSeries(common.Variable):
    """

    This class stores a time series of objects to file(s) in a
    binary format which is efficient for reading and writing.

    When objects are retrieved, the object stored at the time
    closest to the given time will be used.

    A new time series will check if values have been stored to
    file before (for a series with the same name) and in that
    case reuse those values. If new values are stored, old
    values will be cleared.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, mpi_comm, name):
        """

        Create empty time series

        *Arguments*
            mpi_comm (:py:class:`MPI`)
                An MPI communicator
            name (str)
                The time series name

        """
        _fem.TimeSeries_swiginit(self, _fem.new_TimeSeries(mpi_comm, name))
    __swig_destroy__ = _fem.delete_TimeSeries

    def store(self, *args):
        """

        **Overloaded versions**

        * store\ (vector, t)

          Store vector at given time

          *Arguments*
              vector (:py:class:`GenericVector`)
                  The vector to be stored.
              t (float)
                  The time.

        * store\ (mesh, t)

          Store mesh at given time

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to be stored.
              t (float)
                  The time.

        """
        return _fem.TimeSeries_store(self, *args)


    def retrieve(self, *args):
        """

        **Overloaded versions**

        * retrieve\ (vector, t, interpolate=true)

          Retrieve vector at given time

          *Arguments*
              vector (:py:class:`GenericVector`)
                  The vector (values to be retrieved).
              t (float)
                  The time.
              interpolate (bool)
                  Optional argument: If true (default), interpolate
                  time samples closest to t if t is not present.

        * retrieve\ (mesh, t)

          Retrieve mesh at given time

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh (values to be retrieved).
              t (float)
                  The time.

        """
        return _fem.TimeSeries_retrieve(self, *args)


    def vector_times(self):
        """

        Return array of sample times for vectors

        *Returns*
            numpy.array(float)
                The times.

        """
        return _fem.TimeSeries_vector_times(self)


    def mesh_times(self):
        """

        Return array of sample times for meshes

        *Returns*
            numpy.array(float)
                The times.

        """
        return _fem.TimeSeries_mesh_times(self)


    def clear(self):
        """

        Clear time series

        """
        return _fem.TimeSeries_clear(self)


    def default_parameters():
        """

        Default parameter values

        """
        return _fem.TimeSeries_default_parameters()

    default_parameters = staticmethod(default_parameters)
TimeSeries.store = new_instancemethod(_fem.TimeSeries_store, None, TimeSeries)
TimeSeries.retrieve = new_instancemethod(_fem.TimeSeries_retrieve, None, TimeSeries)
TimeSeries.vector_times = new_instancemethod(_fem.TimeSeries_vector_times, None, TimeSeries)
TimeSeries.mesh_times = new_instancemethod(_fem.TimeSeries_mesh_times, None, TimeSeries)
TimeSeries.clear = new_instancemethod(_fem.TimeSeries_clear, None, TimeSeries)
TimeSeries_swigregister = _fem.TimeSeries_swigregister
TimeSeries_swigregister(TimeSeries)

def TimeSeries_default_parameters():
    """

    Default parameter values

    """
    return _fem.TimeSeries_default_parameters()


def adapt_markers(refined_markers, adapted_mesh, markers, mesh):
    """

    Helper function for refinement of boundary conditions

    """
    return _fem.adapt_markers(refined_markers, adapted_mesh, markers, mesh)

def adapt(*args):
    """

    **Overloaded versions**

    * adapt\ (mesh)

      Refine mesh uniformly

    * adapt\ (mesh, cell_markers)

      Refine mesh based on cell markers

    * adapt\ (space)

      Refine function space uniformly

    * adapt\ (space, cell_markers)

      Refine function space based on cell markers

    * adapt\ (space, adapted_mesh)

      Refine function space based on refined mesh

    * adapt\ (function, adapted_mesh, interpolate=true)

      Adapt Function based on adapted mesh

      *Arguments*
          function (:py:class:`Function`)
              The function that should be adapted
          adapted_mesh (:py:class:`Mesh`)
              The new mesh
          interpolate (bool)
              Optional argument, default is true. If false, the
              function's function space is adapted, but the values are
              not interpolated.

      *Returns*
          :py:class:`Function`
              The adapted function

    * adapt\ (function, adapted_mesh)

      Refine GenericFunction based on refined mesh

    * adapt\ (mesh_function, adapted_mesh)

      Refine mesh function<std::size_t> based on mesh

    * adapt\ (bc, adapted_mesh, S)

      Refine Dirichlet bc based on refined mesh

    * adapt\ (form, adapted_mesh, adapt_coefficients=true)

      Adapt form based on adapted mesh

      *Arguments*
          form (:py:class:`Form`)
              The form that should be adapted
          adapted_mesh (:py:class:`Mesh`)
              The new mesh
          adapt_coefficients (bool)
              Optional argument, default is true. If false, the form
              coefficients are not explicitly adapted, but pre-adapted
              coefficients will be transferred.

      *Returns*
          :py:class:`Form`
              The adapted form

    * adapt\ (problem, adapted_mesh)

      Refine linear variational problem based on mesh

    * adapt\ (problem, adapted_mesh)

      Refine nonlinear variational problem based on mesh

    * adapt\ (ec, adapted_mesh, adapt_coefficients=true)

      Adapt error control object based on adapted mesh

      *Arguments*
          ec (:py:class:`ErrorControl`)
              The error control object to be adapted
          adapted_mesh (:py:class:`Mesh`)
              The new mesh
          adapt_coefficients (bool)
              Optional argument, default is true. If false, any form
              coefficients are not explicitly adapted, but pre-adapted
              coefficients will be transferred.

      *Returns*
          :py:class:`ErrorControl`
              The adapted error control object

    """
    return _fem.adapt(*args)

def mark(markers, indicators, strategy, fraction):
    """

    Mark cells based on indicators and given marking strategy

    *Arguments*
        markers (:py:class:`MeshFunction`)
            the cell markers (to be computed)

        indicators (:py:class:`MeshFunction`)
            error indicators (one per cell)

        strategy (str)
            the marking strategy

        fraction (float)
            the marking fraction

    """
    return _fem.mark(markers, indicators, strategy, fraction)

def dorfler_mark(markers, indicators, fraction):
    """

    Mark cells using Dorfler marking

    *Arguments*
        markers (:py:class:`MeshFunction`)
            the cell markers (to be computed)

        indicators (:py:class:`MeshFunction`)
            error indicators (one per cell)

        fraction (float)
            the marking fraction

    """
    return _fem.dorfler_mark(markers, indicators, fraction)

def fem_solve(*args):
    """

    **Overloaded versions**

    * solve\ (equation, u, tol, M)

      Solve linear variational problem a(u, v) == L(v) without
      essential boundary conditions

    * solve\ (equation, u, bc, tol, M)

      Solve linear variational problem a(u, v) == L(v) with single
      boundary condition

    * solve\ (equation, u, bcs, tol, M)

      Solve linear variational problem a(u, v) == L(v) with list of
      boundary conditions

    * solve\ (equation, u, J, tol, M)

      Solve nonlinear variational problem F(u; v) = 0 without
      essential boundary conditions

    * solve\ (equation, u, bc, J, tol, M)

      Solve linear variational problem F(u; v) = 0 with single
      boundary condition

    * solve\ (equation, u, bcs, J, tol, M)

      Solve linear variational problem F(u; v) = 0 with list of
      boundary conditions

    """
    return _fem.fem_solve(*args)

HierarchicalErrorControl.leaf_node = HierarchicalErrorControl._leaf_node
HierarchicalErrorControl.root_node = HierarchicalErrorControl._root_node
HierarchicalErrorControl.child = HierarchicalErrorControl._child
HierarchicalErrorControl.parent = HierarchicalErrorControl._parent



