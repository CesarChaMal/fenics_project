# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _mesh.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_mesh', [dirname(__file__)])
        except ImportError:
            import _mesh
            return _mesh
        if fp is not None:
            try:
                _mod = imp.load_module('_mesh', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _mesh = swig_import_helper()
    del swig_import_helper
else:
    import _mesh
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0



def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except Exception:
    weakref_proxy = lambda x: x



_mesh.SHARED_PTR_DISOWN_swigconstant(_mesh)
SHARED_PTR_DISOWN = _mesh.SHARED_PTR_DISOWN
import ufc

def _attach_base_to_numpy_array(obj, owner):
    return _mesh._attach_base_to_numpy_array(obj, owner)
_attach_base_to_numpy_array = _mesh._attach_base_to_numpy_array

def dolfin_swigversion():
    return _mesh.dolfin_swigversion()
dolfin_swigversion = _mesh.dolfin_swigversion

def dolfin_pythonversion():
    return _mesh.dolfin_pythonversion()
dolfin_pythonversion = _mesh.dolfin_pythonversion

tmp = hex(dolfin_swigversion())
__swigversion__ = "%d.%d.%d"%(tuple(map(int, [tmp[-5], tmp[-3], tmp[-2:]])))
tmp = hex(dolfin_pythonversion())
__pythonversion__ = "%d.%d.%d"%(tuple(map(lambda x: int(x,16), [tmp[2], tmp[3:5], tmp[5:7]])))
del tmp, dolfin_pythonversion, dolfin_swigversion


def has_petsc4py():
    return _mesh.has_petsc4py()
has_petsc4py = _mesh.has_petsc4py

def has_slepc4py():
    return _mesh.has_slepc4py()
has_slepc4py = _mesh.has_slepc4py
import common
class HierarchicalFunctionSpace(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, arg2):
        _mesh.HierarchicalFunctionSpace_swiginit(self, _mesh.new_HierarchicalFunctionSpace(arg2))
    __swig_destroy__ = _mesh.delete_HierarchicalFunctionSpace
HierarchicalFunctionSpace.depth = new_instancemethod(_mesh.HierarchicalFunctionSpace_depth, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace.has_parent = new_instancemethod(_mesh.HierarchicalFunctionSpace_has_parent, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace.has_child = new_instancemethod(_mesh.HierarchicalFunctionSpace_has_child, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace._parent = new_instancemethod(_mesh.HierarchicalFunctionSpace__parent, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace._child = new_instancemethod(_mesh.HierarchicalFunctionSpace__child, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace._root_node = new_instancemethod(_mesh.HierarchicalFunctionSpace__root_node, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace._leaf_node = new_instancemethod(_mesh.HierarchicalFunctionSpace__leaf_node, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace.set_parent = new_instancemethod(_mesh.HierarchicalFunctionSpace_set_parent, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace.clear_child = new_instancemethod(_mesh.HierarchicalFunctionSpace_clear_child, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace.set_child = new_instancemethod(_mesh.HierarchicalFunctionSpace_set_child, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace._debug = new_instancemethod(_mesh.HierarchicalFunctionSpace__debug, None, HierarchicalFunctionSpace)
HierarchicalFunctionSpace_swigregister = _mesh.HierarchicalFunctionSpace_swigregister
HierarchicalFunctionSpace_swigregister(HierarchicalFunctionSpace)

class HierarchicalFunction(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, arg2):
        _mesh.HierarchicalFunction_swiginit(self, _mesh.new_HierarchicalFunction(arg2))
    __swig_destroy__ = _mesh.delete_HierarchicalFunction
HierarchicalFunction.depth = new_instancemethod(_mesh.HierarchicalFunction_depth, None, HierarchicalFunction)
HierarchicalFunction.has_parent = new_instancemethod(_mesh.HierarchicalFunction_has_parent, None, HierarchicalFunction)
HierarchicalFunction.has_child = new_instancemethod(_mesh.HierarchicalFunction_has_child, None, HierarchicalFunction)
HierarchicalFunction._parent = new_instancemethod(_mesh.HierarchicalFunction__parent, None, HierarchicalFunction)
HierarchicalFunction._child = new_instancemethod(_mesh.HierarchicalFunction__child, None, HierarchicalFunction)
HierarchicalFunction._root_node = new_instancemethod(_mesh.HierarchicalFunction__root_node, None, HierarchicalFunction)
HierarchicalFunction._leaf_node = new_instancemethod(_mesh.HierarchicalFunction__leaf_node, None, HierarchicalFunction)
HierarchicalFunction.set_parent = new_instancemethod(_mesh.HierarchicalFunction_set_parent, None, HierarchicalFunction)
HierarchicalFunction.clear_child = new_instancemethod(_mesh.HierarchicalFunction_clear_child, None, HierarchicalFunction)
HierarchicalFunction.set_child = new_instancemethod(_mesh.HierarchicalFunction_set_child, None, HierarchicalFunction)
HierarchicalFunction._debug = new_instancemethod(_mesh.HierarchicalFunction__debug, None, HierarchicalFunction)
HierarchicalFunction_swigregister = _mesh.HierarchicalFunction_swigregister
HierarchicalFunction_swigregister(HierarchicalFunction)

class cells(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * MeshEntityIteratorBase\ (mesh)

          Create iterator for mesh entities over given topological dimension

        * MeshEntityIteratorBase\ (mesh, opt)

          Iterator over MeshEntity of dimension dim on mesh, with string option
          to iterate over "regular", "ghost" or "all" entities

        * MeshEntityIteratorBase\ (entity)

          Create iterator for entities of given dimension connected to given entity

        * MeshEntityIteratorBase\ (it)

          Copy constructor

        """
        _mesh.cells_swiginit(self, _mesh.new_cells(*args))
    __swig_destroy__ = _mesh.delete_cells

    def pos(self):
        """

        Return current position

        """
        return _mesh.cells_pos(self)


    def __eq__(self, it):
        """

        Comparison operator.

        """
        return _mesh.cells___eq__(self, it)


    def __ne__(self, it):
        """

        Comparison operator

        """
        return _mesh.cells___ne__(self, it)


    def end(self):
        """

        Check if iterator has reached the end

        """
        return _mesh.cells_end(self)


    def end_iterator(self):
        """

        Provide a safeguard iterator pointing beyond the end of an iteration
        process, either iterating over the mesh /or incident entities. Added to
        be bit more like STL iterators, since many algorithms rely on a kind of
        beyond iterator.

        """
        return _mesh.cells_end_iterator(self)


    def __iter__(self):
        self.first = True
        return self

    def __next__(self):
        self.first = self.first if hasattr(self,"first") else True
        if not self.first:
            self._increment()
        if self.end():
            self._decrease()
            raise StopIteration
        self.first = False
        return self._dereference()

    #Py2/Py3
    next = __next__


cells.pos = new_instancemethod(_mesh.cells_pos, None, cells)
cells.__eq__ = new_instancemethod(_mesh.cells___eq__, None, cells)
cells.__ne__ = new_instancemethod(_mesh.cells___ne__, None, cells)
cells.end = new_instancemethod(_mesh.cells_end, None, cells)
cells.end_iterator = new_instancemethod(_mesh.cells_end_iterator, None, cells)
cells._increment = new_instancemethod(_mesh.cells__increment, None, cells)
cells._decrease = new_instancemethod(_mesh.cells__decrease, None, cells)
cells._dereference = new_instancemethod(_mesh.cells__dereference, None, cells)
cells_swigregister = _mesh.cells_swigregister
cells_swigregister(cells)

class edges(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * MeshEntityIteratorBase\ (mesh)

          Create iterator for mesh entities over given topological dimension

        * MeshEntityIteratorBase\ (mesh, opt)

          Iterator over MeshEntity of dimension dim on mesh, with string option
          to iterate over "regular", "ghost" or "all" entities

        * MeshEntityIteratorBase\ (entity)

          Create iterator for entities of given dimension connected to given entity

        * MeshEntityIteratorBase\ (it)

          Copy constructor

        """
        _mesh.edges_swiginit(self, _mesh.new_edges(*args))
    __swig_destroy__ = _mesh.delete_edges

    def pos(self):
        """

        Return current position

        """
        return _mesh.edges_pos(self)


    def __eq__(self, it):
        """

        Comparison operator.

        """
        return _mesh.edges___eq__(self, it)


    def __ne__(self, it):
        """

        Comparison operator

        """
        return _mesh.edges___ne__(self, it)


    def end(self):
        """

        Check if iterator has reached the end

        """
        return _mesh.edges_end(self)


    def end_iterator(self):
        """

        Provide a safeguard iterator pointing beyond the end of an iteration
        process, either iterating over the mesh /or incident entities. Added to
        be bit more like STL iterators, since many algorithms rely on a kind of
        beyond iterator.

        """
        return _mesh.edges_end_iterator(self)


    def __iter__(self):
        self.first = True
        return self

    def __next__(self):
        self.first = self.first if hasattr(self,"first") else True
        if not self.first:
            self._increment()
        if self.end():
            self._decrease()
            raise StopIteration
        self.first = False
        return self._dereference()

    #Py2/Py3
    next = __next__


edges.pos = new_instancemethod(_mesh.edges_pos, None, edges)
edges.__eq__ = new_instancemethod(_mesh.edges___eq__, None, edges)
edges.__ne__ = new_instancemethod(_mesh.edges___ne__, None, edges)
edges.end = new_instancemethod(_mesh.edges_end, None, edges)
edges.end_iterator = new_instancemethod(_mesh.edges_end_iterator, None, edges)
edges._increment = new_instancemethod(_mesh.edges__increment, None, edges)
edges._decrease = new_instancemethod(_mesh.edges__decrease, None, edges)
edges._dereference = new_instancemethod(_mesh.edges__dereference, None, edges)
edges_swigregister = _mesh.edges_swigregister
edges_swigregister(edges)

class faces(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * MeshEntityIteratorBase\ (mesh)

          Create iterator for mesh entities over given topological dimension

        * MeshEntityIteratorBase\ (mesh, opt)

          Iterator over MeshEntity of dimension dim on mesh, with string option
          to iterate over "regular", "ghost" or "all" entities

        * MeshEntityIteratorBase\ (entity)

          Create iterator for entities of given dimension connected to given entity

        * MeshEntityIteratorBase\ (it)

          Copy constructor

        """
        _mesh.faces_swiginit(self, _mesh.new_faces(*args))
    __swig_destroy__ = _mesh.delete_faces

    def pos(self):
        """

        Return current position

        """
        return _mesh.faces_pos(self)


    def __eq__(self, it):
        """

        Comparison operator.

        """
        return _mesh.faces___eq__(self, it)


    def __ne__(self, it):
        """

        Comparison operator

        """
        return _mesh.faces___ne__(self, it)


    def end(self):
        """

        Check if iterator has reached the end

        """
        return _mesh.faces_end(self)


    def end_iterator(self):
        """

        Provide a safeguard iterator pointing beyond the end of an iteration
        process, either iterating over the mesh /or incident entities. Added to
        be bit more like STL iterators, since many algorithms rely on a kind of
        beyond iterator.

        """
        return _mesh.faces_end_iterator(self)


    def __iter__(self):
        self.first = True
        return self

    def __next__(self):
        self.first = self.first if hasattr(self,"first") else True
        if not self.first:
            self._increment()
        if self.end():
            self._decrease()
            raise StopIteration
        self.first = False
        return self._dereference()

    #Py2/Py3
    next = __next__


faces.pos = new_instancemethod(_mesh.faces_pos, None, faces)
faces.__eq__ = new_instancemethod(_mesh.faces___eq__, None, faces)
faces.__ne__ = new_instancemethod(_mesh.faces___ne__, None, faces)
faces.end = new_instancemethod(_mesh.faces_end, None, faces)
faces.end_iterator = new_instancemethod(_mesh.faces_end_iterator, None, faces)
faces._increment = new_instancemethod(_mesh.faces__increment, None, faces)
faces._decrease = new_instancemethod(_mesh.faces__decrease, None, faces)
faces._dereference = new_instancemethod(_mesh.faces__dereference, None, faces)
faces_swigregister = _mesh.faces_swigregister
faces_swigregister(faces)

class facets(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * MeshEntityIteratorBase\ (mesh)

          Create iterator for mesh entities over given topological dimension

        * MeshEntityIteratorBase\ (mesh, opt)

          Iterator over MeshEntity of dimension dim on mesh, with string option
          to iterate over "regular", "ghost" or "all" entities

        * MeshEntityIteratorBase\ (entity)

          Create iterator for entities of given dimension connected to given entity

        * MeshEntityIteratorBase\ (it)

          Copy constructor

        """
        _mesh.facets_swiginit(self, _mesh.new_facets(*args))
    __swig_destroy__ = _mesh.delete_facets

    def pos(self):
        """

        Return current position

        """
        return _mesh.facets_pos(self)


    def __eq__(self, it):
        """

        Comparison operator.

        """
        return _mesh.facets___eq__(self, it)


    def __ne__(self, it):
        """

        Comparison operator

        """
        return _mesh.facets___ne__(self, it)


    def end(self):
        """

        Check if iterator has reached the end

        """
        return _mesh.facets_end(self)


    def end_iterator(self):
        """

        Provide a safeguard iterator pointing beyond the end of an iteration
        process, either iterating over the mesh /or incident entities. Added to
        be bit more like STL iterators, since many algorithms rely on a kind of
        beyond iterator.

        """
        return _mesh.facets_end_iterator(self)


    def __iter__(self):
        self.first = True
        return self

    def __next__(self):
        self.first = self.first if hasattr(self,"first") else True
        if not self.first:
            self._increment()
        if self.end():
            self._decrease()
            raise StopIteration
        self.first = False
        return self._dereference()

    #Py2/Py3
    next = __next__


facets.pos = new_instancemethod(_mesh.facets_pos, None, facets)
facets.__eq__ = new_instancemethod(_mesh.facets___eq__, None, facets)
facets.__ne__ = new_instancemethod(_mesh.facets___ne__, None, facets)
facets.end = new_instancemethod(_mesh.facets_end, None, facets)
facets.end_iterator = new_instancemethod(_mesh.facets_end_iterator, None, facets)
facets._increment = new_instancemethod(_mesh.facets__increment, None, facets)
facets._decrease = new_instancemethod(_mesh.facets__decrease, None, facets)
facets._dereference = new_instancemethod(_mesh.facets__dereference, None, facets)
facets_swigregister = _mesh.facets_swigregister
facets_swigregister(facets)

class vertices(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * MeshEntityIteratorBase\ (mesh)

          Create iterator for mesh entities over given topological dimension

        * MeshEntityIteratorBase\ (mesh, opt)

          Iterator over MeshEntity of dimension dim on mesh, with string option
          to iterate over "regular", "ghost" or "all" entities

        * MeshEntityIteratorBase\ (entity)

          Create iterator for entities of given dimension connected to given entity

        * MeshEntityIteratorBase\ (it)

          Copy constructor

        """
        _mesh.vertices_swiginit(self, _mesh.new_vertices(*args))
    __swig_destroy__ = _mesh.delete_vertices

    def pos(self):
        """

        Return current position

        """
        return _mesh.vertices_pos(self)


    def __eq__(self, it):
        """

        Comparison operator.

        """
        return _mesh.vertices___eq__(self, it)


    def __ne__(self, it):
        """

        Comparison operator

        """
        return _mesh.vertices___ne__(self, it)


    def end(self):
        """

        Check if iterator has reached the end

        """
        return _mesh.vertices_end(self)


    def end_iterator(self):
        """

        Provide a safeguard iterator pointing beyond the end of an iteration
        process, either iterating over the mesh /or incident entities. Added to
        be bit more like STL iterators, since many algorithms rely on a kind of
        beyond iterator.

        """
        return _mesh.vertices_end_iterator(self)


    def __iter__(self):
        self.first = True
        return self

    def __next__(self):
        self.first = self.first if hasattr(self,"first") else True
        if not self.first:
            self._increment()
        if self.end():
            self._decrease()
            raise StopIteration
        self.first = False
        return self._dereference()

    #Py2/Py3
    next = __next__


vertices.pos = new_instancemethod(_mesh.vertices_pos, None, vertices)
vertices.__eq__ = new_instancemethod(_mesh.vertices___eq__, None, vertices)
vertices.__ne__ = new_instancemethod(_mesh.vertices___ne__, None, vertices)
vertices.end = new_instancemethod(_mesh.vertices_end, None, vertices)
vertices.end_iterator = new_instancemethod(_mesh.vertices_end_iterator, None, vertices)
vertices._increment = new_instancemethod(_mesh.vertices__increment, None, vertices)
vertices._decrease = new_instancemethod(_mesh.vertices__decrease, None, vertices)
vertices._dereference = new_instancemethod(_mesh.vertices__dereference, None, vertices)
vertices_swigregister = _mesh.vertices_swigregister
vertices_swigregister(vertices)

class HierarchicalMeshFunctionUInt(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, arg2):
        _mesh.HierarchicalMeshFunctionUInt_swiginit(self, _mesh.new_HierarchicalMeshFunctionUInt(arg2))
    __swig_destroy__ = _mesh.delete_HierarchicalMeshFunctionUInt
HierarchicalMeshFunctionUInt.depth = new_instancemethod(_mesh.HierarchicalMeshFunctionUInt_depth, None, HierarchicalMeshFunctionUInt)
HierarchicalMeshFunctionUInt.has_parent = new_instancemethod(_mesh.HierarchicalMeshFunctionUInt_has_parent, None, HierarchicalMeshFunctionUInt)
HierarchicalMeshFunctionUInt.has_child = new_instancemethod(_mesh.HierarchicalMeshFunctionUInt_has_child, None, HierarchicalMeshFunctionUInt)
HierarchicalMeshFunctionUInt._parent = new_instancemethod(_mesh.HierarchicalMeshFunctionUInt__parent, None, HierarchicalMeshFunctionUInt)
HierarchicalMeshFunctionUInt._child = new_instancemethod(_mesh.HierarchicalMeshFunctionUInt__child, None, HierarchicalMeshFunctionUInt)
HierarchicalMeshFunctionUInt._root_node = new_instancemethod(_mesh.HierarchicalMeshFunctionUInt__root_node, None, HierarchicalMeshFunctionUInt)
HierarchicalMeshFunctionUInt._leaf_node = new_instancemethod(_mesh.HierarchicalMeshFunctionUInt__leaf_node, None, HierarchicalMeshFunctionUInt)
HierarchicalMeshFunctionUInt.set_parent = new_instancemethod(_mesh.HierarchicalMeshFunctionUInt_set_parent, None, HierarchicalMeshFunctionUInt)
HierarchicalMeshFunctionUInt.clear_child = new_instancemethod(_mesh.HierarchicalMeshFunctionUInt_clear_child, None, HierarchicalMeshFunctionUInt)
HierarchicalMeshFunctionUInt.set_child = new_instancemethod(_mesh.HierarchicalMeshFunctionUInt_set_child, None, HierarchicalMeshFunctionUInt)
HierarchicalMeshFunctionUInt._debug = new_instancemethod(_mesh.HierarchicalMeshFunctionUInt__debug, None, HierarchicalMeshFunctionUInt)
HierarchicalMeshFunctionUInt_swigregister = _mesh.HierarchicalMeshFunctionUInt_swigregister
HierarchicalMeshFunctionUInt_swigregister(HierarchicalMeshFunctionUInt)

class HierarchicalMeshFunctionInt(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, arg2):
        _mesh.HierarchicalMeshFunctionInt_swiginit(self, _mesh.new_HierarchicalMeshFunctionInt(arg2))
    __swig_destroy__ = _mesh.delete_HierarchicalMeshFunctionInt
HierarchicalMeshFunctionInt.depth = new_instancemethod(_mesh.HierarchicalMeshFunctionInt_depth, None, HierarchicalMeshFunctionInt)
HierarchicalMeshFunctionInt.has_parent = new_instancemethod(_mesh.HierarchicalMeshFunctionInt_has_parent, None, HierarchicalMeshFunctionInt)
HierarchicalMeshFunctionInt.has_child = new_instancemethod(_mesh.HierarchicalMeshFunctionInt_has_child, None, HierarchicalMeshFunctionInt)
HierarchicalMeshFunctionInt._parent = new_instancemethod(_mesh.HierarchicalMeshFunctionInt__parent, None, HierarchicalMeshFunctionInt)
HierarchicalMeshFunctionInt._child = new_instancemethod(_mesh.HierarchicalMeshFunctionInt__child, None, HierarchicalMeshFunctionInt)
HierarchicalMeshFunctionInt._root_node = new_instancemethod(_mesh.HierarchicalMeshFunctionInt__root_node, None, HierarchicalMeshFunctionInt)
HierarchicalMeshFunctionInt._leaf_node = new_instancemethod(_mesh.HierarchicalMeshFunctionInt__leaf_node, None, HierarchicalMeshFunctionInt)
HierarchicalMeshFunctionInt.set_parent = new_instancemethod(_mesh.HierarchicalMeshFunctionInt_set_parent, None, HierarchicalMeshFunctionInt)
HierarchicalMeshFunctionInt.clear_child = new_instancemethod(_mesh.HierarchicalMeshFunctionInt_clear_child, None, HierarchicalMeshFunctionInt)
HierarchicalMeshFunctionInt.set_child = new_instancemethod(_mesh.HierarchicalMeshFunctionInt_set_child, None, HierarchicalMeshFunctionInt)
HierarchicalMeshFunctionInt._debug = new_instancemethod(_mesh.HierarchicalMeshFunctionInt__debug, None, HierarchicalMeshFunctionInt)
HierarchicalMeshFunctionInt_swigregister = _mesh.HierarchicalMeshFunctionInt_swigregister
HierarchicalMeshFunctionInt_swigregister(HierarchicalMeshFunctionInt)

class HierarchicalMeshFunctionDouble(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, arg2):
        _mesh.HierarchicalMeshFunctionDouble_swiginit(self, _mesh.new_HierarchicalMeshFunctionDouble(arg2))
    __swig_destroy__ = _mesh.delete_HierarchicalMeshFunctionDouble
HierarchicalMeshFunctionDouble.depth = new_instancemethod(_mesh.HierarchicalMeshFunctionDouble_depth, None, HierarchicalMeshFunctionDouble)
HierarchicalMeshFunctionDouble.has_parent = new_instancemethod(_mesh.HierarchicalMeshFunctionDouble_has_parent, None, HierarchicalMeshFunctionDouble)
HierarchicalMeshFunctionDouble.has_child = new_instancemethod(_mesh.HierarchicalMeshFunctionDouble_has_child, None, HierarchicalMeshFunctionDouble)
HierarchicalMeshFunctionDouble._parent = new_instancemethod(_mesh.HierarchicalMeshFunctionDouble__parent, None, HierarchicalMeshFunctionDouble)
HierarchicalMeshFunctionDouble._child = new_instancemethod(_mesh.HierarchicalMeshFunctionDouble__child, None, HierarchicalMeshFunctionDouble)
HierarchicalMeshFunctionDouble._root_node = new_instancemethod(_mesh.HierarchicalMeshFunctionDouble__root_node, None, HierarchicalMeshFunctionDouble)
HierarchicalMeshFunctionDouble._leaf_node = new_instancemethod(_mesh.HierarchicalMeshFunctionDouble__leaf_node, None, HierarchicalMeshFunctionDouble)
HierarchicalMeshFunctionDouble.set_parent = new_instancemethod(_mesh.HierarchicalMeshFunctionDouble_set_parent, None, HierarchicalMeshFunctionDouble)
HierarchicalMeshFunctionDouble.clear_child = new_instancemethod(_mesh.HierarchicalMeshFunctionDouble_clear_child, None, HierarchicalMeshFunctionDouble)
HierarchicalMeshFunctionDouble.set_child = new_instancemethod(_mesh.HierarchicalMeshFunctionDouble_set_child, None, HierarchicalMeshFunctionDouble)
HierarchicalMeshFunctionDouble._debug = new_instancemethod(_mesh.HierarchicalMeshFunctionDouble__debug, None, HierarchicalMeshFunctionDouble)
HierarchicalMeshFunctionDouble_swigregister = _mesh.HierarchicalMeshFunctionDouble_swigregister
HierarchicalMeshFunctionDouble_swigregister(HierarchicalMeshFunctionDouble)

class HierarchicalMeshFunctionBool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, arg2):
        _mesh.HierarchicalMeshFunctionBool_swiginit(self, _mesh.new_HierarchicalMeshFunctionBool(arg2))
    __swig_destroy__ = _mesh.delete_HierarchicalMeshFunctionBool
HierarchicalMeshFunctionBool.depth = new_instancemethod(_mesh.HierarchicalMeshFunctionBool_depth, None, HierarchicalMeshFunctionBool)
HierarchicalMeshFunctionBool.has_parent = new_instancemethod(_mesh.HierarchicalMeshFunctionBool_has_parent, None, HierarchicalMeshFunctionBool)
HierarchicalMeshFunctionBool.has_child = new_instancemethod(_mesh.HierarchicalMeshFunctionBool_has_child, None, HierarchicalMeshFunctionBool)
HierarchicalMeshFunctionBool._parent = new_instancemethod(_mesh.HierarchicalMeshFunctionBool__parent, None, HierarchicalMeshFunctionBool)
HierarchicalMeshFunctionBool._child = new_instancemethod(_mesh.HierarchicalMeshFunctionBool__child, None, HierarchicalMeshFunctionBool)
HierarchicalMeshFunctionBool._root_node = new_instancemethod(_mesh.HierarchicalMeshFunctionBool__root_node, None, HierarchicalMeshFunctionBool)
HierarchicalMeshFunctionBool._leaf_node = new_instancemethod(_mesh.HierarchicalMeshFunctionBool__leaf_node, None, HierarchicalMeshFunctionBool)
HierarchicalMeshFunctionBool.set_parent = new_instancemethod(_mesh.HierarchicalMeshFunctionBool_set_parent, None, HierarchicalMeshFunctionBool)
HierarchicalMeshFunctionBool.clear_child = new_instancemethod(_mesh.HierarchicalMeshFunctionBool_clear_child, None, HierarchicalMeshFunctionBool)
HierarchicalMeshFunctionBool.set_child = new_instancemethod(_mesh.HierarchicalMeshFunctionBool_set_child, None, HierarchicalMeshFunctionBool)
HierarchicalMeshFunctionBool._debug = new_instancemethod(_mesh.HierarchicalMeshFunctionBool__debug, None, HierarchicalMeshFunctionBool)
HierarchicalMeshFunctionBool_swigregister = _mesh.HierarchicalMeshFunctionBool_swigregister
HierarchicalMeshFunctionBool_swigregister(HierarchicalMeshFunctionBool)

class HierarchicalMeshFunctionSizet(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, arg2):
        _mesh.HierarchicalMeshFunctionSizet_swiginit(self, _mesh.new_HierarchicalMeshFunctionSizet(arg2))
    __swig_destroy__ = _mesh.delete_HierarchicalMeshFunctionSizet
HierarchicalMeshFunctionSizet.depth = new_instancemethod(_mesh.HierarchicalMeshFunctionSizet_depth, None, HierarchicalMeshFunctionSizet)
HierarchicalMeshFunctionSizet.has_parent = new_instancemethod(_mesh.HierarchicalMeshFunctionSizet_has_parent, None, HierarchicalMeshFunctionSizet)
HierarchicalMeshFunctionSizet.has_child = new_instancemethod(_mesh.HierarchicalMeshFunctionSizet_has_child, None, HierarchicalMeshFunctionSizet)
HierarchicalMeshFunctionSizet._parent = new_instancemethod(_mesh.HierarchicalMeshFunctionSizet__parent, None, HierarchicalMeshFunctionSizet)
HierarchicalMeshFunctionSizet._child = new_instancemethod(_mesh.HierarchicalMeshFunctionSizet__child, None, HierarchicalMeshFunctionSizet)
HierarchicalMeshFunctionSizet._root_node = new_instancemethod(_mesh.HierarchicalMeshFunctionSizet__root_node, None, HierarchicalMeshFunctionSizet)
HierarchicalMeshFunctionSizet._leaf_node = new_instancemethod(_mesh.HierarchicalMeshFunctionSizet__leaf_node, None, HierarchicalMeshFunctionSizet)
HierarchicalMeshFunctionSizet.set_parent = new_instancemethod(_mesh.HierarchicalMeshFunctionSizet_set_parent, None, HierarchicalMeshFunctionSizet)
HierarchicalMeshFunctionSizet.clear_child = new_instancemethod(_mesh.HierarchicalMeshFunctionSizet_clear_child, None, HierarchicalMeshFunctionSizet)
HierarchicalMeshFunctionSizet.set_child = new_instancemethod(_mesh.HierarchicalMeshFunctionSizet_set_child, None, HierarchicalMeshFunctionSizet)
HierarchicalMeshFunctionSizet._debug = new_instancemethod(_mesh.HierarchicalMeshFunctionSizet__debug, None, HierarchicalMeshFunctionSizet)
HierarchicalMeshFunctionSizet_swigregister = _mesh.HierarchicalMeshFunctionSizet_swigregister
HierarchicalMeshFunctionSizet_swigregister(HierarchicalMeshFunctionSizet)

class HierarchicalMesh(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, arg2):
        _mesh.HierarchicalMesh_swiginit(self, _mesh.new_HierarchicalMesh(arg2))
    __swig_destroy__ = _mesh.delete_HierarchicalMesh
HierarchicalMesh.depth = new_instancemethod(_mesh.HierarchicalMesh_depth, None, HierarchicalMesh)
HierarchicalMesh.has_parent = new_instancemethod(_mesh.HierarchicalMesh_has_parent, None, HierarchicalMesh)
HierarchicalMesh.has_child = new_instancemethod(_mesh.HierarchicalMesh_has_child, None, HierarchicalMesh)
HierarchicalMesh._parent = new_instancemethod(_mesh.HierarchicalMesh__parent, None, HierarchicalMesh)
HierarchicalMesh._child = new_instancemethod(_mesh.HierarchicalMesh__child, None, HierarchicalMesh)
HierarchicalMesh._root_node = new_instancemethod(_mesh.HierarchicalMesh__root_node, None, HierarchicalMesh)
HierarchicalMesh._leaf_node = new_instancemethod(_mesh.HierarchicalMesh__leaf_node, None, HierarchicalMesh)
HierarchicalMesh.set_parent = new_instancemethod(_mesh.HierarchicalMesh_set_parent, None, HierarchicalMesh)
HierarchicalMesh.clear_child = new_instancemethod(_mesh.HierarchicalMesh_clear_child, None, HierarchicalMesh)
HierarchicalMesh.set_child = new_instancemethod(_mesh.HierarchicalMesh_set_child, None, HierarchicalMesh)
HierarchicalMesh._debug = new_instancemethod(_mesh.HierarchicalMesh__debug, None, HierarchicalMesh)
HierarchicalMesh_swigregister = _mesh.HierarchicalMesh_swigregister
HierarchicalMesh_swigregister(HierarchicalMesh)

class CellType(object):
    """

    This class provides a common interface for different cell types.
    Each cell type implements mesh functionality that is specific to
    a certain type of cell.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    point = _mesh.CellType_point
    interval = _mesh.CellType_interval
    triangle = _mesh.CellType_triangle
    quadrilateral = _mesh.CellType_quadrilateral
    tetrahedron = _mesh.CellType_tetrahedron
    hexahedron = _mesh.CellType_hexahedron
    __swig_destroy__ = _mesh.delete_CellType

    def create(*args):
        """

        **Overloaded versions**

        * create\ (type)

          Create cell type from type (factory function)

        * create\ (type)

          Create cell type from string (factory function)

        """
        return _mesh.CellType_create(*args)

    create = staticmethod(create)

    def string2type(type):
        """

        Convert from string to cell type

        """
        return _mesh.CellType_string2type(type)

    string2type = staticmethod(string2type)

    def type2string(type):
        """

        Convert from cell type to string

        """
        return _mesh.CellType_type2string(type)

    type2string = staticmethod(type2string)

    def cell_type(self):
        """

        Return type of cell

        """
        return _mesh.CellType_cell_type(self)


    def facet_type(self):
        """

        Return type of cell for facets

        """
        return _mesh.CellType_facet_type(self)


    def entity_type(self, i):
        """

        Return type of cell for entity of dimension i

        """
        return _mesh.CellType_entity_type(self, i)


    def dim(self):
        """

        Return topological dimension of cell

        """
        return _mesh.CellType_dim(self)


    def num_entities(self, dim):
        """

        Return number of entities of given topological dimension

        """
        return _mesh.CellType_num_entities(self, dim)


    def num_vertices(self, *args):
        """

        **Overloaded versions**

        * num_vertices\ ()

          Return number of vertices for cell

        * num_vertices\ (dim)

          Return number of vertices for entity of given topological dimension

        """
        return _mesh.CellType_num_vertices(self, *args)


    def orientation(self, *args):
        """

        **Overloaded versions**

        * orientation\ (cell)

          Return orientation of the cell (assuming flat space)

        * orientation\ (cell, up)

          Return orientation of the cell relative to given up direction

        """
        return _mesh.CellType_orientation(self, *args)


    def create_entities(self, e, dim, v):
        """

        Create entities e of given topological dimension from vertices v

        """
        return _mesh.CellType_create_entities(self, e, dim, v)


    def refine_cell(self, cell, editor, current_cell):
        """

        Refine cell uniformly

        """
        return _mesh.CellType_refine_cell(self, cell, editor, current_cell)


    def volume(self, entity):
        """

        Compute (generalized) volume of mesh entity

        """
        return _mesh.CellType_volume(self, entity)


    def diameter(self, entity):
        """

        Compute diameter of mesh entity

        """
        return _mesh.CellType_diameter(self, entity)


    def inradius(self, cell):
        """

        Compute inradius of cell

        """
        return _mesh.CellType_inradius(self, cell)


    def radius_ratio(self, cell):
        """

        Compute dim*inradius/circumradius for given cell

        """
        return _mesh.CellType_radius_ratio(self, cell)


    def squared_distance(self, cell, point):
        """

        Compute squared distance to given point

        """
        return _mesh.CellType_squared_distance(self, cell, point)


    def normal(self, *args):
        """

        **Overloaded versions**

        * normal\ (cell, facet, i)

          Compute component i of normal of given facet with respect to the cell

        * normal\ (cell, facet)

          Compute of given facet with respect to the cell

        """
        return _mesh.CellType_normal(self, *args)


    def cell_normal(self, cell):
        """

        Compute normal to given cell (viewed as embedded in 3D)

        """
        return _mesh.CellType_cell_normal(self, cell)


    def facet_area(self, cell, facet):
        """

        Compute the area/length of given facet with respect to the cell

        """
        return _mesh.CellType_facet_area(self, cell, facet)


    def order(self, cell, local_to_global_vertex_indices):
        """

        Order entities locally

        """
        return _mesh.CellType_order(self, cell, local_to_global_vertex_indices)


    def ordered(self, cell, local_to_global_vertex_indices):
        """

        Check if entities are ordered

        """
        return _mesh.CellType_ordered(self, cell, local_to_global_vertex_indices)


    def collides(self, *args):
        """

        **Overloaded versions**

        * collides\ (cell, point)

          Check whether given point collides with cell

        * collides\ (cell, entity)

          Check whether given entity collides with cell

        """
        return _mesh.CellType_collides(self, *args)


    def triangulate_intersection(self, c0, c1):
        """

        Compute triangulation of intersection of two cells

        """
        return _mesh.CellType_triangulate_intersection(self, c0, c1)


    def description(self, plural):
        """

        Return description of cell type

        """
        return _mesh.CellType_description(self, plural)


    def vtk_mapping(self):
        """

        Mapping of DOLFIN/UFC vertex ordering to VTK/XDMF ordering

        """
        return _mesh.CellType_vtk_mapping(self)

CellType.cell_type = new_instancemethod(_mesh.CellType_cell_type, None, CellType)
CellType.facet_type = new_instancemethod(_mesh.CellType_facet_type, None, CellType)
CellType.entity_type = new_instancemethod(_mesh.CellType_entity_type, None, CellType)
CellType.dim = new_instancemethod(_mesh.CellType_dim, None, CellType)
CellType.num_entities = new_instancemethod(_mesh.CellType_num_entities, None, CellType)
CellType.num_vertices = new_instancemethod(_mesh.CellType_num_vertices, None, CellType)
CellType.orientation = new_instancemethod(_mesh.CellType_orientation, None, CellType)
CellType.create_entities = new_instancemethod(_mesh.CellType_create_entities, None, CellType)
CellType.refine_cell = new_instancemethod(_mesh.CellType_refine_cell, None, CellType)
CellType.volume = new_instancemethod(_mesh.CellType_volume, None, CellType)
CellType.diameter = new_instancemethod(_mesh.CellType_diameter, None, CellType)
CellType.inradius = new_instancemethod(_mesh.CellType_inradius, None, CellType)
CellType.radius_ratio = new_instancemethod(_mesh.CellType_radius_ratio, None, CellType)
CellType.squared_distance = new_instancemethod(_mesh.CellType_squared_distance, None, CellType)
CellType.normal = new_instancemethod(_mesh.CellType_normal, None, CellType)
CellType.cell_normal = new_instancemethod(_mesh.CellType_cell_normal, None, CellType)
CellType.facet_area = new_instancemethod(_mesh.CellType_facet_area, None, CellType)
CellType.order = new_instancemethod(_mesh.CellType_order, None, CellType)
CellType.ordered = new_instancemethod(_mesh.CellType_ordered, None, CellType)
CellType.collides = new_instancemethod(_mesh.CellType_collides, None, CellType)
CellType.triangulate_intersection = new_instancemethod(_mesh.CellType_triangulate_intersection, None, CellType)
CellType.description = new_instancemethod(_mesh.CellType_description, None, CellType)
CellType.vtk_mapping = new_instancemethod(_mesh.CellType_vtk_mapping, None, CellType)
CellType_swigregister = _mesh.CellType_swigregister
CellType_swigregister(CellType)

def CellType_create(*args):
    """

    **Overloaded versions**

    * create\ (type)

      Create cell type from type (factory function)

    * create\ (type)

      Create cell type from string (factory function)

    """
    return _mesh.CellType_create(*args)

def CellType_string2type(type):
    """

    Convert from string to cell type

    """
    return _mesh.CellType_string2type(type)

def CellType_type2string(type):
    """

    Convert from cell type to string

    """
    return _mesh.CellType_type2string(type)

class MeshTopology(object):
    """

    MeshTopology stores the topology of a mesh, consisting of mesh
    entities and connectivity (incidence relations for the mesh
    entities). Note that the mesh entities don't need to be stored,
    only the number of entities and the connectivity. Any numbering
    scheme for the mesh entities is stored separately in a
    MeshFunction over the entities.

    A mesh entity e may be identified globally as a pair e = (dim,
    i), where dim is the topological dimension and i is the index of
    the entity within that topological dimension.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * MeshTopology\ ()

          Create empty mesh topology

        * MeshTopology\ (topology)

          Copy constructor

        """
        _mesh.MeshTopology_swiginit(self, _mesh.new_MeshTopology(*args))
    __swig_destroy__ = _mesh.delete_MeshTopology

    def dim(self):
        """

        Return topological dimension

        """
        return _mesh.MeshTopology_dim(self)


    def size(self, dim):
        """

        Return number of entities for given dimension

        """
        return _mesh.MeshTopology_size(self, dim)


    def size_global(self, dim):
        """

        Return global number of entities for given dimension

        """
        return _mesh.MeshTopology_size_global(self, dim)


    def ghost_offset(self, dim):
        """

        Return number of regular (non-ghost) entities
        or equivalently, the offset of where ghost entities begin

        """
        return _mesh.MeshTopology_ghost_offset(self, dim)


    def clear(self, *args):
        """

        **Overloaded versions**

        * clear\ ()

          Clear all data

        * clear\ (d0, d1)

          Clear data for given pair of topological dimensions

        """
        return _mesh.MeshTopology_clear(self, *args)


    def init(self, *args):
        """

        **Overloaded versions**

        * init\ (dim)

          Initialize topology of given maximum dimension

        * init\ (dim, local_size, global_size)

          Set number of local entities (local_size) and global entities
          (global_size) for given topological dimension dim

        """
        return _mesh.MeshTopology_init(self, *args)


    def init_global_indices(self, dim, size):
        """

        Initialize storage for global entity numbering for entities of
        dimension dim

        """
        return _mesh.MeshTopology_init_global_indices(self, dim, size)


    def init_ghost(self, dim, index):
        """

        Initialise the offset index of ghost entities for this dimension

        """
        return _mesh.MeshTopology_init_ghost(self, dim, index)


    def set_global_index(self, dim, local_index, global_index):
        """

        Set global index for entity of dimension dim and with local
        index

        """
        return _mesh.MeshTopology_set_global_index(self, dim, local_index, global_index)


    def global_indices(self, d):
        """

        Get local-to-global index map for entities of topological
        dimension d

        """
        return _mesh.MeshTopology_global_indices(self, d)


    def have_global_indices(self, dim):
        """

        Check if global indices are available for entities of
        dimension dim

        """
        return _mesh.MeshTopology_have_global_indices(self, dim)


    def have_shared_entities(self, dim):
        """

        Check whether there are any shared entities calculated
        of dimension dim

        """
        return _mesh.MeshTopology_have_shared_entities(self, dim)


    def shared_entities(self, dim):
        """

        **Overloaded versions**

        * shared_entities\ (dim)

          Return map from shared entities (local index) to processes
          that share the entity

        * shared_entities\ (dim)

          Return map from shared entities (local index) to process that
          share the entity (const version)

        """
        return _mesh.MeshTopology_shared_entities(self, dim)


    def cell_owner(self, *args):
        """

        **Overloaded versions**

        * cell_owner\ ()

          Return mapping from local ghost cell index to owning process
          Since ghost cells are at the end of the range, this is just
          a vector over those cells

        * cell_owner\ ()

          Return mapping from local ghost cell index to owning process (const version)
          Since ghost cells are at the end of the range, this is just
          a vector over those cells

        """
        return _mesh.MeshTopology_cell_owner(self, *args)


    def hash(self):
        """

        Return hash based on the hash of cell-vertex connectivity

        """
        return _mesh.MeshTopology_hash(self)


    def str(self, verbose):
        """

        Return informal string representation (pretty-print)

        """
        return _mesh.MeshTopology_str(self, verbose)

    coloring = _swig_property(_mesh.MeshTopology_coloring_get, _mesh.MeshTopology_coloring_set)
MeshTopology.dim = new_instancemethod(_mesh.MeshTopology_dim, None, MeshTopology)
MeshTopology.size = new_instancemethod(_mesh.MeshTopology_size, None, MeshTopology)
MeshTopology.size_global = new_instancemethod(_mesh.MeshTopology_size_global, None, MeshTopology)
MeshTopology.ghost_offset = new_instancemethod(_mesh.MeshTopology_ghost_offset, None, MeshTopology)
MeshTopology.clear = new_instancemethod(_mesh.MeshTopology_clear, None, MeshTopology)
MeshTopology.init = new_instancemethod(_mesh.MeshTopology_init, None, MeshTopology)
MeshTopology.init_global_indices = new_instancemethod(_mesh.MeshTopology_init_global_indices, None, MeshTopology)
MeshTopology.init_ghost = new_instancemethod(_mesh.MeshTopology_init_ghost, None, MeshTopology)
MeshTopology.set_global_index = new_instancemethod(_mesh.MeshTopology_set_global_index, None, MeshTopology)
MeshTopology.global_indices = new_instancemethod(_mesh.MeshTopology_global_indices, None, MeshTopology)
MeshTopology.have_global_indices = new_instancemethod(_mesh.MeshTopology_have_global_indices, None, MeshTopology)
MeshTopology.have_shared_entities = new_instancemethod(_mesh.MeshTopology_have_shared_entities, None, MeshTopology)
MeshTopology.shared_entities = new_instancemethod(_mesh.MeshTopology_shared_entities, None, MeshTopology)
MeshTopology.cell_owner = new_instancemethod(_mesh.MeshTopology_cell_owner, None, MeshTopology)
MeshTopology.__call__ = new_instancemethod(_mesh.MeshTopology___call__, None, MeshTopology)
MeshTopology.hash = new_instancemethod(_mesh.MeshTopology_hash, None, MeshTopology)
MeshTopology.str = new_instancemethod(_mesh.MeshTopology_str, None, MeshTopology)
MeshTopology_swigregister = _mesh.MeshTopology_swigregister
MeshTopology_swigregister(MeshTopology)

class MeshGeometry(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * MeshGeometry\ ()

          Create empty set of coordinates

        * MeshGeometry\ (geometry)

          Copy constructor

        """
        _mesh.MeshGeometry_swiginit(self, _mesh.new_MeshGeometry(*args))
    __swig_destroy__ = _mesh.delete_MeshGeometry

    def dim(self):
        """

        Return Euclidean dimension of coordinate system

        """
        return _mesh.MeshGeometry_dim(self)


    def size(self):
        """

        Return number of coordinates

        """
        return _mesh.MeshGeometry_size(self)


    def x(self, *args):
        """

        **Overloaded versions**

        * x\ (n, i)

          Return value of coordinate with local index n in direction i

        * x\ (n, i)

          Return value of coordinate with local index n in direction i

        * x\ (n)

          Return array of values for coordinate with local index n

        * x\ (n)

          Return array of values for coordinate with local index n

        * x\ ()

          Return array of values for all coordinates

        * x\ ()

          Return array of values for all coordinates

        """
        return _mesh.MeshGeometry_x(self, *args)


    def point(self, n):
        """

        Return coordinate with local index n as a 3D point value

        """
        return _mesh.MeshGeometry_point(self, n)


    def clear(self):
        """

        Clear all data

        """
        return _mesh.MeshGeometry_clear(self)


    def init(self, dim, size):
        """

        Initialize coordinate list to given dimension and size

        """
        return _mesh.MeshGeometry_init(self, dim, size)


    def hash(self):
        """

        Hash of coordinate values

        *Returns*
            int
                A tree-hashed value of the coordinates over all MPI processes


        """
        return _mesh.MeshGeometry_hash(self)


    def str(self, verbose):
        """

        Return informal string representation (pretty-print)

        """
        return _mesh.MeshGeometry_str(self, verbose)

MeshGeometry.dim = new_instancemethod(_mesh.MeshGeometry_dim, None, MeshGeometry)
MeshGeometry.size = new_instancemethod(_mesh.MeshGeometry_size, None, MeshGeometry)
MeshGeometry.x = new_instancemethod(_mesh.MeshGeometry_x, None, MeshGeometry)
MeshGeometry.point = new_instancemethod(_mesh.MeshGeometry_point, None, MeshGeometry)
MeshGeometry.clear = new_instancemethod(_mesh.MeshGeometry_clear, None, MeshGeometry)
MeshGeometry.init = new_instancemethod(_mesh.MeshGeometry_init, None, MeshGeometry)
MeshGeometry.set = new_instancemethod(_mesh.MeshGeometry_set, None, MeshGeometry)
MeshGeometry.hash = new_instancemethod(_mesh.MeshGeometry_hash, None, MeshGeometry)
MeshGeometry.str = new_instancemethod(_mesh.MeshGeometry_str, None, MeshGeometry)
MeshGeometry_swigregister = _mesh.MeshGeometry_swigregister
MeshGeometry_swigregister(MeshGeometry)

class MeshDomains(object):
    """

    The class :py:class:`MeshDomains` stores the division of a :py:class:`Mesh` into
    subdomains. For each topological dimension 0 <= d <= D, where D
    is the topological dimension of the :py:class:`Mesh`, a set of integer
    markers are stored for a subset of the entities of dimension d,
    indicating for each entity in the subset the number of the
    subdomain. It should be noted that the subset does not need to
    contain all entities of any given dimension; entities not
    contained in the subset are "unmarked".

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """

        Create empty mesh domains

        """
        _mesh.MeshDomains_swiginit(self, _mesh.new_MeshDomains())
    __swig_destroy__ = _mesh.delete_MeshDomains

    def max_dim(self):
        """

        Return maximum topological dimension of stored markers

        """
        return _mesh.MeshDomains_max_dim(self)


    def num_marked(self, dim):
        """

        Return number of marked entities of given dimension

        """
        return _mesh.MeshDomains_num_marked(self, dim)


    def is_empty(self):
        """

        Check whether domain data is empty

        """
        return _mesh.MeshDomains_is_empty(self)


    def markers(self, dim):
        """

        **Overloaded versions**

        * markers\ (dim)

          Get subdomain markers for given dimension (shared pointer
          version)

        * markers\ (dim)

          Get subdomain markers for given dimension (const shared
          pointer version)

        """
        return _mesh.MeshDomains_markers(self, dim)


    def set_marker(self, marker, dim):
        """

        Set marker (entity index, marker value) of a given dimension
        d. Returns true if a new key is inserted, false otherwise.

        """
        return _mesh.MeshDomains_set_marker(self, marker, dim)


    def get_marker(self, entity_index, dim):
        """

        Get marker (entity index, marker value) of a given dimension
        d. Throws an error if marker does not exist.

        """
        return _mesh.MeshDomains_get_marker(self, entity_index, dim)


    def init(self, dim):
        """

        Initialize mesh domains for given topological dimension

        """
        return _mesh.MeshDomains_init(self, dim)


    def clear(self):
        """

        Clear all data

        """
        return _mesh.MeshDomains_clear(self)

MeshDomains.max_dim = new_instancemethod(_mesh.MeshDomains_max_dim, None, MeshDomains)
MeshDomains.num_marked = new_instancemethod(_mesh.MeshDomains_num_marked, None, MeshDomains)
MeshDomains.is_empty = new_instancemethod(_mesh.MeshDomains_is_empty, None, MeshDomains)
MeshDomains.markers = new_instancemethod(_mesh.MeshDomains_markers, None, MeshDomains)
MeshDomains.set_marker = new_instancemethod(_mesh.MeshDomains_set_marker, None, MeshDomains)
MeshDomains.get_marker = new_instancemethod(_mesh.MeshDomains_get_marker, None, MeshDomains)
MeshDomains.init = new_instancemethod(_mesh.MeshDomains_init, None, MeshDomains)
MeshDomains.clear = new_instancemethod(_mesh.MeshDomains_clear, None, MeshDomains)
MeshDomains_swigregister = _mesh.MeshDomains_swigregister
MeshDomains_swigregister(MeshDomains)

class MeshData(common.Variable):
    """

    The class MeshData is a container for auxiliary mesh data,
    represented either as arrays or maps. Each dataset is identified
    by a unique user-specified string. Only std::size_t-valued data
    are currently supported.

    Auxiliary mesh data may be attached to a mesh by users as a
    convenient way to store data associated with a mesh. It is also
    used internally by DOLFIN to communicate data associated with
    meshes. The following named mesh data are recognized by DOLFIN:

    Facet orientation (used for assembly over interior facets)

      * "facet_orientation"  - _std:vector_ <std::size_t> of dimension D - 1

    Sub meshes (used by the class SubMesh)

      * "parent_vertex_indices" - _std::vector_ <std::size_t> of dimension 0

    Note to developers: use underscore in names in place of spaces.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """

        Constructor

        """
        _mesh.MeshData_swiginit(self, _mesh.new_MeshData())
    __swig_destroy__ = _mesh.delete_MeshData

    def clear(self):
        """

        Clear all data

        """
        return _mesh.MeshData_clear(self)


    def exists(self, name, dim):
        """

        Check is array exists

        *Arguments*
            name (str)
                The name of the array.

        *Returns*
            bool
                True is array exists, false otherwise.

        """
        return _mesh.MeshData_exists(self, name, dim)


    def create_array(self, name, dim):
        """

        Create array (vector) with given name and size

        *Arguments*
            name (str)
                The name of the array.
            size (int)
                The size (length) of the array.

        *Returns*
            numpy.array(int)
                The array.

        """
        return _mesh.MeshData_create_array(self, name, dim)


    def array(self, *args):
        """

        **Overloaded versions**

        * array\ (name, dim)

          Return array with given name (returning zero if data is not
          available)

          *Arguments*
              name (str)
                  The name of the array.

          *Returns*
              numpy.array(int)
                  The array.

        * array\ (name, dim)

          Return array with given name (returning zero if data is not
          available)

          *Arguments*
              name (str)
                  The name of the array.

          *Returns*
              numpy.array(int)
                  The array.

        """
        return _mesh.MeshData_array(self, *args)


    def erase_array(self, name, dim):
        """

        Erase array with given name

        *Arguments*
            name (str)
                The name of the array.

        """
        return _mesh.MeshData_erase_array(self, name, dim)

MeshData.clear = new_instancemethod(_mesh.MeshData_clear, None, MeshData)
MeshData.exists = new_instancemethod(_mesh.MeshData_exists, None, MeshData)
MeshData.create_array = new_instancemethod(_mesh.MeshData_create_array, None, MeshData)
MeshData.array = new_instancemethod(_mesh.MeshData_array, None, MeshData)
MeshData.erase_array = new_instancemethod(_mesh.MeshData_erase_array, None, MeshData)
MeshData_swigregister = _mesh.MeshData_swigregister
MeshData_swigregister(MeshData)

class Mesh(common.Variable, HierarchicalMesh):
    """

    A :py:class:`Mesh` consists of a set of connected and numbered mesh entities.

    Both the representation and the interface are
    dimension-independent, but a concrete interface is also provided
    for standard named mesh entities:

    .. tabularcolumns:: |c|c|c|

    +--------+-----------+-------------+
    | Entity | Dimension | Codimension |
    +========+===========+=============+
    | Vertex |  0        |             |
    +--------+-----------+-------------+
    | Edge   |  1        |             |
    +--------+-----------+-------------+
    | Face   |  2        |             |
    +--------+-----------+-------------+
    | Facet  |           |      1      |
    +--------+-----------+-------------+
    | Cell   |           |      0      |
    +--------+-----------+-------------+

    When working with mesh iterators, all entities and connectivity
    are precomputed automatically the first time an iterator is
    created over any given topological dimension or connectivity.

    Note that for efficiency, only entities of dimension zero
    (vertices) and entities of the maximal dimension (cells) exist
    when creating a :py:class:`Mesh`. Other entities must be explicitly created
    by calling init(). For example, all edges in a mesh may be
    created by a call to mesh.init(1). Similarly, connectivities
    such as all edges connected to a given vertex must also be
    explicitly created (in this case by a call to mesh.init(0, 1)).

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * Mesh\ ()

          Create empty mesh

        * Mesh\ (comm)

          Create empty mesh

        * Mesh\ (mesh)

          Copy constructor.

          *Arguments*
              mesh (:py:class:`Mesh`)
                  Object to be copied.

        * Mesh\ (filename)

          Create mesh from data file.

          *Arguments*
              filename (str)
                  Name of file to load.

        * Mesh\ (comm, filename)

          Create mesh from data file.

          *Arguments*
              comm (:py:class:`MPI`)
                  The MPI communicator
              filename (str)
                  Name of file to load.

        * Mesh\ (comm, local_mesh_data)

          Create a distributed mesh from local (per process) data.

          *Arguments*
              comm (:py:class:`MPI`)
                  MPI communicator for the mesh.
              local_mesh_data (:py:class:`LocalMeshData`)
                  Data from which to build the mesh.

        """
        _mesh.Mesh_swiginit(self, _mesh.new_Mesh(*args))
    __swig_destroy__ = _mesh.delete_Mesh

    def num_vertices(self):
        """

        Get number of vertices in mesh.

        *Returns*
            int
                Number of vertices.

        *Example*
            .. note::

                No example code available for this function.

        """
        return _mesh.Mesh_num_vertices(self)


    def num_edges(self):
        """

        Get number of edges in mesh.

        *Returns*
            int
                Number of edges.

        *Example*
            .. note::

                No example code available for this function.

        """
        return _mesh.Mesh_num_edges(self)


    def num_faces(self):
        """

        Get number of faces in mesh.

        *Returns*
            int
                Number of faces.

        *Example*
            .. note::

                No example code available for this function.

        """
        return _mesh.Mesh_num_faces(self)


    def num_facets(self):
        """

        Get number of facets in mesh.

        *Returns*
            int
                Number of facets.

        *Example*
            .. note::

                No example code available for this function.

        """
        return _mesh.Mesh_num_facets(self)


    def num_cells(self):
        """

        Get number of cells in mesh.

        *Returns*
            int
                Number of cells.

        *Example*
            .. note::

                No example code available for this function.

        """
        return _mesh.Mesh_num_cells(self)


    def num_entities(self, d):
        """

        Get number of entities of given topological dimension.

        *Arguments*
            d (int)
                Topological dimension.

        *Returns*
            int
                Number of entities of topological dimension d.

        *Example*
            .. note::

                No example code available for this function.

        """
        return _mesh.Mesh_num_entities(self, d)


    def size(self, dim):
        """

        Get number of local entities of given topological dimension.

        *Arguments*
            dim (int)
                Topological dimension.

        *Returns*
            int
                Number of local entities of topological dimension d.

        *Example*
            .. note::

                No example code available for this function.

        """
        return _mesh.Mesh_size(self, dim)


    def size_global(self, dim):
        """

        Get global number of entities of given topological dimension.

        *Arguments*
            dim (int)
                Topological dimension.

        *Returns*
            int
                Global number of entities of topological dimension d.

        *Example*
            .. note::

                No example code available for this function.

        """
        return _mesh.Mesh_size_global(self, dim)


    def topology(self, *args):
        """

        **Overloaded versions**

        * topology\ ()

          Get mesh topology.

          *Returns*
              :py:class:`MeshTopology`
                  The topology object associated with the mesh.

        * topology\ ()

          Get mesh topology (const version).

        """
        return _mesh.Mesh_topology(self, *args)


    def geometry(self, *args):
        """

        **Overloaded versions**

        * geometry\ ()

          Get mesh geometry.

          *Returns*
              :py:class:`MeshGeometry`
                  The geometry object associated with the mesh.

        * geometry\ ()

          Get mesh geometry (const version).

        """
        return _mesh.Mesh_geometry(self, *args)


    def domains(self, *args):
        """

        **Overloaded versions**

        * domains\ ()

          Get mesh (sub)domains.

          *Returns*
              :py:class:`MeshDomains`
                  The (sub)domains associated with the mesh.

        * domains\ ()

          Get mesh (sub)domains.

        """
        return _mesh.Mesh_domains(self, *args)


    def bounding_box_tree(self):
        """

        Get bounding box tree for mesh. The bounding box tree is
        initialized and built upon the first call to this
        function. The bounding box tree can be used to compute
        collisions between the mesh and other objects. It is the
        responsibility of the caller to use (and possibly rebuild) the
        tree. It is stored as a (mutable) member of the mesh to enable
        sharing of the bounding box tree data structure.

        """
        return _mesh.Mesh_bounding_box_tree(self)


    def data(self, *args):
        """

        **Overloaded versions**

        * data\ ()

          Get mesh data.

          *Returns*
              :py:class:`MeshData`
                  The mesh data object associated with the mesh.

        * data\ ()

          Get mesh data (const version).

        """
        return _mesh.Mesh_data(self, *args)


    def type(self, *args):
        """

        **Overloaded versions**

        * type\ ()

          Get mesh cell type.

          *Returns*
              :py:class:`CellType`
                  The cell type object associated with the mesh.

        * type\ ()

          Get mesh cell type (const version).

        """
        return _mesh.Mesh_type(self, *args)


    def init(self, *args):
        """

        **Overloaded versions**

        * init\ (dim)

          Compute entities of given topological dimension.

          *Arguments*
              dim (int)
                  Topological dimension.

          *Returns*
              int
                  Number of created entities.

        * init\ (d0, d1)

          Compute connectivity between given pair of dimensions.

          *Arguments*
              d0 (int)
                  Topological dimension.

              d1 (int)
                  Topological dimension.

        * init\ ()

          Compute all entities and connectivity.

        """
        return _mesh.Mesh_init(self, *args)


    def clear(self):
        """

        Clear all mesh data.

        """
        return _mesh.Mesh_clear(self)


    def clean(self):
        """

        Clean out all auxiliary topology data. This clears all
        topological data, except the connectivity between cells and
        vertices.

        """
        return _mesh.Mesh_clean(self)


    def order(self):
        """

        Order all mesh entities.

        .. seealso::

            UFC documentation (put link here!)

        """
        return _mesh.Mesh_order(self)


    def ordered(self):
        """

        Check if mesh is ordered according to the UFC numbering convention.

        *Returns*
            bool
                The return values is true iff the mesh is ordered.

        """
        return _mesh.Mesh_ordered(self)


    def renumber_by_color(self):
        """

        Renumber mesh entities by coloring. This function is currently
        restricted to renumbering by cell coloring. The cells
        (cell-vertex connectivity) and the coordinates of the mesh are
        renumbered to improve the locality within each color. It is
        assumed that the mesh has already been colored and that only
        cell-vertex connectivity exists as part of the mesh.

        """
        return _mesh.Mesh_renumber_by_color(self)


    def translate(self, point):
        """

        Translate mesh according to a given vector.

        *Arguments*
            point (Point)
                The vector defining the translation.

        """
        return _mesh.Mesh_translate(self, point)


    def rotate(self, *args):
        """

        **Overloaded versions**

        * rotate\ (angle, axis=2)

          Rotate mesh around a coordinate axis through center of mass
          of all mesh vertices

          *Arguments*
              angle (float)
                  The number of degrees (0-360) of rotation.
              axis (int)
                  The coordinate axis around which to rotate the mesh.

        * rotate\ (angle, axis, point)

          Rotate mesh around a coordinate axis through a given point

          *Arguments*
              angle (float)
                  The number of degrees (0-360) of rotation.
              axis (int)
                  The coordinate axis around which to rotate the mesh.
              point (:py:class:`Point`)
                  The point around which to rotate the mesh.

        """
        return _mesh.Mesh_rotate(self, *args)


    def move(self, *args):
        """

        **Overloaded versions**

        * move\ (boundary)

          Move coordinates of mesh according to new boundary coordinates.

          *Arguments*
              boundary (:py:class:`BoundaryMesh`)
                  A mesh containing just the boundary cells.

          *Returns*
              MeshDisplacement
                  Displacement encapsulated in Expression subclass
                  MeshDisplacement.

        * move\ (mesh)

          Move coordinates of mesh according to adjacent mesh with
          common global vertices.

          *Arguments*
              mesh (:py:class:`Mesh`)
                  A :py:class:`Mesh` object.

          *Returns*
              MeshDisplacement
                  Displacement encapsulated in Expression subclass
                  MeshDisplacement.

        * move\ (displacement)

          Move coordinates of mesh according to displacement function.

          *Arguments*
              displacement (:py:class:`GenericFunction`)
                  A :py:class:`GenericFunction` object.

        """
        return _mesh.Mesh_move(self, *args)


    def smooth(self, num_iterations=1):
        """

        Smooth internal vertices of mesh by local averaging.

        *Arguments*
            num_iterations (int)
                Number of iterations to perform smoothing,
                default value is 1.

        """
        return _mesh.Mesh_smooth(self, num_iterations)


    def smooth_boundary(self, num_iterations=1, harmonic_smoothing=True):
        """

        Smooth boundary vertices of mesh by local averaging.

        *Arguments*
            num_iterations (int)
                Number of iterations to perform smoothing,
                default value is 1.

            harmonic_smoothing (bool)
                Flag to turn on harmonics smoothing, default
                value is true.

        """
        return _mesh.Mesh_smooth_boundary(self, num_iterations, harmonic_smoothing)


    def snap_boundary(self, sub_domain, harmonic_smoothing=True):
        """

        Snap boundary vertices of mesh to match given sub domain.

        *Arguments*
            sub_domain (:py:class:`SubDomain`)
                A :py:class:`SubDomain` object.

            harmonic_smoothing (bool)
                Flag to turn on harmonics smoothing, default
                value is true.

        """
        return _mesh.Mesh_snap_boundary(self, sub_domain, harmonic_smoothing)


    def color(self, *args):
        """

        **Overloaded versions**

        * color\ (coloring_type)

          Color the cells of the mesh such that no two neighboring cells
          share the same color. A colored mesh keeps a
          CellFunction<std::size_t> named "cell colors" as mesh data which
          holds the colors of the mesh.

          *Arguments*
              coloring_type (str)
                  Coloring type, specifying what relation makes two
                  cells neighbors, can be one of "vertex", "edge" or
                  "facet".

          *Returns*
              numpy.array(int)
                  The colors as a mesh function over the cells of the mesh.

        * color\ (coloring_type)

          Color the cells of the mesh such that no two neighboring cells
          share the same color. A colored mesh keeps a
          CellFunction<std::size_t> named "cell colors" as mesh data which
          holds the colors of the mesh.

          *Arguments*
              coloring_type (numpy.array(int))
                  Coloring type given as list of topological dimensions,
                  specifying what relation makes two mesh entities neighbors.

          *Returns*
              numpy.array(int)
                  The colors as a mesh function over entities of the mesh.

        """
        return _mesh.Mesh_color(self, *args)


    def hmin(self):
        """

        Compute minimum cell diameter.

        *Returns*
            float
                The minimum cell diameter, the diameter is computed as
                two times the circumradius
                (http://mathworld.wolfram.com).

        *Example*
            .. code-block:: python

                >>> mesh = dolfin.UnitSquare(2,2)
                >>> mesh.hmin()
                0.70710678118654757

        """
        return _mesh.Mesh_hmin(self)


    def hmax(self):
        """

        Compute maximum cell diameter.

        *Returns*
            float
                The maximum cell diameter, the diameter is computed as
                two times the circumradius
                (http://mathworld.wolfram.com).

        *Example*
            .. code-block:: python

                >>> mesh = dolfin.UnitSquare(2,2)
                >>> mesh.hmax()
                0.70710678118654757

        """
        return _mesh.Mesh_hmax(self)


    def rmin(self):
        """

        Compute minimum cell inradius.

        *Returns*
            float
                The minimum of cells' inscribed sphere radii

        *Example*
            .. note::

                No example code available for this function.

        """
        return _mesh.Mesh_rmin(self)


    def rmax(self):
        """

        Compute maximum cell inradius.

        *Returns*
            float
                The maximum of cells' inscribed sphere radii

        *Example*
            .. note::

                No example code available for this function.

        """
        return _mesh.Mesh_rmax(self)


    def hash(self):
        """

        Compute hash of mesh, currently based on the has of the mesh
        geometry and mesh topology.

        *Returns*
            int
                A tree-hashed value of the coordinates over all MPI processes


        """
        return _mesh.Mesh_hash(self)


    def init_cell_orientations(self, global_normal):
        """

        Compute and initialize cell_orientations relative to a given
        global outward direction/normal/orientation. Only defined if
        mesh is orientable.

        *Arguments*
            global_normal (Expression)
                A global normal direction to the mesh

        """
        return _mesh.Mesh_init_cell_orientations(self, global_normal)


    def mpi_comm(self):
        """

        Mesh MPI communicator

        """
        return _mesh.Mesh_mpi_comm(self)


    def coordinates(self):
        """
        * coordinates\ ()

          Get vertex coordinates.

          *Returns*
              numpy.array(float)
                  Coordinates of all vertices.

          *Example*
              .. code-block:: python

                  >>> mesh = dolfin.UnitSquare(1,1)
                  >>> mesh.coordinates()
                  array([[ 0.,  0.],
                         [ 1.,  0.],
                         [ 0.,  1.],
                         [ 1.,  1.]])
        """

    # Get coordinates
        coord = self._coordinates()

    # Attach a reference to the Mesh to the coord array
        _attach_base_to_numpy_array(coord, self)

        return coord

    def cell_orientations(self):
        """
        Get the cell orientations set.

        *Returns*
            numpy.array(int)
                Cell orientations
        """
    # Get coordinates
        orientations = self._cell_orientations()

    # Attach a reference to the Mesh to the orientations array
        _attach_base_to_numpy_array(orientations, self)

        return orientations

    def cells(self):
        """
        Get cell connectivity.

        *Returns*
            numpy.array(int)
                Connectivity for all cells.

        *Example*
            .. code-block:: python

                >>> mesh = dolfin.UnitSquare(1,1)
                >>> mesh.cells()
                array([[0, 1, 3],
                      [0, 2, 3]])
        """
    # Get coordinates
        cells = self._cells()

    # Attach a reference to the Mesh to the cells array
        _attach_base_to_numpy_array(cells, self)

        return cells



    def ufl_id(self):
        "Returns an id that UFL can use to decide if two objects are the same."
        return self.id()

    def ufl_cell(self):
        """
        Returns the ufl cell of the mesh.

        The cell corresponds to the topological dimension of the mesh.
        """
        import ufl
        tdim = self.topology().dim()
        gdim = self.geometry().dim()
        dim2domain = { 1: 'interval', 2: 'triangle', 3: 'tetrahedron' }
        cellname = dim2domain[tdim]

        cellname = CellType.type2string(self.type().cell_type())

        return ufl.Cell(cellname, geometric_dimension=gdim)

    def ufl_domain(self):
        """Returns the ufl Domain corresponding to the mesh."""
        import ufl
        label = "dolfin_mesh_with_id_%d" % self.id()
        return ufl.Domain(self.ufl_cell(), label=label, data=self)

Mesh.num_vertices = new_instancemethod(_mesh.Mesh_num_vertices, None, Mesh)
Mesh.num_edges = new_instancemethod(_mesh.Mesh_num_edges, None, Mesh)
Mesh.num_faces = new_instancemethod(_mesh.Mesh_num_faces, None, Mesh)
Mesh.num_facets = new_instancemethod(_mesh.Mesh_num_facets, None, Mesh)
Mesh.num_cells = new_instancemethod(_mesh.Mesh_num_cells, None, Mesh)
Mesh.num_entities = new_instancemethod(_mesh.Mesh_num_entities, None, Mesh)
Mesh.size = new_instancemethod(_mesh.Mesh_size, None, Mesh)
Mesh.size_global = new_instancemethod(_mesh.Mesh_size_global, None, Mesh)
Mesh.topology = new_instancemethod(_mesh.Mesh_topology, None, Mesh)
Mesh.geometry = new_instancemethod(_mesh.Mesh_geometry, None, Mesh)
Mesh.domains = new_instancemethod(_mesh.Mesh_domains, None, Mesh)
Mesh.bounding_box_tree = new_instancemethod(_mesh.Mesh_bounding_box_tree, None, Mesh)
Mesh.data = new_instancemethod(_mesh.Mesh_data, None, Mesh)
Mesh.type = new_instancemethod(_mesh.Mesh_type, None, Mesh)
Mesh.init = new_instancemethod(_mesh.Mesh_init, None, Mesh)
Mesh.clear = new_instancemethod(_mesh.Mesh_clear, None, Mesh)
Mesh.clean = new_instancemethod(_mesh.Mesh_clean, None, Mesh)
Mesh.order = new_instancemethod(_mesh.Mesh_order, None, Mesh)
Mesh.ordered = new_instancemethod(_mesh.Mesh_ordered, None, Mesh)
Mesh.renumber_by_color = new_instancemethod(_mesh.Mesh_renumber_by_color, None, Mesh)
Mesh.translate = new_instancemethod(_mesh.Mesh_translate, None, Mesh)
Mesh.rotate = new_instancemethod(_mesh.Mesh_rotate, None, Mesh)
Mesh.move = new_instancemethod(_mesh.Mesh_move, None, Mesh)
Mesh.smooth = new_instancemethod(_mesh.Mesh_smooth, None, Mesh)
Mesh.smooth_boundary = new_instancemethod(_mesh.Mesh_smooth_boundary, None, Mesh)
Mesh.snap_boundary = new_instancemethod(_mesh.Mesh_snap_boundary, None, Mesh)
Mesh.color = new_instancemethod(_mesh.Mesh_color, None, Mesh)
Mesh.hmin = new_instancemethod(_mesh.Mesh_hmin, None, Mesh)
Mesh.hmax = new_instancemethod(_mesh.Mesh_hmax, None, Mesh)
Mesh.rmin = new_instancemethod(_mesh.Mesh_rmin, None, Mesh)
Mesh.rmax = new_instancemethod(_mesh.Mesh_rmax, None, Mesh)
Mesh.hash = new_instancemethod(_mesh.Mesh_hash, None, Mesh)
Mesh.init_cell_orientations = new_instancemethod(_mesh.Mesh_init_cell_orientations, None, Mesh)
Mesh.mpi_comm = new_instancemethod(_mesh.Mesh_mpi_comm, None, Mesh)
Mesh._coordinates = new_instancemethod(_mesh.Mesh__coordinates, None, Mesh)
Mesh._cells = new_instancemethod(_mesh.Mesh__cells, None, Mesh)
Mesh._cell_orientations = new_instancemethod(_mesh.Mesh__cell_orientations, None, Mesh)
Mesh_swigregister = _mesh.Mesh_swigregister
Mesh_swigregister(Mesh)

class MeshEntity(object):
    """

    A MeshEntity represents a mesh entity associated with
    a specific topological dimension of some :py:class:`Mesh`.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * MeshEntity\ ()

          Default Constructor

        * MeshEntity\ (mesh, dim, index)

          Constructor

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh.
              dim (int)
                  The topological dimension.
              index (int)
                  The index.

        """
        _mesh.MeshEntity_swiginit(self, _mesh.new_MeshEntity(*args))
    __swig_destroy__ = _mesh.delete_MeshEntity

    def init(self, mesh, dim, index):
        """

        Initialize mesh entity with given data

        *Arguments*
            mesh (:py:class:`Mesh`)
                The mesh.
            dim (int)
                The topological dimension.
            index (int)
                The index.

        """
        return _mesh.MeshEntity_init(self, mesh, dim, index)


    def __eq__(self, e):
        """

        Comparison Operator

        *Arguments*
            another (:py:class:`MeshEntity`)
                Another mesh entity

        *Returns*
            bool
                True if the two mesh entities are equal.

        """
        return _mesh.MeshEntity___eq__(self, e)


    def __ne__(self, e):
        """

        Comparison Operator

        *Arguments*
            another (MeshEntity)
                Another mesh entity.

        *Returns*
            bool
                True if the two mesh entities are NOT equal.

        """
        return _mesh.MeshEntity___ne__(self, e)


    def mesh(self):
        """

        Return mesh associated with mesh entity

        *Returns*
            :py:class:`Mesh`
                The mesh.

        """
        return _mesh.MeshEntity_mesh(self)


    def dim(self):
        """

        Return topological dimension

        *Returns*
            int
                The dimension.

        """
        return _mesh.MeshEntity_dim(self)


    def global_index(self):
        """

        Return global index of mesh entity

        *Returns*
            int
                The global index. Set to
                std::numerical_limits<std::size_t>::max() if global index
                has not been computed

        """
        return _mesh.MeshEntity_global_index(self)


    def num_entities(self, dim):
        """

        Return local number of incident mesh entities of given
        topological dimension

        *Arguments*
            dim (int)
                The topological dimension.

        *Returns*
            int
        The number of local incident MeshEntity objects of given
        dimension.

        """
        return _mesh.MeshEntity_num_entities(self, dim)


    def num_global_entities(self, dim):
        """

        Return global number of incident mesh entities of given
        topological dimension

        *Arguments*
            dim (int)
                The topological dimension.

        *Returns*
            int
                The number of global incident MeshEntity objects of given
                dimension.

        """
        return _mesh.MeshEntity_num_global_entities(self, dim)


    def mesh_id(self):
        """

        Return unique mesh ID

        *Returns*
            int
                The unique mesh ID.

        """
        return _mesh.MeshEntity_mesh_id(self)


    def incident(self, entity):
        """

        Check if given entity is incident

        *Arguments*
            entity (:py:class:`MeshEntity`)
                The entity.

        *Returns*
            bool
                True if the given entity is incident

        """
        return _mesh.MeshEntity_incident(self, entity)


    def index(self, *args):
        """

        **Overloaded versions**

        * index\ ()

          Return index of mesh entity

          *Returns*
              int
                  The index.

        * index\ (entity)

          Compute local index of given incident entity (error if not
          found)

          *Arguments*
              entity (:py:class:`MeshEntity`)
                  The mesh entity.

          *Returns*
              int
                  The local index of given entity.

        """
        return _mesh.MeshEntity_index(self, *args)


    def midpoint(self):
        """

        Compute midpoint of cell

        *Returns*
            :py:class:`Point`
                The midpoint of the cell.

        """
        return _mesh.MeshEntity_midpoint(self)


    def is_ghost(self):
        """

        Determine whether an entity is a 'ghost' from another
        process

        """
        return _mesh.MeshEntity_is_ghost(self)


    def sharing_processes(self):
        """

        Return set of sharing processes

        """
        return _mesh.MeshEntity_sharing_processes(self)


    def is_shared(self):
        """

        Determine if an entity is shared or not

        """
        return _mesh.MeshEntity_is_shared(self)


    def owner(self):
        """

        Get ownership of this entity - only really valid for cells

        """
        return _mesh.MeshEntity_owner(self)


    def str(self, verbose):
        """

        Return informal string representation (pretty-print)

        *Arguments*
            verbose (bool)
                Flag to turn on additional output.

        *Returns*
            str
                An informal representation of the function space.

        """
        return _mesh.MeshEntity_str(self, verbose)


    def entities(self, dim):
        """ Return number of incident mesh entities of given topological dimension"""
        return self.mesh().topology()(self.dim(), dim)(self.index())

    def __str__(self):
        """Pretty print of MeshEntity"""
        return self.str(False)

MeshEntity.init = new_instancemethod(_mesh.MeshEntity_init, None, MeshEntity)
MeshEntity.__eq__ = new_instancemethod(_mesh.MeshEntity___eq__, None, MeshEntity)
MeshEntity.__ne__ = new_instancemethod(_mesh.MeshEntity___ne__, None, MeshEntity)
MeshEntity.mesh = new_instancemethod(_mesh.MeshEntity_mesh, None, MeshEntity)
MeshEntity.dim = new_instancemethod(_mesh.MeshEntity_dim, None, MeshEntity)
MeshEntity.global_index = new_instancemethod(_mesh.MeshEntity_global_index, None, MeshEntity)
MeshEntity.num_entities = new_instancemethod(_mesh.MeshEntity_num_entities, None, MeshEntity)
MeshEntity.num_global_entities = new_instancemethod(_mesh.MeshEntity_num_global_entities, None, MeshEntity)
MeshEntity.mesh_id = new_instancemethod(_mesh.MeshEntity_mesh_id, None, MeshEntity)
MeshEntity.incident = new_instancemethod(_mesh.MeshEntity_incident, None, MeshEntity)
MeshEntity.index = new_instancemethod(_mesh.MeshEntity_index, None, MeshEntity)
MeshEntity.midpoint = new_instancemethod(_mesh.MeshEntity_midpoint, None, MeshEntity)
MeshEntity.is_ghost = new_instancemethod(_mesh.MeshEntity_is_ghost, None, MeshEntity)
MeshEntity.sharing_processes = new_instancemethod(_mesh.MeshEntity_sharing_processes, None, MeshEntity)
MeshEntity.is_shared = new_instancemethod(_mesh.MeshEntity_is_shared, None, MeshEntity)
MeshEntity.owner = new_instancemethod(_mesh.MeshEntity_owner, None, MeshEntity)
MeshEntity.str = new_instancemethod(_mesh.MeshEntity_str, None, MeshEntity)
MeshEntity_swigregister = _mesh.MeshEntity_swigregister
MeshEntity_swigregister(MeshEntity)

class entities(object):
    """

    MeshEntityIterator provides a common iterator for mesh entities
    over meshes, boundaries and incidence relations. The basic use
    is illustrated below.

    *Example*
        The following example shows how to iterate over all mesh entities
        of a mesh of topological dimension dim:

        .. code-block:: python

            >>> for e in dolfin.cpp.entities(mesh, 1):
            ...     print e.index()

        The following example shows how to iterate over mesh entities of
        topological dimension dim connected (incident) to some mesh entity f:

        .. code-block:: python

            >>> f = dolfin.cpp.MeshEntity(mesh, 0, 0)
            >>> for e in dolfin.cpp.entities(f, 1):
            ...     print e.index()
    In addition to the general iterator, a set of specific named iterators
    are provided for entities of type :py:class:`Vertex`, :py:class:`Edge`, :py:class:`Face`, :py:class:`Facet`
    and :py:class:`Cell`. These iterators are defined along with their respective
    classes.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * MeshEntityIterator\ ()

          Default constructor

        * MeshEntityIterator\ (mesh, dim)

          Create iterator for mesh entities over given topological dimension

        * MeshEntityIterator\ (mesh, dim, opt)

          Iterator over MeshEntity of dimension dim on mesh, with string option
          to iterate over "regular", "ghost" or "all" entities

        * MeshEntityIterator\ (entity, dim)

          Create iterator for entities of given dimension connected to
          given entity

        * MeshEntityIterator\ (it)

          Copy constructor

        """
        _mesh.entities_swiginit(self, _mesh.new_entities(*args))
    __swig_destroy__ = _mesh.delete_entities

    def _increment(self):
        """

        Step to next mesh entity (prefix increment)

        """
        return _mesh.entities__increment(self)


    def _decrease(self):
        """

        Step to the previous mesh entity (prefix decrease)

        """
        return _mesh.entities__decrease(self)


    def pos(self):
        """

        Return current position

        """
        return _mesh.entities_pos(self)


    def __eq__(self, it):
        """

        Comparison operator

        """
        return _mesh.entities___eq__(self, it)


    def __ne__(self, it):
        """

        Comparison operator

        """
        return _mesh.entities___ne__(self, it)


    def _dereference(self):
        """

        Dereference operator

        """
        return _mesh.entities__dereference(self)


    def end(self):
        """

        Check if iterator has reached the end

        """
        return _mesh.entities_end(self)


    def end_iterator(self):
        """

        Provide a safeguard iterator pointing beyond the end of an
        iteration process, either iterating over the mesh /or incident
        entities. Added to be bit more like STL iterators, since many
        algorithms rely on a kind of beyond iterator.

        """
        return _mesh.entities_end_iterator(self)


    def __iter__(self):
        self.first = True
        return self

    def __next__(self):
        self.first = self.first if hasattr(self,"first") else True
        if not self.first:
            self._increment()
        if self.end():
            self._decrease()
            raise StopIteration
        self.first = False
        return self._dereference()
    # Py2/Py3
    next = __next__

entities._increment = new_instancemethod(_mesh.entities__increment, None, entities)
entities._decrease = new_instancemethod(_mesh.entities__decrease, None, entities)
entities.pos = new_instancemethod(_mesh.entities_pos, None, entities)
entities.__eq__ = new_instancemethod(_mesh.entities___eq__, None, entities)
entities.__ne__ = new_instancemethod(_mesh.entities___ne__, None, entities)
entities._dereference = new_instancemethod(_mesh.entities__dereference, None, entities)
entities.end = new_instancemethod(_mesh.entities_end, None, entities)
entities.end_iterator = new_instancemethod(_mesh.entities_end_iterator, None, entities)
entities_swigregister = _mesh.entities_swigregister
entities_swigregister(entities)

class SubsetIterator(object):
    """

    A :py:class:`SubsetIterator` is similar to a :py:class:`MeshEntityIterator` but
    iterates over a specified subset of the range of entities as
    specified by a :py:class:`MeshFunction` that labels the entities.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * SubsetIterator\ (labels, label)

          Create iterator for given mesh function. The iterator visits
          all entities that match the given label.

        * SubsetIterator\ (subset_iter)

          Copy Constructor

        """
        _mesh.SubsetIterator_swiginit(self, _mesh.new_SubsetIterator(*args))
    __swig_destroy__ = _mesh.delete_SubsetIterator

    def _increment(self):
        """

        Step to next mesh entity (prefix increment)

        """
        return _mesh.SubsetIterator__increment(self)


    def __eq__(self, sub_iter):
        """

        Comparison operator

        """
        return _mesh.SubsetIterator___eq__(self, sub_iter)


    def __ne__(self, sub_iter):
        """

        Comparison operator

        """
        return _mesh.SubsetIterator___ne__(self, sub_iter)


    def _dereference(self):
        """

        Dereference operator

        """
        return _mesh.SubsetIterator__dereference(self)


    def end(self):
        """

        Check if iterator has reached the end

        """
        return _mesh.SubsetIterator_end(self)


    def __iter__(self):
        self.first = True
        return self

    def __next__(self):
        self.first = self.first if hasattr(self,"first") else True
        if not self.first:
            self._increment()
        if self.end():
            raise StopIteration
        self.first = False
        return self._dereference()
    # Py2/Py3
    next = __next__

SubsetIterator._increment = new_instancemethod(_mesh.SubsetIterator__increment, None, SubsetIterator)
SubsetIterator.__eq__ = new_instancemethod(_mesh.SubsetIterator___eq__, None, SubsetIterator)
SubsetIterator.__ne__ = new_instancemethod(_mesh.SubsetIterator___ne__, None, SubsetIterator)
SubsetIterator._dereference = new_instancemethod(_mesh.SubsetIterator__dereference, None, SubsetIterator)
SubsetIterator.end = new_instancemethod(_mesh.SubsetIterator_end, None, SubsetIterator)
SubsetIterator.end_iterator = new_instancemethod(_mesh.SubsetIterator_end_iterator, None, SubsetIterator)
SubsetIterator_swigregister = _mesh.SubsetIterator_swigregister
SubsetIterator_swigregister(SubsetIterator)

class Vertex(MeshEntity):
    """

    A Vertex is a MeshEntity of topological dimension 0.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * Vertex\ (mesh, index)

          Create vertex on given mesh

        * Vertex\ (entity)

          Create vertex from mesh entity

        """
        _mesh.Vertex_swiginit(self, _mesh.new_Vertex(*args))
    __swig_destroy__ = _mesh.delete_Vertex

    def point(self):
        """

        Return vertex coordinates as a 3D point value

        """
        return _mesh.Vertex_point(self)


    def x(self, *args):
        """

        **Overloaded versions**

        * x\ (i)

          Return value of vertex coordinate i

        * x\ ()

          Return array of vertex coordinates (const version)

        """
        return _mesh.Vertex_x(self, *args)

Vertex.point = new_instancemethod(_mesh.Vertex_point, None, Vertex)
Vertex.x = new_instancemethod(_mesh.Vertex_x, None, Vertex)
Vertex_swigregister = _mesh.Vertex_swigregister
Vertex_swigregister(Vertex)

class Edge(MeshEntity):
    """

    An Edge is a :py:class:`MeshEntity` of topological dimension 1.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * Edge\ (mesh, index)

          Create edge on given mesh

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh.
              index (int)
                  Index of the edge.

        * Edge\ (entity)

          Create edge from mesh entity

          *Arguments*
              entity (:py:class:`MeshEntity`)
                  The mesh entity to create an edge from.

        """
        _mesh.Edge_swiginit(self, _mesh.new_Edge(*args))
    __swig_destroy__ = _mesh.delete_Edge

    def length(self):
        """

        Compute Euclidean length of edge

        *Returns*
            float
                Euclidean length of edge.

        *Example*
            .. note::

                No example code available for this function.

        """
        return _mesh.Edge_length(self)


    def dot(self, edge):
        """

        Compute dot product between edge and other edge

        *Arguments*
            edge (:py:class:`Edge`)
                Another edge.

        *Returns*
            float
                The dot product.

        *Example*
            .. note::

                No example code available for this function.

        """
        return _mesh.Edge_dot(self, edge)

Edge.length = new_instancemethod(_mesh.Edge_length, None, Edge)
Edge.dot = new_instancemethod(_mesh.Edge_dot, None, Edge)
Edge_swigregister = _mesh.Edge_swigregister
Edge_swigregister(Edge)

class Face(MeshEntity):
    """

    A Face is a MeshEntity of topological dimension 2.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, mesh, index):
        """

        Constructor

        """
        _mesh.Face_swiginit(self, _mesh.new_Face(mesh, index))
    __swig_destroy__ = _mesh.delete_Face

    def area(self):
        """

        Calculate the area of the face (triangle)

        """
        return _mesh.Face_area(self)


    def normal(self, *args):
        """

        **Overloaded versions**

        * normal\ (i)

          Compute component i of the normal to the face

        * normal\ ()

          Compute normal to the face

        """
        return _mesh.Face_normal(self, *args)

Face.area = new_instancemethod(_mesh.Face_area, None, Face)
Face.normal = new_instancemethod(_mesh.Face_normal, None, Face)
Face_swigregister = _mesh.Face_swigregister
Face_swigregister(Face)

class Facet(MeshEntity):
    """

    A Facet is a MeshEntity of topological codimension 1.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, mesh, index):
        """

        Constructor

        """
        _mesh.Facet_swiginit(self, _mesh.new_Facet(mesh, index))
    __swig_destroy__ = _mesh.delete_Facet

    def normal(self, *args):
        """

        **Overloaded versions**

        * normal\ (i)

          Compute component i of the normal to the facet

        * normal\ ()

          Compute normal to the facet

        """
        return _mesh.Facet_normal(self, *args)


    def squared_distance(self, point):
        """

        Compute squared distance to given point.

        *Arguments*
            point (:py:class:`Point`)
                The point.
        *Returns*
            float
                The squared distance to the point.

        """
        return _mesh.Facet_squared_distance(self, point)


    def distance(self, point):
        """

        Compute distance to given point.

        *Arguments*
            point (:py:class:`Point`)
                The point.
        *Returns*
            float
                The distance to the point.

        """
        return _mesh.Facet_distance(self, point)


    def exterior(self):
        """

        Return true if facet is an exterior facet (relative to global mesh,
        so this function will return false for facets on partition
        boundaries). Facet connectivity must be initialized before
        calling this function.

        """
        return _mesh.Facet_exterior(self)

Facet.normal = new_instancemethod(_mesh.Facet_normal, None, Facet)
Facet.squared_distance = new_instancemethod(_mesh.Facet_squared_distance, None, Facet)
Facet.distance = new_instancemethod(_mesh.Facet_distance, None, Facet)
Facet.exterior = new_instancemethod(_mesh.Facet_exterior, None, Facet)
Facet_swigregister = _mesh.Facet_swigregister
Facet_swigregister(Facet)

class Cell(MeshEntity):
    """

    A Cell is a :py:class:`MeshEntity` of topological codimension 0.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * Cell\ ()

          Create empty cell

        * Cell\ (mesh, index)

          Create cell on given mesh with given index

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh.
              index (int)
                  The index.

        """
        _mesh.Cell_swiginit(self, _mesh.new_Cell(*args))
    __swig_destroy__ = _mesh.delete_Cell

    def type(self):
        """

        Return type of cell

        """
        return _mesh.Cell_type(self)


    def num_vertices(self):
        """

        Return number of vertices of cell

        """
        return _mesh.Cell_num_vertices(self)


    def orientation(self, *args):
        """

        **Overloaded versions**

        * orientation\ ()

          Compute orientation of cell

          *Returns*
              int
                  Orientation of the cell (0 is 'up'/'right', 1 is 'down'/'left')

        * orientation\ (up)

          Compute orientation of cell relative to given 'up' direction

          *Arguments*
              up (:py:class:`Point`)
                  The direction defined as 'up'

          *Returns*
              int
                  Orientation of the cell (0 is 'same', 1 is 'opposite')

        """
        return _mesh.Cell_orientation(self, *args)


    def volume(self):
        """

        Compute (generalized) volume of cell

        *Returns*
            float
                The volume of the cell.

        *Example*
            .. note::

                No example code available for this function.

        """
        return _mesh.Cell_volume(self)


    def diameter(self):
        """

        Compute diameter of cell

        *Returns*
            float
                The diameter of the cell.

        *Example*
            .. note::

                No example code available for this function.

        """
        return _mesh.Cell_diameter(self)


    def inradius(self):
        """

        Compute inradius of cell

        *Returns*
            float
                Radius of the sphere inscribed in the cell.

        *Example*
            .. note::

                No example code available for this function.

        """
        return _mesh.Cell_inradius(self)


    def radius_ratio(self):
        """

        Compute ratio of inradius to circumradius times dim for cell.
        Useful as cell quality measure. Returns 1. for equilateral
        and 0. for degenerate cell.
        See Jonathan Richard Shewchuk: What Is a Good Linear Finite Element?,
        online: http://www.cs.berkeley.edu/~jrs/papers/elemj.pdf

        *Returns*
            float
                topological_dimension * inradius / circumradius

        *Example*
            .. note::

                No example code available for this function.

        """
        return _mesh.Cell_radius_ratio(self)


    def squared_distance(self, point):
        """

        Compute squared distance to given point.

        *Arguments*
            point (:py:class:`Point`)
                The point.
        *Returns*
            float
                The squared distance to the point.

        """
        return _mesh.Cell_squared_distance(self, point)


    def distance(self, point):
        """

        Compute distance to given point.

        *Arguments*
            point (:py:class:`Point`)
                The point.
        *Returns*
            float
                The distance to the point.

        """
        return _mesh.Cell_distance(self, point)


    def normal(self, *args):
        """

        **Overloaded versions**

        * normal\ (facet, i)

          Compute component i of normal of given facet with respect to the cell

          *Arguments*
              facet (int)
                  Index of facet.
              i (int)
                  Component.

          *Returns*
              float
                  Component i of the normal of the facet.

        * normal\ (facet)

          Compute normal of given facet with respect to the cell

          *Arguments*
              facet (int)
                  Index of facet.

          *Returns*
              :py:class:`Point`
                  Normal of the facet.

        """
        return _mesh.Cell_normal(self, *args)


    def cell_normal(self):
        """

        Compute normal to cell itself (viewed as embedded in 3D)

        *Returns*
            :py:class:`Point`
                Normal of the cell

        """
        return _mesh.Cell_cell_normal(self)


    def facet_area(self, facet):
        """

        Compute the area/length of given facet with respect to the cell

        *Arguments*
            facet (int)
                Index of the facet.

        *Returns*
            float
                Area/length of the facet.

        """
        return _mesh.Cell_facet_area(self, facet)


    def order(self, local_to_global_vertex_indices):
        """

        Order entities locally

        *Arguments*
            global_vertex_indices (numpy.array(int))
                The global vertex indices.

        """
        return _mesh.Cell_order(self, local_to_global_vertex_indices)


    def ordered(self, local_to_global_vertex_indices):
        """

        Check if entities are ordered

        *Arguments*
            global_vertex_indices (numpy.array(int))
                The global vertex indices.

        *Returns*
            bool
                True iff ordered.

        """
        return _mesh.Cell_ordered(self, local_to_global_vertex_indices)


    def contains(self, point):
        """

        Check whether given point is contained in cell. This function is
        identical to the function collides(point).

        *Arguments*
            point (:py:class:`Point`)
                The point to be checked.

        *Returns*
            bool
                True iff point is contained in cell.

        """
        return _mesh.Cell_contains(self, point)


    def collides(self, *args):
        """

        **Overloaded versions**

        * collides\ (point)

          Check whether given point collides with cell

          *Arguments*
              point (:py:class:`Point`)
                  The point to be checked.

          *Returns*
              bool
                  True iff point collides with cell.

        * collides\ (entity)

          Check whether given entity collides with cell

          *Arguments*
              entity (:py:class:`MeshEntity`)
                  The cell to be checked.

          *Returns*
              bool
                  True iff entity collides with cell.

        """
        return _mesh.Cell_collides(self, *args)


    def triangulate_intersection(self, entity):
        """

        Compute triangulation of intersection with given entity

        *Arguments*
            entity (:py:class:`MeshEntity`)
                The entity with which to intersect.

        *Returns*
            numpy.array(float)
                A flattened array of simplices of dimension
                num_simplices x num_vertices x gdim =
                num_simplices x (tdim + 1) x gdim

        """
        return _mesh.Cell_triangulate_intersection(self, entity)


    def get_vertex_coordinates(self, *args):
        """

        **Overloaded versions**

        * get_vertex_coordinates\ (coordinates)

          Get cell vertex coordinates

        * get_vertex_coordinates\ (coordinates)

          Get cell vertex coordinates

        """
        return _mesh.Cell_get_vertex_coordinates(self, *args)


    def get_cell_data(self, ufc_cell, local_facet=-1):
        """

        Fill UFC cell with miscellaneous data

        """
        return _mesh.Cell_get_cell_data(self, ufc_cell, local_facet)


    def get_cell_topology(self, ufc_cell):
        """

        Fill UFC cell with topology data

        """
        return _mesh.Cell_get_cell_topology(self, ufc_cell)

Cell.type = new_instancemethod(_mesh.Cell_type, None, Cell)
Cell.num_vertices = new_instancemethod(_mesh.Cell_num_vertices, None, Cell)
Cell.orientation = new_instancemethod(_mesh.Cell_orientation, None, Cell)
Cell.volume = new_instancemethod(_mesh.Cell_volume, None, Cell)
Cell.diameter = new_instancemethod(_mesh.Cell_diameter, None, Cell)
Cell.inradius = new_instancemethod(_mesh.Cell_inradius, None, Cell)
Cell.radius_ratio = new_instancemethod(_mesh.Cell_radius_ratio, None, Cell)
Cell.squared_distance = new_instancemethod(_mesh.Cell_squared_distance, None, Cell)
Cell.distance = new_instancemethod(_mesh.Cell_distance, None, Cell)
Cell.normal = new_instancemethod(_mesh.Cell_normal, None, Cell)
Cell.cell_normal = new_instancemethod(_mesh.Cell_cell_normal, None, Cell)
Cell.facet_area = new_instancemethod(_mesh.Cell_facet_area, None, Cell)
Cell.order = new_instancemethod(_mesh.Cell_order, None, Cell)
Cell.ordered = new_instancemethod(_mesh.Cell_ordered, None, Cell)
Cell.contains = new_instancemethod(_mesh.Cell_contains, None, Cell)
Cell.collides = new_instancemethod(_mesh.Cell_collides, None, Cell)
Cell.triangulate_intersection = new_instancemethod(_mesh.Cell_triangulate_intersection, None, Cell)
Cell.get_vertex_coordinates = new_instancemethod(_mesh.Cell_get_vertex_coordinates, None, Cell)
Cell.get_cell_data = new_instancemethod(_mesh.Cell_get_cell_data, None, Cell)
Cell.get_cell_topology = new_instancemethod(_mesh.Cell_get_cell_topology, None, Cell)
Cell_swigregister = _mesh.Cell_swigregister
Cell_swigregister(Cell)

class FacetCell(Cell):
    """

    This class represents a cell in a mesh incident to a facet on
    the boundary. It is useful in cases where one needs to iterate
    over a boundary mesh and access the corresponding cells in the
    original mesh.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, mesh, facet):
        """

        Create cell on mesh corresponding to given facet (cell) on boundary

        """
        _mesh.FacetCell_swiginit(self, _mesh.new_FacetCell(mesh, facet))
    __swig_destroy__ = _mesh.delete_FacetCell

    def facet_index(self):
        """

        Return local index of facet with respect to the cell

        """
        return _mesh.FacetCell_facet_index(self)

FacetCell.facet_index = new_instancemethod(_mesh.FacetCell_facet_index, None, FacetCell)
FacetCell_swigregister = _mesh.FacetCell_swigregister
FacetCell_swigregister(FacetCell)

class MeshConnectivity(object):
    """

    Mesh connectivity stores a sparse data structure of connections
    (incidence relations) between mesh entities for a fixed pair of
    topological dimensions.

    The connectivity can be specified either by first giving the
    number of entities and the number of connections for each entity,
    which may either be equal for all entities or different, or by
    giving the entire (sparse) connectivity pattern.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * MeshConnectivity\ (d0, d1)

          Create empty connectivity between given dimensions (d0 -- d1)

        * MeshConnectivity\ (connectivity)

          Copy constructor

        """
        _mesh.MeshConnectivity_swiginit(self, _mesh.new_MeshConnectivity(*args))
    __swig_destroy__ = _mesh.delete_MeshConnectivity

    def empty(self):
        """

        Return true if the total number of connections is equal to zero

        """
        return _mesh.MeshConnectivity_empty(self)


    def size(self, *args):
        """

        **Overloaded versions**

        * size\ ()

          Return total number of connections

        * size\ (entity)

          Return number of connections for given entity

        """
        return _mesh.MeshConnectivity_size(self, *args)


    def size_global(self, entity):
        """

        Return global number of connections for given entity

        """
        return _mesh.MeshConnectivity_size_global(self, entity)


    def clear(self):
        """

        Clear all data

        """
        return _mesh.MeshConnectivity_clear(self)


    def init(self, *args):
        """

        **Overloaded versions**

        * init\ (num_entities, num_connections)

          Initialize number of entities and number of connections (equal
          for all)

        * init\ (num_connections)

          Initialize number of entities and number of connections
          (individually)

        """
        return _mesh.MeshConnectivity_init(self, *args)


    def set_global_size(self, num_global_connections):
        """

        Set global number of connections for all local entities

        """
        return _mesh.MeshConnectivity_set_global_size(self, num_global_connections)


    def hash(self):
        """

        Hash of connections

        """
        return _mesh.MeshConnectivity_hash(self)


    def str(self, verbose):
        """

        Return informal string representation (pretty-print)

        """
        return _mesh.MeshConnectivity_str(self, verbose)

MeshConnectivity.empty = new_instancemethod(_mesh.MeshConnectivity_empty, None, MeshConnectivity)
MeshConnectivity.size = new_instancemethod(_mesh.MeshConnectivity_size, None, MeshConnectivity)
MeshConnectivity.size_global = new_instancemethod(_mesh.MeshConnectivity_size_global, None, MeshConnectivity)
MeshConnectivity.clear = new_instancemethod(_mesh.MeshConnectivity_clear, None, MeshConnectivity)
MeshConnectivity.init = new_instancemethod(_mesh.MeshConnectivity_init, None, MeshConnectivity)
MeshConnectivity.set_global_size = new_instancemethod(_mesh.MeshConnectivity_set_global_size, None, MeshConnectivity)
MeshConnectivity.hash = new_instancemethod(_mesh.MeshConnectivity_hash, None, MeshConnectivity)
MeshConnectivity.str = new_instancemethod(_mesh.MeshConnectivity_str, None, MeshConnectivity)
MeshConnectivity.__call__ = new_instancemethod(_mesh.MeshConnectivity___call__, None, MeshConnectivity)
MeshConnectivity_swigregister = _mesh.MeshConnectivity_swigregister
MeshConnectivity_swigregister(MeshConnectivity)

class MeshEditor(object):
    """

    A simple mesh editor for creating simplicial meshes in 1D, 2D
    and 3D.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """

        Constructor

        """
        _mesh.MeshEditor_swiginit(self, _mesh.new_MeshEditor())
    __swig_destroy__ = _mesh.delete_MeshEditor

    def open(self, *args):
        """

        **Overloaded versions**

        * open\ (mesh, tdim, gdim)

          Open mesh of given topological and geometrical dimension

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to open.
              tdim (int)
                  The topological dimension.
              gdim (int)
                  The geometrical dimension.

          *Example*
              .. note::

                  No example code available for this function.

        * open\ (mesh, type, tdim, gdim)

          Open mesh of given cell type, topological and geometrical dimension

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to open.
              type (CellType::Type)
                  Cell type.
              tdim (int)
                  The topological dimension.
              gdim (int)
                  The geometrical dimension.

        * open\ (mesh, type, tdim, gdim)

          Open mesh of given cell type, topological and geometrical dimension

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to open.
              type (str)
                  Cell type.
              tdim (int)
                  The topological dimension.
              gdim (int)
                  The geometrical dimension.

        """
        return _mesh.MeshEditor_open(self, *args)


    def init_vertices(self, num_vertices):
        """

        Specify number of vertices (serial version)

        *Arguments*
            num_vertices (int)
                The number of vertices.

        *Example*
            .. note::

                No example code available for this function.

        """
        return _mesh.MeshEditor_init_vertices(self, num_vertices)


    def init_vertices_global(self, num_local_vertices, num_global_vertices):
        """

        Specify number of vertices (distributed version)

        *Arguments*
            num_local_vertices (int)
                The number of vertices on this process.
            num_global_vertices (int)
                The number of vertices in distributed mesh.

        *Example*
            .. note::

                No example code available for this function.

        """
        return _mesh.MeshEditor_init_vertices_global(self, num_local_vertices, num_global_vertices)


    def init_cells(self, num_cells):
        """

        Specify number of cells (serial version)

        *Arguments*
            num_cells (int)
                The number of cells.

        *Example*
            .. note::

                No example code available for this function.

        """
        return _mesh.MeshEditor_init_cells(self, num_cells)


    def init_cells_global(self, num_local_cells, num_global_cells):
        """

        Specify number of cells (distributed version)

        *Arguments*
            num_local_cells (int)
                The number of local cells.
            num_global_cells (int)
                The number of cells in distributed mesh.

        *Example*
            .. note::

                No example code available for this function.

        """
        return _mesh.MeshEditor_init_cells_global(self, num_local_cells, num_global_cells)


    def add_vertex(self, *args):
        """

        **Overloaded versions**

        * add_vertex\ (index, p)

          Add vertex v at given point p

          *Arguments*
              index (int)
                  The vertex (index).
              p (:py:class:`Point`)
                  The point.

        * add_vertex\ (index, x)

          Add vertex v at given coordinate x

          *Arguments*
              index (int)
                  The vertex (index).
              x (numpy.array(float))
                  The x-coordinates.

        * add_vertex\ (index, x)

          Add vertex v at given point x (for a 1D mesh)

          *Arguments*
              index (int)
                  The vertex (index).
              x (float)
                  The x-coordinate.

        * add_vertex\ (index, x, y)

          Add vertex v at given point (x, y) (for a 2D mesh)

          *Arguments*
              index (int)
                  The vertex (index).
              x (float)
                  The x-coordinate.
              y (float)
                  The y-coordinate.

        * add_vertex\ (index, x, y, z)

          Add vertex v at given point (x, y, z) (for a 3D mesh)

          *Arguments*
              index (int)
                  The vertex (index).
              x (float)
                  The x-coordinate.
              y (float)
                  The y-coordinate.
              z (float)
                  The z-coordinate.

        """
        return _mesh.MeshEditor_add_vertex(self, *args)


    def add_vertex_global(self, *args):
        """

        **Overloaded versions**

        * add_vertex_global\ (local_index, global_index, p)

          Add vertex v at given point p

          *Arguments*
              local_index (int)
                  The vertex (local index).
              global_index (int)
                  The vertex (global_index).
              p (:py:class:`Point`)
                  The point.

        * add_vertex_global\ (local_index, global_index, x)

          Add vertex v at given coordinate x

          *Arguments*
              local_index (int)
                  The vertex (local index).
              global_index (int)
                  The vertex (global_index).
              x (numpy.array(float))
                  The x-coordinates.

        """
        return _mesh.MeshEditor_add_vertex_global(self, *args)


    def add_cell(self, *args):
        """

        **Overloaded versions**

        * add_cell\ (c, v0, v1)

          Add cell with given vertices (1D)

          *Arguments*
              c (int)
                  The cell (index).
              v0 (numpy.array(int))
                  The first vertex (local index).
              v1 (numpy.array(int))
                  The second vertex (local index).

        * add_cell\ (c, v0, v1, v2)

          Add cell with given vertices (2D)

          *Arguments*
              c (int)
                  The cell (index).
              v0 (numpy.array(int))
                  The first vertex (local index).
              v1 (numpy.array(int))
                  The second vertex (local index).
              v2 (numpy.array(int))
                  The third vertex (local index).

        * add_cell\ (c, v0, v1, v2, v3)

          Add cell with given vertices (3D)

          *Arguments*
              c (int)
                  The cell (index).
              v0 (numpy.array(int))
                  The first vertex (local index).
              v1 (numpy.array(int))
                  The second vertex (local index).
              v2 (numpy.array(int))
                  The third vertex (local index).
              v3 (numpy.array(int))
                  The fourth vertex (local index).

        * add_cell\ (c, v)

          Add cell with given vertices (non-templated version for Python
          interface)

          *Arguments*
              c (int)
                  The cell (index).
              v (numpy.array(int))
                  The vertex indices (local indices)

        * add_cell\ (c, v)

          Add cell with given vertices

          *Arguments*
              c (int)
                  The cell (index).
              v (typename T)
                  The vertex indices (local indices)

        * add_cell\ (local_index, global_index, v)

          Add cell with given vertices

          *Arguments*
              local_index (int)
                  The cell (index).
              global_index (int)
                  The global (user) cell index.
              v (numpy.array(int))
                  The vertex indices (local indices)

        """
        return _mesh.MeshEditor_add_cell(self, *args)


    def close(self, order=True):
        """

        Close mesh, finish editing, and order entities locally

        *Arguments*
            order (bool)
                Order entities locally if true. Default values is true.

        *Example*
            .. note::

                No example code available for this function.

        """
        return _mesh.MeshEditor_close(self, order)

MeshEditor.open = new_instancemethod(_mesh.MeshEditor_open, None, MeshEditor)
MeshEditor.init_vertices = new_instancemethod(_mesh.MeshEditor_init_vertices, None, MeshEditor)
MeshEditor.init_vertices_global = new_instancemethod(_mesh.MeshEditor_init_vertices_global, None, MeshEditor)
MeshEditor.init_cells = new_instancemethod(_mesh.MeshEditor_init_cells, None, MeshEditor)
MeshEditor.init_cells_global = new_instancemethod(_mesh.MeshEditor_init_cells_global, None, MeshEditor)
MeshEditor.add_vertex = new_instancemethod(_mesh.MeshEditor_add_vertex, None, MeshEditor)
MeshEditor.add_vertex_global = new_instancemethod(_mesh.MeshEditor_add_vertex_global, None, MeshEditor)
MeshEditor.add_cell = new_instancemethod(_mesh.MeshEditor_add_cell, None, MeshEditor)
MeshEditor.close = new_instancemethod(_mesh.MeshEditor_close, None, MeshEditor)
MeshEditor_swigregister = _mesh.MeshEditor_swigregister
MeshEditor_swigregister(MeshEditor)

class DynamicMeshEditor(object):
    """

    This class provides an interface for dynamic editing of meshes,
    that is, when the number of vertices and cells are not known
    a priori. If the number of vertices and cells are known a priori,
    it is more efficient to use the default editor MeshEditor.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """

        Constructor

        """
        _mesh.DynamicMeshEditor_swiginit(self, _mesh.new_DynamicMeshEditor())
    __swig_destroy__ = _mesh.delete_DynamicMeshEditor

    def open(self, *args):
        """

        **Overloaded versions**

        * open\ (mesh, type, tdim, gdim, num_global_vertices, num_global_cells)

          Open mesh of given cell type, topological and geometrical dimension

        * open\ (mesh, type, tdim, gdim, num_global_vertices, num_global_cells)

          Open mesh of given cell type, topological and geometrical dimension

        """
        return _mesh.DynamicMeshEditor_open(self, *args)


    def add_vertex(self, *args):
        """

        **Overloaded versions**

        * add_vertex\ (v, p)

          Add vertex v at given point p

        * add_vertex\ (v, x)

          Add vertex v at given coordinate x

        * add_vertex\ (v, x, y)

          Add vertex v at given coordinate (x, y)

        * add_vertex\ (v, x, y, z)

          Add vertex v at given coordinate (x, y, z)

        """
        return _mesh.DynamicMeshEditor_add_vertex(self, *args)


    def add_cell(self, *args):
        """

        **Overloaded versions**

        * add_cell\ (c, v)

          Add cell with given vertices

        * add_cell\ (c, v0, v1)

          Add cell (interval) with given vertices

        * add_cell\ (c, v0, v1, v2)

          Add cell (triangle) with given vertices

        * add_cell\ (c, v0, v1, v2, v3)

          Add cell (tetrahedron) with given vertices

        """
        return _mesh.DynamicMeshEditor_add_cell(self, *args)


    def close(self, order=False):
        """

        Close mesh, finish editing, and order entities locally

        """
        return _mesh.DynamicMeshEditor_close(self, order)

DynamicMeshEditor.open = new_instancemethod(_mesh.DynamicMeshEditor_open, None, DynamicMeshEditor)
DynamicMeshEditor.add_vertex = new_instancemethod(_mesh.DynamicMeshEditor_add_vertex, None, DynamicMeshEditor)
DynamicMeshEditor.add_cell = new_instancemethod(_mesh.DynamicMeshEditor_add_cell, None, DynamicMeshEditor)
DynamicMeshEditor.close = new_instancemethod(_mesh.DynamicMeshEditor_close, None, DynamicMeshEditor)
DynamicMeshEditor_swigregister = _mesh.DynamicMeshEditor_swigregister
DynamicMeshEditor_swigregister(DynamicMeshEditor)

class MeshColoring(object):
    """

    This class computes colorings for a local mesh. It supports
    vertex, edge, and facet-based colorings.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def color_cells(mesh, coloring_type):
        """

        Color the cells of a mesh for given coloring type, which can
        be one of "vertex", "edge" or "facet". Coloring is saved in the
        mesh topology

        """
        return _mesh.MeshColoring_color_cells(mesh, coloring_type)

    color_cells = staticmethod(color_cells)

    def color(mesh, coloring_type):
        """

        Color the cells of a mesh for given coloring type specified by
        topological dimension, which can be one of 0, 1 or D - 1. Coloring
        is saved in the mesh topology

        """
        return _mesh.MeshColoring_color(mesh, coloring_type)

    color = staticmethod(color)

    def compute_colors(mesh, colors, coloring_type):
        """

        Compute cell colors for given coloring type specified by
        topological dimension, which can be one of 0, 1 or D - 1.

        """
        return _mesh.MeshColoring_compute_colors(mesh, colors, coloring_type)

    compute_colors = staticmethod(compute_colors)

    def cell_colors(*args):
        """

        **Overloaded versions**

        * cell_colors\ (mesh, coloring_type)

          Return a MeshFunction with the cell colors (used for visualisation)

        * cell_colors\ (mesh, coloring_type)

          Return a MeshFunction with the cell colors (used for visualisation)

        """
        return _mesh.MeshColoring_cell_colors(*args)

    cell_colors = staticmethod(cell_colors)

    def type_to_dim(coloring_type, mesh):
        """

        Convert coloring type to topological dimension

        """
        return _mesh.MeshColoring_type_to_dim(coloring_type, mesh)

    type_to_dim = staticmethod(type_to_dim)

    def __init__(self):
        _mesh.MeshColoring_swiginit(self, _mesh.new_MeshColoring())
    __swig_destroy__ = _mesh.delete_MeshColoring
MeshColoring_swigregister = _mesh.MeshColoring_swigregister
MeshColoring_swigregister(MeshColoring)

def MeshColoring_color_cells(mesh, coloring_type):
    """

    Color the cells of a mesh for given coloring type, which can
    be one of "vertex", "edge" or "facet". Coloring is saved in the
    mesh topology

    """
    return _mesh.MeshColoring_color_cells(mesh, coloring_type)

def MeshColoring_color(mesh, coloring_type):
    """

    Color the cells of a mesh for given coloring type specified by
    topological dimension, which can be one of 0, 1 or D - 1. Coloring
    is saved in the mesh topology

    """
    return _mesh.MeshColoring_color(mesh, coloring_type)

def MeshColoring_compute_colors(mesh, colors, coloring_type):
    """

    Compute cell colors for given coloring type specified by
    topological dimension, which can be one of 0, 1 or D - 1.

    """
    return _mesh.MeshColoring_compute_colors(mesh, colors, coloring_type)

def MeshColoring_cell_colors(*args):
    """

    **Overloaded versions**

    * cell_colors\ (mesh, coloring_type)

      Return a MeshFunction with the cell colors (used for visualisation)

    * cell_colors\ (mesh, coloring_type)

      Return a MeshFunction with the cell colors (used for visualisation)

    """
    return _mesh.MeshColoring_cell_colors(*args)

def MeshColoring_type_to_dim(coloring_type, mesh):
    """

    Convert coloring type to topological dimension

    """
    return _mesh.MeshColoring_type_to_dim(coloring_type, mesh)

class MeshRenumbering(object):
    """

    This class implements renumbering algorithms for meshes.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def renumber_by_color(mesh, coloring):
        """

        Renumber mesh entities by coloring. This function is currently
        restricted to renumbering by cell coloring. The cells
        (cell-vertex connectivity) and the coordinates of the mesh are
        renumbered to improve the locality within each color. It is
        assumed that the mesh has already been colored and that only
        cell-vertex connectivity exists as part of the mesh.

        *Arguments*
            mesh (:py:class:`Mesh`)
                Mesh to be renumbered.
            coloring (numpy.array(int))
                Mesh coloring type.
        *Returns*
            :py:class:`Mesh`

        """
        return _mesh.MeshRenumbering_renumber_by_color(mesh, coloring)

    renumber_by_color = staticmethod(renumber_by_color)

    def __init__(self):
        _mesh.MeshRenumbering_swiginit(self, _mesh.new_MeshRenumbering())
    __swig_destroy__ = _mesh.delete_MeshRenumbering
MeshRenumbering_swigregister = _mesh.MeshRenumbering_swigregister
MeshRenumbering_swigregister(MeshRenumbering)

def MeshRenumbering_renumber_by_color(mesh, coloring):
    """

    Renumber mesh entities by coloring. This function is currently
    restricted to renumbering by cell coloring. The cells
    (cell-vertex connectivity) and the coordinates of the mesh are
    renumbered to improve the locality within each color. It is
    assumed that the mesh has already been colored and that only
    cell-vertex connectivity exists as part of the mesh.

    *Arguments*
        mesh (:py:class:`Mesh`)
            Mesh to be renumbered.
        coloring (numpy.array(int))
            Mesh coloring type.
    *Returns*
        :py:class:`Mesh`

    """
    return _mesh.MeshRenumbering_renumber_by_color(mesh, coloring)

class MeshTransformation(object):
    """

    This class implements various transformations of the coordinates
    of a mesh.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def translate(mesh, point):
        """

        Translate mesh according to a given vector.

        *Arguments*
            mesh (:py:class:`Mesh`)
                The mesh
            point (Point)
                The vector defining the translation.

        """
        return _mesh.MeshTransformation_translate(mesh, point)

    translate = staticmethod(translate)

    def rotate(*args):
        """

        **Overloaded versions**

        * rotate\ (mesh, angle, axis)

          Rotate mesh around a coordinate axis through center of mass
          of all mesh vertices

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh.
              angle (float)
                  The number of degrees (0-360) of rotation.
              axis (int)
                  The coordinate axis around which to rotate the mesh.

        * rotate\ (mesh, angle, axis, p)

          Rotate mesh around a coordinate axis through a given point

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh.
              angle (float)
                  The number of degrees (0-360) of rotation.
              axis (int)
                  The coordinate axis around which to rotate the mesh.
              point (:py:class:`Point`)
                  The point around which to rotate the mesh.

        """
        return _mesh.MeshTransformation_rotate(*args)

    rotate = staticmethod(rotate)

    def __init__(self):
        _mesh.MeshTransformation_swiginit(self, _mesh.new_MeshTransformation())
    __swig_destroy__ = _mesh.delete_MeshTransformation
MeshTransformation_swigregister = _mesh.MeshTransformation_swigregister
MeshTransformation_swigregister(MeshTransformation)

def MeshTransformation_translate(mesh, point):
    """

    Translate mesh according to a given vector.

    *Arguments*
        mesh (:py:class:`Mesh`)
            The mesh
        point (Point)
            The vector defining the translation.

    """
    return _mesh.MeshTransformation_translate(mesh, point)

def MeshTransformation_rotate(*args):
    """

    **Overloaded versions**

    * rotate\ (mesh, angle, axis)

      Rotate mesh around a coordinate axis through center of mass
      of all mesh vertices

      *Arguments*
          mesh (:py:class:`Mesh`)
              The mesh.
          angle (float)
              The number of degrees (0-360) of rotation.
          axis (int)
              The coordinate axis around which to rotate the mesh.

    * rotate\ (mesh, angle, axis, p)

      Rotate mesh around a coordinate axis through a given point

      *Arguments*
          mesh (:py:class:`Mesh`)
              The mesh.
          angle (float)
              The number of degrees (0-360) of rotation.
          axis (int)
              The coordinate axis around which to rotate the mesh.
          point (:py:class:`Point`)
              The point around which to rotate the mesh.

    """
    return _mesh.MeshTransformation_rotate(*args)

class LocalMeshData(common.Variable):
    """

    This class stores mesh data on a local processor corresponding
    to a portion of a (larger) global mesh.

    Note that the data stored in this class does typically not
    correspond to a topologically connected mesh; it merely stores a
    list of vertex coordinates, a list of cell-vertex mappings and a
    list of global vertex numbers for the locally stored vertices.

    It is typically used for parsing meshes in parallel from mesh
    XML files. After local mesh data has been parsed on each
    processor, a subsequent repartitioning takes place: first a
    geometric partitioning of the vertices followed by a
    redistribution of vertex and cell data, and then a topological
    partitioning again followed by redistribution of vertex and cell
    data, at that point corresponding to topologically connected
    meshes instead of local mesh data.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * LocalMeshData\ (mpi_comm)

          Create empty local mesh data

        * LocalMeshData\ (mesh)

          Create local mesh data for given mesh

        """
        _mesh.LocalMeshData_swiginit(self, _mesh.new_LocalMeshData(*args))
    __swig_destroy__ = _mesh.delete_LocalMeshData
    vertex_coordinates = _swig_property(_mesh.LocalMeshData_vertex_coordinates_get, _mesh.LocalMeshData_vertex_coordinates_set)
    vertex_indices = _swig_property(_mesh.LocalMeshData_vertex_indices_get, _mesh.LocalMeshData_vertex_indices_set)
    cell_vertices = _swig_property(_mesh.LocalMeshData_cell_vertices_get, _mesh.LocalMeshData_cell_vertices_set)
    global_cell_indices = _swig_property(_mesh.LocalMeshData_global_cell_indices_get, _mesh.LocalMeshData_global_cell_indices_set)
    cell_partition = _swig_property(_mesh.LocalMeshData_cell_partition_get, _mesh.LocalMeshData_cell_partition_set)
    cell_weight = _swig_property(_mesh.LocalMeshData_cell_weight_get, _mesh.LocalMeshData_cell_weight_set)
    num_global_vertices = _swig_property(_mesh.LocalMeshData_num_global_vertices_get, _mesh.LocalMeshData_num_global_vertices_set)
    num_global_cells = _swig_property(_mesh.LocalMeshData_num_global_cells_get, _mesh.LocalMeshData_num_global_cells_set)
    num_vertices_per_cell = _swig_property(_mesh.LocalMeshData_num_vertices_per_cell_get, _mesh.LocalMeshData_num_vertices_per_cell_set)
    gdim = _swig_property(_mesh.LocalMeshData_gdim_get, _mesh.LocalMeshData_gdim_set)
    tdim = _swig_property(_mesh.LocalMeshData_tdim_get, _mesh.LocalMeshData_tdim_set)
    cell_type = _swig_property(_mesh.LocalMeshData_cell_type_get, _mesh.LocalMeshData_cell_type_set)
    domain_data = _swig_property(_mesh.LocalMeshData_domain_data_get, _mesh.LocalMeshData_domain_data_set)
LocalMeshData.clear = new_instancemethod(_mesh.LocalMeshData_clear, None, LocalMeshData)
LocalMeshData.extract_mesh_data = new_instancemethod(_mesh.LocalMeshData_extract_mesh_data, None, LocalMeshData)
LocalMeshData.broadcast_mesh_data = new_instancemethod(_mesh.LocalMeshData_broadcast_mesh_data, None, LocalMeshData)
LocalMeshData.receive_mesh_data = new_instancemethod(_mesh.LocalMeshData_receive_mesh_data, None, LocalMeshData)
LocalMeshData.unpack_vertex_coordinates = new_instancemethod(_mesh.LocalMeshData_unpack_vertex_coordinates, None, LocalMeshData)
LocalMeshData.unpack_cell_vertices = new_instancemethod(_mesh.LocalMeshData_unpack_cell_vertices, None, LocalMeshData)
LocalMeshData.mpi_comm = new_instancemethod(_mesh.LocalMeshData_mpi_comm, None, LocalMeshData)
LocalMeshData_swigregister = _mesh.LocalMeshData_swigregister
LocalMeshData_swigregister(LocalMeshData)

class SubDomain(object):
    """

    This class defines the interface for definition of subdomains.
    Alternatively, subdomains may be defined by a :py:class:`Mesh` and a
    :py:class:`MeshFunction` <std::size_t> over the mesh.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, map_tol=1.0e-10):
        """

        Constructor

        *Arguments*
            map_tol (float)
                The tolerance used when identifying mapped points using
                the function SubDomain::map.

        """
        if self.__class__ == SubDomain:
            _self = None
        else:
            _self = self
        _mesh.SubDomain_swiginit(self, _mesh.new_SubDomain(_self, map_tol))
    __swig_destroy__ = _mesh.delete_SubDomain

    def inside(self, x, on_boundary):
        """

        Return true for points inside the subdomain

        *Arguments*
            x (numpy.array(float))
                The coordinates of the point.
            on_boundary (bool)
                True for points on the boundary.

        *Returns*
            bool
                True for points inside the subdomain.

        """
        return _mesh.SubDomain_inside(self, x, on_boundary)


    def map(self, x, y):
        """

        Map coordinate x in domain H to coordinate y in domain G (used for
        periodic boundary conditions)

        *Arguments*
            x (numpy.array(float))
                The coordinates in domain H.
            y (numpy.array(float))
                The coordinates in domain G.

        """
        return _mesh.SubDomain_map(self, x, y)


    def snap(self, x):
        """

        Snap coordinate to boundary of subdomain

        *Arguments*
            x (numpy.array(float))
                The coordinates.

        """
        return _mesh.SubDomain_snap(self, x)


    def mark_cells(self, mesh, sub_domain, check_midpoint=True):
        """

        Set subdomain markers (std::size_t) on cells for given subdomain number

        *Arguments*
            mesh (:py:class:`Mesh`)
                The mesh to be marked.
            sub_domain (int)
                The subdomain number.
            check_midpoint (bool)
                Flag for whether midpoint of cell should be checked (default).

        """
        return _mesh.SubDomain_mark_cells(self, mesh, sub_domain, check_midpoint)


    def mark_facets(self, mesh, sub_domain, check_midpoint=True):
        """

        Set subdomain markers (std::size_t) on facets for given subdomain number

        *Arguments*
            mesh (:py:class:`Mesh`)
                The mesh to be marked.
            sub_domain (int)
                The subdomain number.
            check_midpoint (bool)
                Flag for whether midpoint of cell should be checked (default).

        """
        return _mesh.SubDomain_mark_facets(self, mesh, sub_domain, check_midpoint)


    def _mark(self, *args):
        """

        **Overloaded versions**

        * mark\ (mesh, dim, sub_domain, check_midpoint=true)

          Set subdomain markers (std::size_t) for given topological dimension
          and subdomain number

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to be marked.
              dim (int)
                  The topological dimension of entities to be marked.
              sub_domain (int)
                  The subdomain number.
              check_midpoint (bool)
                  Flag for whether midpoint of cell should be checked (default).

        * mark\ (sub_domains, sub_domain, check_midpoint=true)

          Set subdomain markers (std::size_t) for given subdomain number

          *Arguments*
              sub_domains (:py:class:`MeshFunction`)
                  The subdomain markers.
              sub_domain (int)
                  The subdomain number.
              check_midpoint (bool)
                  Flag for whether midpoint of cell should be checked (default).

        * mark\ (sub_domains, sub_domain, check_midpoint=true)

          Set subdomain markers (int) for given subdomain number

          *Arguments*
              sub_domains (:py:class:`MeshFunction`)
                  The subdomain markers.
              sub_domain (int)
                  The subdomain number.
              check_midpoint (bool)
                  Flag for whether midpoint of cell should be checked (default).

        * mark\ (sub_domains, sub_domain, check_midpoint=true)

          Set subdomain markers (double) for given subdomain number

          *Arguments*
              sub_domains (:py:class:`MeshFunction`)
                  The subdomain markers.
              sub_domain (float)
                  The subdomain number.
              check_midpoint (bool)
                  Flag for whether midpoint of cell should be checked (default).

        * mark\ (sub_domains, sub_domain, check_midpoint=true)

          Set subdomain markers (bool) for given subdomain

          *Arguments*
              sub_domains (:py:class:`MeshFunction`)
                  The subdomain markers.
              sub_domain (bool)
                  The subdomain number.
              check_midpoint (bool)
                  Flag for whether midpoint of cell should be checked (default).

        * mark\ (sub_domains, sub_domain, mesh, check_midpoint=true)

          Set subdomain markers (std::size_t) for given subdomain number

          *Arguments*
              sub_domains (:py:class:`MeshValueCollection`)
                  The subdomain markers.
              sub_domain (int)
                  The subdomain number.
              mesh (:py:class:`Mesh`)
                  The mesh.
              check_midpoint (bool)
                  Flag for whether midpoint of cell should be checked (default).

        * mark\ (sub_domains, sub_domain, mesh, check_midpoint=true)

          Set subdomain markers (int) for given subdomain number

          *Arguments*
              sub_domains (:py:class:`MeshValueCollection`)
                  The subdomain markers
              sub_domain (int)
                  The subdomain number
              check_midpoint (bool)
                  Flag for whether midpoint of cell should be checked (default).

        * mark\ (sub_domains, sub_domain, mesh, check_midpoint=true)

          Set subdomain markers (double) for given subdomain number

          *Arguments*
              sub_domains (:py:class:`MeshValueCollection`)
                  The subdomain markers.
              sub_domain (float)
                  The subdomain number
              check_midpoint (bool)
                  Flag for whether midpoint of cell should be checked (default).

        * mark\ (sub_domains, sub_domain, mesh, check_midpoint=true)

          Set subdomain markers (bool) for given subdomain

          *Arguments*
              sub_domains (:py:class:`MeshValueCollection`)
                  The subdomain markers
              sub_domain (bool)
                  The subdomain number
              check_midpoint (bool)
                  Flag for whether midpoint of cell should be checked (default).

        """
        return _mesh.SubDomain__mark(self, *args)


    def geometric_dimension(self):
        """

        Return geometric dimension

        *Returns*
            int
                The geometric dimension.

        """
        return _mesh.SubDomain_geometric_dimension(self)

    map_tolerance = _swig_property(_mesh.SubDomain_map_tolerance_get)

    # NOTE: This is a hardcoded check, which rely on SubDomain::mark only taking
    # a MeshFunction as its first argument when mark is called with two arguments
    def mark(self, *args, **kwargs):
        from . import common
        if len(args) == 2 and not isinstance(args[0], \
                        (MeshFunctionSizet, MeshFunctionInt,
                         MeshFunctionDouble, MeshFunctionBool)):
            common.dolfin_error("dolfin.cpp.mesh.py",
                                "mark MeshFunction",
                                "Expected a MeshFunction of type \"size_t\", \"int\", \"double\" or \"bool\"")

        if ("check_midpoint" in kwargs):
            args = args + (kwargs["check_midpoint"],)
        self._mark(*args)

    def __disown__(self):
        self.this.disown()
        _mesh.disown_SubDomain(self)
        return weakref_proxy(self)
SubDomain.inside = new_instancemethod(_mesh.SubDomain_inside, None, SubDomain)
SubDomain.map = new_instancemethod(_mesh.SubDomain_map, None, SubDomain)
SubDomain.snap = new_instancemethod(_mesh.SubDomain_snap, None, SubDomain)
SubDomain.mark_cells = new_instancemethod(_mesh.SubDomain_mark_cells, None, SubDomain)
SubDomain.mark_facets = new_instancemethod(_mesh.SubDomain_mark_facets, None, SubDomain)
SubDomain._mark = new_instancemethod(_mesh.SubDomain__mark, None, SubDomain)
SubDomain.geometric_dimension = new_instancemethod(_mesh.SubDomain_geometric_dimension, None, SubDomain)
SubDomain_swigregister = _mesh.SubDomain_swigregister
SubDomain_swigregister(SubDomain)

class SubMesh(Mesh):
    """

    A SubMesh is a mesh defined as a subset of a given mesh. It
    provides a convenient way to create matching meshes for
    multiphysics applications by creating meshes for subdomains as
    subsets of a single global mesh. A mapping from the vertices of
    the sub mesh to the vertices of the parent mesh is stored as the
    mesh data named "parent_vertex_indices".

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * SubMesh\ (mesh, sub_domain)

          Create subset of given mesh marked by sub domain

        * SubMesh\ (mesh, sub_domains, sub_domain)

          Create subset of given mesh marked by mesh function

        * SubMesh\ (mesh, sub_domain)

          Create subset of given mesh from stored MeshValueCollection

        """
        _mesh.SubMesh_swiginit(self, _mesh.new_SubMesh(*args))
    __swig_destroy__ = _mesh.delete_SubMesh

    def ufl_id(self):
        "Returns an id that UFL can use to decide if two objects are the same."
        return self.id()

    def ufl_cell(self):
        """
        Returns the ufl cell of the mesh.

        The cell corresponds to the topological dimension of the mesh.
        """
        import ufl
        tdim = self.topology().dim()
        gdim = self.geometry().dim()
        dim2domain = { 1: 'interval', 2: 'triangle', 3: 'tetrahedron' }
        cellname = dim2domain[tdim]
        return ufl.Cell(cellname, geometric_dimension=gdim)

    def ufl_domain(self):
        """Returns the ufl Domain corresponding to the mesh."""
        import ufl
        label = "dolfin_mesh_with_id_%d" % self.id()
        return ufl.Domain(self.ufl_cell(), label=label, data=self)

SubMesh_swigregister = _mesh.SubMesh_swigregister
SubMesh_swigregister(SubMesh)

class Restriction(object):
    """

    This class represents a restriction of a mesh to a subdomain,
    which can be defined as a subset of all the cells, the facets,
    or possibly lower dimensional entities of the mesh.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * Restriction\ (mesh, sub_domain)

          Create cell-based restriction from subdomain

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh
              sub_domain (:py:class:`SubDomain`)
                  Sub domain defining the restriction

        * Restriction\ (mesh, sub_domain, dim)

          Create restriction from subdomain to entities of arbitrary dimension

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh
              sub_domain (:py:class:`SubDomain`)
                  Sub domain defining the restriction
              dim (int)
                  Dimension of restriction

        * Restriction\ (domain_markers, domain_number)

          Create restriction from domain markers

          *Arguments*
              domain_markers (:py:class:`MeshFunction`)
                  Domain markers for the cells of the mesh.
              domain_number (int)
                  Identifier for domain.

        * Restriction\ (domain_markers, domain_number)

          Create restriction from domain markers (shared pointer version)

          *Arguments*
              domain_markers (:py:class:`MeshFunction`)
                  Domain markers for the cells of the mesh.
              domain_number (int)
                  Identifier for domain.

        """
        _mesh.Restriction_swiginit(self, _mesh.new_Restriction(*args))

    def mesh(self):
        """

        Return the full unrestricted mesh

        """
        return _mesh.Restriction_mesh(self)


    def dim(self):
        """

        Return topological dimension of restriction

        """
        return _mesh.Restriction_dim(self)


    def contains(self, *args):
        """

        **Overloaded versions**

        * contains\ (entity)

          Check whether restriction contains entity

        * contains\ (d, i)

          Check whether restriction contains entity (d, i)

        """
        return _mesh.Restriction_contains(self, *args)

    __swig_destroy__ = _mesh.delete_Restriction
Restriction.mesh = new_instancemethod(_mesh.Restriction_mesh, None, Restriction)
Restriction.dim = new_instancemethod(_mesh.Restriction_dim, None, Restriction)
Restriction.contains = new_instancemethod(_mesh.Restriction_contains, None, Restriction)
Restriction_swigregister = _mesh.Restriction_swigregister
Restriction_swigregister(Restriction)

class DomainBoundary(SubDomain):
    """

    This class provides a SubDomain which picks out the boundary of
    a mesh, and provides a convenient way to specify boundary
    conditions on the entire boundary of a mesh.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """

        Constructor

        """
        _mesh.DomainBoundary_swiginit(self, _mesh.new_DomainBoundary())
    __swig_destroy__ = _mesh.delete_DomainBoundary
DomainBoundary_swigregister = _mesh.DomainBoundary_swigregister
DomainBoundary_swigregister(DomainBoundary)

class BoundaryMesh(Mesh):
    """

    A BoundaryMesh is a mesh over the boundary of some given mesh.
    The cells of the boundary mesh (facets of the original mesh) are
    oriented to produce outward pointing normals relative to the
    original mesh.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, mesh, type, order=True):
        """

        Create boundary mesh from given mesh.

        *Arguments*
            mesh (:py:class:`Mesh`)
                Another :py:class:`Mesh` object.
            type (_std::string_)
                The type of BoundaryMesh, which can be "exterior",
                "interior" or "local". "exterior" is the globally
                external boundary, "interior" is the inter-process mesh
                and "local" is the boundary of the local (this process)
                mesh.
            order (bool)
                Optional argument which can be used to control whether
                or not the boundary mesh should be ordered according
                to the UFC ordering convention. If set to false, the
                boundary mesh will be ordered with right-oriented
                facets (outward-pointing unit normals). The default
                value is true.

        """
        _mesh.BoundaryMesh_swiginit(self, _mesh.new_BoundaryMesh(mesh, type, order))
    __swig_destroy__ = _mesh.delete_BoundaryMesh

    def entity_map(self, *args):
        """

        **Overloaded versions**

        * entity_map\ (d)

          Get index map for entities of dimension d in the boundary mesh
          to the entity in the original full mesh

        * entity_map\ (d)

          Get index map for entities of dimension d in the boundary mesh
          to the entity in the original full mesh (const version)

        """
        return _mesh.BoundaryMesh_entity_map(self, *args)

BoundaryMesh.entity_map = new_instancemethod(_mesh.BoundaryMesh_entity_map, None, BoundaryMesh)
BoundaryMesh_swigregister = _mesh.BoundaryMesh_swigregister
BoundaryMesh_swigregister(BoundaryMesh)

class PeriodicBoundaryComputation(object):
    """

    This class computes map from slave entity to master entity

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def compute_periodic_pairs(mesh, sub_domain, dim):
        """

        For entities of dimension dim, compute map from a slave entity
        on this process (local index) to its master entity (owning
        process, local index on owner). If a master entity is shared
        by processes, only one of the owning processes is returned.

        """
        return _mesh.PeriodicBoundaryComputation_compute_periodic_pairs(mesh, sub_domain, dim)

    compute_periodic_pairs = staticmethod(compute_periodic_pairs)

    def masters_slaves(mesh, sub_domain, dim):
        """

        This function returns a MeshFunction which marks mesh entities
        of dimension dim according to:

            2: slave entities
            1: master entities
            0: all other entities

        It is useful for visualising and debugging the Expression::map
        function that is used to apply periodic boundary conditions.

        """
        return _mesh.PeriodicBoundaryComputation_masters_slaves(mesh, sub_domain, dim)

    masters_slaves = staticmethod(masters_slaves)

    def __init__(self):
        _mesh.PeriodicBoundaryComputation_swiginit(self, _mesh.new_PeriodicBoundaryComputation())
    __swig_destroy__ = _mesh.delete_PeriodicBoundaryComputation
PeriodicBoundaryComputation_swigregister = _mesh.PeriodicBoundaryComputation_swigregister
PeriodicBoundaryComputation_swigregister(PeriodicBoundaryComputation)

def PeriodicBoundaryComputation_compute_periodic_pairs(mesh, sub_domain, dim):
    """

    For entities of dimension dim, compute map from a slave entity
    on this process (local index) to its master entity (owning
    process, local index on owner). If a master entity is shared
    by processes, only one of the owning processes is returned.

    """
    return _mesh.PeriodicBoundaryComputation_compute_periodic_pairs(mesh, sub_domain, dim)

def PeriodicBoundaryComputation_masters_slaves(mesh, sub_domain, dim):
    """

    This function returns a MeshFunction which marks mesh entities
    of dimension dim according to:

        2: slave entities
        1: master entities
        0: all other entities

    It is useful for visualising and debugging the Expression::map
    function that is used to apply periodic boundary conditions.

    """
    return _mesh.PeriodicBoundaryComputation_masters_slaves(mesh, sub_domain, dim)

class MeshQuality(object):
    """

    The class provides functions to quantify mesh quality

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def radius_ratios(mesh):
        """

        Compute the radius ratio for all cells.

        *Returns*
            CellFunction<double>
                The cell radius ratio radius ratio geometric_dimension *
                * inradius / circumradius (geometric_dimension
                is normalization factor). It has range zero to one.
                Zero indicates a degenerate element.

        *Example*
            .. note::

                No example code available for this function.

        """
        return _mesh.MeshQuality_radius_ratios(mesh)

    radius_ratios = staticmethod(radius_ratios)

    def radius_ratio_min_max(mesh):
        """

        Compute the minimum and maximum radius ratio of cells
        (across all processes)

        *Returns*
            (float, float)
                The [minimum, maximum] cell radii ratio (geometric_dimension *
                * inradius / circumradius, geometric_dimension
                is normalization factor). It has range zero to one.
                Zero indicates a degenerate element.

        *Example*
            .. note::

                No example code available for this function.

        """
        return _mesh.MeshQuality_radius_ratio_min_max(mesh)

    radius_ratio_min_max = staticmethod(radius_ratio_min_max)

    def radius_ratio_histogram_data(mesh, num_intervals=50):
        """

        Create (ratio, number of cells) data for creating a histogram
        of cell quality

        """
        return _mesh.MeshQuality_radius_ratio_histogram_data(mesh, num_intervals)

    radius_ratio_histogram_data = staticmethod(radius_ratio_histogram_data)

    def radius_ratio_matplotlib_histogram(mesh, num_bins=50):
        """

        Create Matplotlib string to plot cell quality histogram

        """
        return _mesh.MeshQuality_radius_ratio_matplotlib_histogram(mesh, num_bins)

    radius_ratio_matplotlib_histogram = staticmethod(radius_ratio_matplotlib_histogram)

    def __init__(self):
        _mesh.MeshQuality_swiginit(self, _mesh.new_MeshQuality())
    __swig_destroy__ = _mesh.delete_MeshQuality
MeshQuality_swigregister = _mesh.MeshQuality_swigregister
MeshQuality_swigregister(MeshQuality)

def MeshQuality_radius_ratios(mesh):
    """

    Compute the radius ratio for all cells.

    *Returns*
        CellFunction<double>
            The cell radius ratio radius ratio geometric_dimension *
            * inradius / circumradius (geometric_dimension
            is normalization factor). It has range zero to one.
            Zero indicates a degenerate element.

    *Example*
        .. note::

            No example code available for this function.

    """
    return _mesh.MeshQuality_radius_ratios(mesh)

def MeshQuality_radius_ratio_min_max(mesh):
    """

    Compute the minimum and maximum radius ratio of cells
    (across all processes)

    *Returns*
        (float, float)
            The [minimum, maximum] cell radii ratio (geometric_dimension *
            * inradius / circumradius, geometric_dimension
            is normalization factor). It has range zero to one.
            Zero indicates a degenerate element.

    *Example*
        .. note::

            No example code available for this function.

    """
    return _mesh.MeshQuality_radius_ratio_min_max(mesh)

def MeshQuality_radius_ratio_histogram_data(mesh, num_intervals=50):
    """

    Create (ratio, number of cells) data for creating a histogram
    of cell quality

    """
    return _mesh.MeshQuality_radius_ratio_histogram_data(mesh, num_intervals)

def MeshQuality_radius_ratio_matplotlib_histogram(mesh, num_bins=50):
    """

    Create Matplotlib string to plot cell quality histogram

    """
    return _mesh.MeshQuality_radius_ratio_matplotlib_histogram(mesh, num_bins)

class MultiMesh(common.Variable):
    """

    This class represents a collection of meshes with arbitrary
    overlaps. A multimesh may be created from a set of standard
    meshes spaces by repeatedly calling add(), followed by a call to
    build(). Note that a multimesh is not useful until build() has
    been called.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """

        Create empty multimesh

        """
        _mesh.MultiMesh_swiginit(self, _mesh.new_MultiMesh())
    __swig_destroy__ = _mesh.delete_MultiMesh

    def num_parts(self):
        """

        Return the number of meshes (parts) of the multimesh

        *Returns*
            int
                The number of meshes (parts) of the multimesh.

        """
        return _mesh.MultiMesh_num_parts(self)


    def part(self, i):
        """

        Return mesh (part) number i

        *Arguments*
            i (int)
                The part number

        *Returns*
            :py:class:`Mesh`
                Mesh (part) number i

        """
        return _mesh.MultiMesh_part(self, i)


    def uncut_cells(self, part):
        """

        Return the list of uncut cells for given part. The uncut cells
        are defined as all cells that don't collide with any cells in
        any other part with higher part number.

        *Arguments*
            part (int)
                The part number

        *Returns*
            numpy.array(int)
                List of uncut cell indices for given part

        """
        return _mesh.MultiMesh_uncut_cells(self, part)


    def cut_cells(self, part):
        """

        Return the list of cut cells for given part. The cut cells are
        defined as all cells that collide with the boundary of any
        part with higher part number.

        FIXME: Figure out whether this makes sense; a cell may collide
        with the boundary of part j but may still be covered
        completely by the domain of part j + 1. Possible solution is
        to for each part i check overlapping parts starting from the
        top and working back down to i + 1.

        *Arguments*
            part (int)
                The part number

        *Returns*
            numpy.array(int)
                List of cut cell indices for given part

        """
        return _mesh.MultiMesh_cut_cells(self, part)


    def covered_cells(self, part):
        """

        Return the list of covered cells for given part. The covered
        cells are defined as all cells that collide with the domain of
        any part with higher part number, but not with the boundary of
        that part; in other words cells that are completely covered by
        any other part (and which therefore are inactive).

        *Arguments*
            part (int)
                The part number

        *Returns*
            numpy.array(int)
                List of covered cell indices for given part

        """
        return _mesh.MultiMesh_covered_cells(self, part)


    def collision_map_cut_cells(self, part):
        """

        Return the collision map for cut cells of the given part

        *Arguments*
            part (int)
                The part number

        *Returns*
            std::map<unsigned int, std::vector<std::pair<std::size_t, unsigned int> > >
                A map from cell indices of cut cells to a list of
                cutting cells. Each cutting cell is represented as a
                pair (part_number, cutting_cell_index).

        """
        return _mesh.MultiMesh_collision_map_cut_cells(self, part)


    def quadrature_rule_cut_cells(self, part):
        """

        Return quadrature rules for cut cells on the given part

        *Arguments*
            part (int)
                The part number

        *Returns*
            std::map<unsigned int, std::pair<std::vector<double>, std::vector<double> > >
                A map from cell indices of cut cells to quadrature
                rules. Each quadrature rule is represented as a pair
                of a flattened array of quadrature points and a
                corresponding array of quadrature weights.

        """
        return _mesh.MultiMesh_quadrature_rule_cut_cells(self, part)


    def quadrature_rule_cut_cell(self, part, cell_index):
        """

        Return quadrature rule for a given cut cell on the given part

        *Arguments*
            part (int)
                The part number
            cell (int)
                The cell index

        *Returns*
            std::pair<std::vector<double>, std::vector<double> >
                A quadrature rule represented as a pair of a flattened
                array of quadrature points and a corresponding array
                of quadrature weights. An error is raised if the given
                cell is not in the map.

        Developer note: this function is mainly useful from Python and
        could be replaced by a suitable typemap that would make the
        previous more general function accessible from Python.

        """
        return _mesh.MultiMesh_quadrature_rule_cut_cell(self, part, cell_index)


    def quadrature_rule_overlap(self, part):
        """

        Return quadrature rules for the overlap on the given part.

        *Arguments*
            part (int)
                The part number

        *Returns*
            std::map<unsigned int, std::pair<std::vector<double>, std::vector<double> > >
                A map from cell indices of cut cells to quadrature
                rules.  A separate quadrature rule is given for each
                cutting cell and stored in the same order as in the
                collision map. Each quadrature rule is represented as
                a pair of an array of quadrature points and a
                corresponding flattened array of quadrature weights.

        """
        return _mesh.MultiMesh_quadrature_rule_overlap(self, part)


    def quadrature_rule_interface(self, part):
        """

        Return quadrature rules for the interface on the given part

        *Arguments*
            part (int)
                The part number

        *Returns*
            std::map<unsigned int, std::pair<std::vector<double>, std::vector<double> > >
                A map from cell indices of cut cells to quadrature
                rules on an interface part cutting through the cell.
                A separate quadrature rule is given for each cutting
                cell and stored in the same order as in the collision
                map. Each quadrature rule is represented as a pair of
                an array of quadrature points and a corresponding
                flattened array of quadrature weights.

        """
        return _mesh.MultiMesh_quadrature_rule_interface(self, part)


    def facet_normals(self, part):
        """

        Return facet normals for the interface on the given part

        *Arguments*
            part (int)
                The part number

        *Returns*
            std::map<unsigned int, std::vector<std::vector<double> > >
                A map from cell indices of cut cells to facet normals
                on an interface part cutting through the cell. A
                separate list of facet normals, one for each
                quadrature point, is given for each cutting cell and
                stored in the same order as in the collision map. The
                facet normals for each set of quadrature points is
                stored as a contiguous flattened array, the length of
                which should be equal to the number of quadrature
                points multiplied by the geometric dimension. Puh!

        """
        return _mesh.MultiMesh_facet_normals(self, part)


    def bounding_box_tree(self, part):
        """

        Return the bounding box tree for the mesh of the given part

        *Arguments*
            part (int)
                The part number

        *Returns*
            std::shared_ptr<const BoundingBoxTree>
                The bounding box tree

        """
        return _mesh.MultiMesh_bounding_box_tree(self, part)


    def bounding_box_tree_boundary(self, part):
        """

        Return the bounding box tree for the boundary mesh of the
        given part

        *Arguments*
            part (int)
                The part number

        *Returns*
            std::shared_ptr<const BoundingBoxTree>
                The bounding box tree

        """
        return _mesh.MultiMesh_bounding_box_tree_boundary(self, part)


    def add(self, *args):
        """

        **Overloaded versions**

        * add\ (mesh)

          Add mesh (shared pointer version)

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh

        * add\ (mesh)

          Add mesh (reference version)

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh

        """
        return _mesh.MultiMesh_add(self, *args)


    def build(self):
        """

        Build multimesh

        """
        return _mesh.MultiMesh_build(self)


    def clear(self):
        """

        Clear multimesh

        """
        return _mesh.MultiMesh_clear(self)


    def default_parameters():
        """

        Default parameter values

        """
        return _mesh.MultiMesh_default_parameters()

    default_parameters = staticmethod(default_parameters)
MultiMesh.num_parts = new_instancemethod(_mesh.MultiMesh_num_parts, None, MultiMesh)
MultiMesh.part = new_instancemethod(_mesh.MultiMesh_part, None, MultiMesh)
MultiMesh.uncut_cells = new_instancemethod(_mesh.MultiMesh_uncut_cells, None, MultiMesh)
MultiMesh.cut_cells = new_instancemethod(_mesh.MultiMesh_cut_cells, None, MultiMesh)
MultiMesh.covered_cells = new_instancemethod(_mesh.MultiMesh_covered_cells, None, MultiMesh)
MultiMesh.collision_map_cut_cells = new_instancemethod(_mesh.MultiMesh_collision_map_cut_cells, None, MultiMesh)
MultiMesh.quadrature_rule_cut_cells = new_instancemethod(_mesh.MultiMesh_quadrature_rule_cut_cells, None, MultiMesh)
MultiMesh.quadrature_rule_cut_cell = new_instancemethod(_mesh.MultiMesh_quadrature_rule_cut_cell, None, MultiMesh)
MultiMesh.quadrature_rule_overlap = new_instancemethod(_mesh.MultiMesh_quadrature_rule_overlap, None, MultiMesh)
MultiMesh.quadrature_rule_interface = new_instancemethod(_mesh.MultiMesh_quadrature_rule_interface, None, MultiMesh)
MultiMesh.facet_normals = new_instancemethod(_mesh.MultiMesh_facet_normals, None, MultiMesh)
MultiMesh.bounding_box_tree = new_instancemethod(_mesh.MultiMesh_bounding_box_tree, None, MultiMesh)
MultiMesh.bounding_box_tree_boundary = new_instancemethod(_mesh.MultiMesh_bounding_box_tree_boundary, None, MultiMesh)
MultiMesh.add = new_instancemethod(_mesh.MultiMesh_add, None, MultiMesh)
MultiMesh.build = new_instancemethod(_mesh.MultiMesh_build, None, MultiMesh)
MultiMesh.clear = new_instancemethod(_mesh.MultiMesh_clear, None, MultiMesh)
MultiMesh_swigregister = _mesh.MultiMesh_swigregister
MultiMesh_swigregister(MultiMesh)

def MultiMesh_default_parameters():
    """

    Default parameter values

    """
    return _mesh.MultiMesh_default_parameters()

class MeshHierarchy(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * MeshHierarchy\ ()

          Constructor

        * MeshHierarchy\ (mesh)

          Constructor with initial mesh

        """
        _mesh.MeshHierarchy_swiginit(self, _mesh.new_MeshHierarchy(*args))
    __swig_destroy__ = _mesh.delete_MeshHierarchy

    def size(self):
        """

        Number of meshes

        """
        return _mesh.MeshHierarchy_size(self)


    def finest(self):
        """

        Get the finest mesh of the MeshHierarchy

        """
        return _mesh.MeshHierarchy_finest(self)


    def coarsest(self):
        """

        Get the coarsest mesh of the MeshHierarchy

        """
        return _mesh.MeshHierarchy_coarsest(self)


    def refine(self, markers):
        """

        Refine finest mesh of existing hierarchy, creating a new hierarchy
        (level n -> n+1)

        """
        return _mesh.MeshHierarchy_refine(self, markers)


    def unrefine(self):
        """

        Unrefine by returning the previous MeshHierarchy
        (level n -> n-1)
        Returns NULL for a MeshHierarchy containing a single Mesh

        """
        return _mesh.MeshHierarchy_unrefine(self)


    def coarsen(self, markers):
        """

        Coarsen finest mesh by one level, based on markers (level n->n)

        """
        return _mesh.MeshHierarchy_coarsen(self, markers)


    def weight(self):
        """

        Calculate the number of cells on the finest Mesh
        which are descendents of each cell on the coarsest Mesh,
        returning a vector over the cells of the coarsest Mesh.

        """
        return _mesh.MeshHierarchy_weight(self)


    def rebalance(self):
        """

        Rebalance across processes

        """
        return _mesh.MeshHierarchy_rebalance(self)

MeshHierarchy.size = new_instancemethod(_mesh.MeshHierarchy_size, None, MeshHierarchy)
MeshHierarchy.finest = new_instancemethod(_mesh.MeshHierarchy_finest, None, MeshHierarchy)
MeshHierarchy.coarsest = new_instancemethod(_mesh.MeshHierarchy_coarsest, None, MeshHierarchy)
MeshHierarchy.refine = new_instancemethod(_mesh.MeshHierarchy_refine, None, MeshHierarchy)
MeshHierarchy.unrefine = new_instancemethod(_mesh.MeshHierarchy_unrefine, None, MeshHierarchy)
MeshHierarchy.coarsen = new_instancemethod(_mesh.MeshHierarchy_coarsen, None, MeshHierarchy)
MeshHierarchy.weight = new_instancemethod(_mesh.MeshHierarchy_weight, None, MeshHierarchy)
MeshHierarchy.rebalance = new_instancemethod(_mesh.MeshHierarchy_rebalance, None, MeshHierarchy)
MeshHierarchy.__getitem__ = new_instancemethod(_mesh.MeshHierarchy___getitem__, None, MeshHierarchy)
MeshHierarchy_swigregister = _mesh.MeshHierarchy_swigregister
MeshHierarchy_swigregister(MeshHierarchy)

class MeshPartitioning(object):
    """

    This class partitions and distributes a mesh based on
    partitioned local mesh data.The local mesh data will
    also be repartitioned and redistributed during the computation
    of the mesh partitioning.

    After partitioning, each process has a local mesh and some data
    that couples the meshes together.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def build_distributed_mesh(mesh):
        """

        **Overloaded versions**

        * build_distributed_mesh\ (mesh)

          Build a partitioned mesh based from a local mesh on process 0

        * build_distributed_mesh\ (mesh, cell_partition)

          Build a partitioned mesh based from a local mesh on process 0
          with supplied destination processes for each cell

        * build_distributed_mesh\ (mesh, data)

          Build a partitioned mesh from local mesh data that is
          distributed across processes

        """
        return _mesh.MeshPartitioning_build_distributed_mesh(mesh)

    build_distributed_mesh = staticmethod(build_distributed_mesh)

    def __init__(self):
        _mesh.MeshPartitioning_swiginit(self, _mesh.new_MeshPartitioning())
    __swig_destroy__ = _mesh.delete_MeshPartitioning
MeshPartitioning_swigregister = _mesh.MeshPartitioning_swigregister
MeshPartitioning_swigregister(MeshPartitioning)

def MeshPartitioning_build_distributed_mesh(mesh):
    """

    **Overloaded versions**

    * build_distributed_mesh\ (mesh)

      Build a partitioned mesh based from a local mesh on process 0

    * build_distributed_mesh\ (mesh, cell_partition)

      Build a partitioned mesh based from a local mesh on process 0
      with supplied destination processes for each cell

    * build_distributed_mesh\ (mesh, data)

      Build a partitioned mesh from local mesh data that is
      distributed across processes

    """
    return _mesh.MeshPartitioning_build_distributed_mesh(mesh)


_subdomain_mark_doc_string = SubDomain._mark.__doc__


import sys
if sys.version_info[0] > 2:
    SubDomain.mark.__doc__ = _subdomain_mark_doc_string
else:
    SubDomain.mark.__func__.__doc__ = _subdomain_mark_doc_string
del _subdomain_mark_doc_string

class MeshFunctionSizet(common.Variable, HierarchicalMeshFunctionSizet):
    """

    A MeshFunction is a function that can be evaluated at a set of
    mesh entities. A MeshFunction is discrete and is only defined
    at the set of mesh entities of a fixed topological dimension.
    A MeshFunction may for example be used to store a global
    numbering scheme for the entities of a (parallel) mesh, marking
    sub domains or boolean markers for mesh refinement.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * MeshFunction\ ()

          Create empty mesh function

        * MeshFunction\ (mesh)

          Create empty mesh function on given mesh

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.

        * MeshFunction\ (mesh)

          Create empty mesh function on given mesh (shared_ptr version)

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.

        * MeshFunction\ (mesh, dim)

          Create mesh function of given dimension on given mesh

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.
              dim (int)
                  The mesh entity dimension for the mesh function.

        * MeshFunction\ (mesh, dim)

          Create mesh function of given dimension on given mesh
          (shared_ptr version)

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.
              dim (int)
                  The mesh entity dimension for the mesh function.

        * MeshFunction\ (mesh, dim, value)

          Create mesh of given dimension on given mesh and initialize
          to a value

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.
              dim (int)
                  The mesh entity dimension.
              value (T)
                  The value.

        * MeshFunction\ (mesh, dim, value)

          Create mesh of given dimension on given mesh and initialize
          to a value (shared_ptr version)

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.
              dim (int)
                  The mesh entity dimension.
              value (T)
                  The value.

        * MeshFunction\ (mesh, filename)

          Create function from data file

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.
              filename (str)
                  The filename to create mesh function from.

        * MeshFunction\ (mesh, filename)

          Create function from data file (shared_ptr version)

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.
              filename (str)
                  The filename to create mesh function from.

        * MeshFunction\ (mesh, value_collection)

          Create function from a MeshValueCollecion

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.
              value_collection (:py:class:`MeshValueCollection`)
                  The mesh value collection for the mesh function data.

        * MeshFunction\ (mesh, value_collection)

          Create function from a MeshValueCollecion (shared_ptr version)

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.
              value_collection (:py:class:`MeshValueCollection`)
                  The mesh value collection for the mesh function data.

        * MeshFunction\ (mesh, dim, domains)

          Create function from MeshDomains

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.
              dim (int)
                  The dimension of the MeshFunction
              domains (:py:class:`MeshDomains`)
                  The domains from which to extract the domain markers

        * MeshFunction\ (f)

          Copy constructor

          *Arguments*
              f (:py:class:`MeshFunction`)
                  The object to be copied.

        """
        _mesh.MeshFunctionSizet_swiginit(self, _mesh.new_MeshFunctionSizet(*args))
    __swig_destroy__ = _mesh.delete_MeshFunctionSizet

    def mesh(self):
        """

        Return mesh associated with mesh function

        *Returns*
            :py:class:`Mesh`
                The mesh.

        """
        return _mesh.MeshFunctionSizet_mesh(self)


    def dim(self):
        """

        Return topological dimension

        *Returns*
            int
                The dimension.

        """
        return _mesh.MeshFunctionSizet_dim(self)


    def empty(self):
        """

        Return true if empty

        *Returns*
            bool
                True if empty.

        """
        return _mesh.MeshFunctionSizet_empty(self)


    def size(self):
        """

        Return size (number of entities)

        *Returns*
            int
                The size.

        """
        return _mesh.MeshFunctionSizet_size(self)


    def init(self, *args):
        """

        **Overloaded versions**

        * init\ (dim)

          Initialize mesh function for given topological dimension

          *Arguments*
              dim (int)
                  The dimension.

        * init\ (dim, size)

          Initialize mesh function for given topological dimension of
          given size

          *Arguments*
              dim (int)
                  The dimension.
              size (int)
                  The size.

        * init\ (mesh, dim)

          Initialize mesh function for given topological dimension

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh.
              dim (int)
                  The dimension.

        * init\ (mesh, dim)

          Initialize mesh function for given topological dimension
          (shared_ptr version)

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh.
              dim (int)
                  The dimension.

        * init\ (mesh, dim, size)

          Initialize mesh function for given topological dimension of
          given size

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh.
              dim (int)
                  The dimension.
              size (int)
                  The size.

        * init\ (mesh, dim, size)

          Initialize mesh function for given topological dimension of
          given size (shared_ptr version)

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh.
              dim (int)
                  The dimension.
              size (int)
                  The size.

        """
        return _mesh.MeshFunctionSizet_init(self, *args)


    def set_value(self, *args):
        """

        **Overloaded versions**

        * set_value\ (index, value)

          Set value at given index

          *Arguments*
              index (int)
                  The index.
              value (T)
                  The value.

        * set_value\ (index, value, mesh)

          Compatibility function for use in SubDomains

        """
        return _mesh.MeshFunctionSizet_set_value(self, *args)


    def set_values(self, values):
        """

        Set values

        *Arguments*
            values (std::vector<T>)
                The values.

        """
        return _mesh.MeshFunctionSizet_set_values(self, values)


    def set_all(self, value):
        """

        Set all values to given value

        *Arguments*
            value (T)
                The value to set all values to.

        """
        return _mesh.MeshFunctionSizet_set_all(self, value)


    def _getitem(self, *args):
        """Missing docstring"""
        return _mesh.MeshFunctionSizet__getitem(self, *args)


    def _setitem(self, *args):
        """Missing docstring"""
        return _mesh.MeshFunctionSizet__setitem(self, *args)


    def array(self):
        """
        Return a NumPy array view of the data
        """
        data = self._array()
        _attach_base_to_numpy_array(data, self)
        return data

    def __getitem__(self, index):
        if not isinstance(index, (int, MeshEntity)):
            raise TypeError("expected an int or a MeshEntity as index argument")

        if isinstance(index, MeshEntity):
            entity = index
            assert entity.mesh().id() == self.mesh().id(), "MeshEntity and MeshFunction do not share the same mesh"
            assert entity.dim() == self.dim(), "MeshEntity and MeshFunction do not share the same topological dimensions"

            index = entity.index()

        while index < 0:
            index += self.size()
        if index >= self.size():
            raise IndexError("index out of range")
        return self._getitem(index)

    def __setitem__(self, index, value):
        if not isinstance(index, (int, MeshEntity)):
            raise TypeError("expected an int or a MeshEntity as index argument")

        if isinstance(index, MeshEntity):
            entity = index
            assert entity.mesh().id() == self.mesh().id(), "MeshEntity and MeshFunction do not share the same mesh"
            assert entity.dim() == self.dim(), "MeshEntity and MeshFunction do not share the same topological dimensions"

            index = entity.index()

        while index < 0:
            index += self.size()
        if index >= self.size():
            raise IndexError("index out of range")
        self._setitem(index, value)

    def __len__(self):
        return self.size()

    def ufl_id(self):
        "Returns an id that UFL can use to decide if two objects are the same."
        return self.id()


MeshFunctionSizet.mesh = new_instancemethod(_mesh.MeshFunctionSizet_mesh, None, MeshFunctionSizet)
MeshFunctionSizet.dim = new_instancemethod(_mesh.MeshFunctionSizet_dim, None, MeshFunctionSizet)
MeshFunctionSizet.empty = new_instancemethod(_mesh.MeshFunctionSizet_empty, None, MeshFunctionSizet)
MeshFunctionSizet.size = new_instancemethod(_mesh.MeshFunctionSizet_size, None, MeshFunctionSizet)
MeshFunctionSizet.init = new_instancemethod(_mesh.MeshFunctionSizet_init, None, MeshFunctionSizet)
MeshFunctionSizet.set_value = new_instancemethod(_mesh.MeshFunctionSizet_set_value, None, MeshFunctionSizet)
MeshFunctionSizet.set_values = new_instancemethod(_mesh.MeshFunctionSizet_set_values, None, MeshFunctionSizet)
MeshFunctionSizet.set_all = new_instancemethod(_mesh.MeshFunctionSizet_set_all, None, MeshFunctionSizet)
MeshFunctionSizet._array = new_instancemethod(_mesh.MeshFunctionSizet__array, None, MeshFunctionSizet)
MeshFunctionSizet._getitem = new_instancemethod(_mesh.MeshFunctionSizet__getitem, None, MeshFunctionSizet)
MeshFunctionSizet._setitem = new_instancemethod(_mesh.MeshFunctionSizet__setitem, None, MeshFunctionSizet)
MeshFunctionSizet_swigregister = _mesh.MeshFunctionSizet_swigregister
MeshFunctionSizet_swigregister(MeshFunctionSizet)

class CellFunctionSizet(MeshFunctionSizet):
    """

    A CellFunction is a MeshFunction of topological codimension 0.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _mesh.CellFunctionSizet_swiginit(self, _mesh.new_CellFunctionSizet(*args))
    __swig_destroy__ = _mesh.delete_CellFunctionSizet
CellFunctionSizet_swigregister = _mesh.CellFunctionSizet_swigregister
CellFunctionSizet_swigregister(CellFunctionSizet)

class EdgeFunctionSizet(MeshFunctionSizet):
    """

    An EdgeFunction is a :py:class:`MeshFunction` of topological dimension 1.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _mesh.EdgeFunctionSizet_swiginit(self, _mesh.new_EdgeFunctionSizet(*args))
    __swig_destroy__ = _mesh.delete_EdgeFunctionSizet
EdgeFunctionSizet_swigregister = _mesh.EdgeFunctionSizet_swigregister
EdgeFunctionSizet_swigregister(EdgeFunctionSizet)

class FaceFunctionSizet(MeshFunctionSizet):
    """

    A FaceFunction is a MeshFunction of topological dimension 2.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _mesh.FaceFunctionSizet_swiginit(self, _mesh.new_FaceFunctionSizet(*args))
    __swig_destroy__ = _mesh.delete_FaceFunctionSizet
FaceFunctionSizet_swigregister = _mesh.FaceFunctionSizet_swigregister
FaceFunctionSizet_swigregister(FaceFunctionSizet)

class FacetFunctionSizet(MeshFunctionSizet):
    """

    A FacetFunction is a MeshFunction of topological codimension 1.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _mesh.FacetFunctionSizet_swiginit(self, _mesh.new_FacetFunctionSizet(*args))
    __swig_destroy__ = _mesh.delete_FacetFunctionSizet
FacetFunctionSizet_swigregister = _mesh.FacetFunctionSizet_swigregister
FacetFunctionSizet_swigregister(FacetFunctionSizet)

class VertexFunctionSizet(MeshFunctionSizet):
    """

    A VertexFunction is a MeshFunction of topological dimension 0.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _mesh.VertexFunctionSizet_swiginit(self, _mesh.new_VertexFunctionSizet(*args))
    __swig_destroy__ = _mesh.delete_VertexFunctionSizet
VertexFunctionSizet_swigregister = _mesh.VertexFunctionSizet_swigregister
VertexFunctionSizet_swigregister(VertexFunctionSizet)


HierarchicalMeshFunctionSizet.leaf_node = HierarchicalMeshFunctionSizet._leaf_node
HierarchicalMeshFunctionSizet.root_node = HierarchicalMeshFunctionSizet._root_node
HierarchicalMeshFunctionSizet.child = HierarchicalMeshFunctionSizet._child
HierarchicalMeshFunctionSizet.parent = HierarchicalMeshFunctionSizet._parent

class MeshFunctionInt(common.Variable, HierarchicalMeshFunctionInt):
    """

    A MeshFunction is a function that can be evaluated at a set of
    mesh entities. A MeshFunction is discrete and is only defined
    at the set of mesh entities of a fixed topological dimension.
    A MeshFunction may for example be used to store a global
    numbering scheme for the entities of a (parallel) mesh, marking
    sub domains or boolean markers for mesh refinement.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * MeshFunction\ ()

          Create empty mesh function

        * MeshFunction\ (mesh)

          Create empty mesh function on given mesh

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.

        * MeshFunction\ (mesh)

          Create empty mesh function on given mesh (shared_ptr version)

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.

        * MeshFunction\ (mesh, dim)

          Create mesh function of given dimension on given mesh

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.
              dim (int)
                  The mesh entity dimension for the mesh function.

        * MeshFunction\ (mesh, dim)

          Create mesh function of given dimension on given mesh
          (shared_ptr version)

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.
              dim (int)
                  The mesh entity dimension for the mesh function.

        * MeshFunction\ (mesh, dim, value)

          Create mesh of given dimension on given mesh and initialize
          to a value

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.
              dim (int)
                  The mesh entity dimension.
              value (T)
                  The value.

        * MeshFunction\ (mesh, dim, value)

          Create mesh of given dimension on given mesh and initialize
          to a value (shared_ptr version)

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.
              dim (int)
                  The mesh entity dimension.
              value (T)
                  The value.

        * MeshFunction\ (mesh, filename)

          Create function from data file

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.
              filename (str)
                  The filename to create mesh function from.

        * MeshFunction\ (mesh, filename)

          Create function from data file (shared_ptr version)

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.
              filename (str)
                  The filename to create mesh function from.

        * MeshFunction\ (mesh, value_collection)

          Create function from a MeshValueCollecion

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.
              value_collection (:py:class:`MeshValueCollection`)
                  The mesh value collection for the mesh function data.

        * MeshFunction\ (mesh, value_collection)

          Create function from a MeshValueCollecion (shared_ptr version)

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.
              value_collection (:py:class:`MeshValueCollection`)
                  The mesh value collection for the mesh function data.

        * MeshFunction\ (mesh, dim, domains)

          Create function from MeshDomains

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.
              dim (int)
                  The dimension of the MeshFunction
              domains (:py:class:`MeshDomains`)
                  The domains from which to extract the domain markers

        * MeshFunction\ (f)

          Copy constructor

          *Arguments*
              f (:py:class:`MeshFunction`)
                  The object to be copied.

        """
        _mesh.MeshFunctionInt_swiginit(self, _mesh.new_MeshFunctionInt(*args))
    __swig_destroy__ = _mesh.delete_MeshFunctionInt

    def mesh(self):
        """

        Return mesh associated with mesh function

        *Returns*
            :py:class:`Mesh`
                The mesh.

        """
        return _mesh.MeshFunctionInt_mesh(self)


    def dim(self):
        """

        Return topological dimension

        *Returns*
            int
                The dimension.

        """
        return _mesh.MeshFunctionInt_dim(self)


    def empty(self):
        """

        Return true if empty

        *Returns*
            bool
                True if empty.

        """
        return _mesh.MeshFunctionInt_empty(self)


    def size(self):
        """

        Return size (number of entities)

        *Returns*
            int
                The size.

        """
        return _mesh.MeshFunctionInt_size(self)


    def init(self, *args):
        """

        **Overloaded versions**

        * init\ (dim)

          Initialize mesh function for given topological dimension

          *Arguments*
              dim (int)
                  The dimension.

        * init\ (dim, size)

          Initialize mesh function for given topological dimension of
          given size

          *Arguments*
              dim (int)
                  The dimension.
              size (int)
                  The size.

        * init\ (mesh, dim)

          Initialize mesh function for given topological dimension

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh.
              dim (int)
                  The dimension.

        * init\ (mesh, dim)

          Initialize mesh function for given topological dimension
          (shared_ptr version)

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh.
              dim (int)
                  The dimension.

        * init\ (mesh, dim, size)

          Initialize mesh function for given topological dimension of
          given size

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh.
              dim (int)
                  The dimension.
              size (int)
                  The size.

        * init\ (mesh, dim, size)

          Initialize mesh function for given topological dimension of
          given size (shared_ptr version)

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh.
              dim (int)
                  The dimension.
              size (int)
                  The size.

        """
        return _mesh.MeshFunctionInt_init(self, *args)


    def set_value(self, *args):
        """

        **Overloaded versions**

        * set_value\ (index, value)

          Set value at given index

          *Arguments*
              index (int)
                  The index.
              value (T)
                  The value.

        * set_value\ (index, value, mesh)

          Compatibility function for use in SubDomains

        """
        return _mesh.MeshFunctionInt_set_value(self, *args)


    def set_values(self, values):
        """

        Set values

        *Arguments*
            values (std::vector<T>)
                The values.

        """
        return _mesh.MeshFunctionInt_set_values(self, values)


    def set_all(self, value):
        """

        Set all values to given value

        *Arguments*
            value (T)
                The value to set all values to.

        """
        return _mesh.MeshFunctionInt_set_all(self, value)


    def _getitem(self, *args):
        """Missing docstring"""
        return _mesh.MeshFunctionInt__getitem(self, *args)


    def _setitem(self, *args):
        """Missing docstring"""
        return _mesh.MeshFunctionInt__setitem(self, *args)


    def array(self):
        """
        Return a NumPy array view of the data
        """
        data = self._array()
        _attach_base_to_numpy_array(data, self)
        return data

    def __getitem__(self, index):
        if not isinstance(index, (int, MeshEntity)):
            raise TypeError("expected an int or a MeshEntity as index argument")

        if isinstance(index, MeshEntity):
            entity = index
            assert entity.mesh().id() == self.mesh().id(), "MeshEntity and MeshFunction do not share the same mesh"
            assert entity.dim() == self.dim(), "MeshEntity and MeshFunction do not share the same topological dimensions"

            index = entity.index()

        while index < 0:
            index += self.size()
        if index >= self.size():
            raise IndexError("index out of range")
        return self._getitem(index)

    def __setitem__(self, index, value):
        if not isinstance(index, (int, MeshEntity)):
            raise TypeError("expected an int or a MeshEntity as index argument")

        if isinstance(index, MeshEntity):
            entity = index
            assert entity.mesh().id() == self.mesh().id(), "MeshEntity and MeshFunction do not share the same mesh"
            assert entity.dim() == self.dim(), "MeshEntity and MeshFunction do not share the same topological dimensions"

            index = entity.index()

        while index < 0:
            index += self.size()
        if index >= self.size():
            raise IndexError("index out of range")
        self._setitem(index, value)

    def __len__(self):
        return self.size()

    def ufl_id(self):
        "Returns an id that UFL can use to decide if two objects are the same."
        return self.id()


MeshFunctionInt.mesh = new_instancemethod(_mesh.MeshFunctionInt_mesh, None, MeshFunctionInt)
MeshFunctionInt.dim = new_instancemethod(_mesh.MeshFunctionInt_dim, None, MeshFunctionInt)
MeshFunctionInt.empty = new_instancemethod(_mesh.MeshFunctionInt_empty, None, MeshFunctionInt)
MeshFunctionInt.size = new_instancemethod(_mesh.MeshFunctionInt_size, None, MeshFunctionInt)
MeshFunctionInt.init = new_instancemethod(_mesh.MeshFunctionInt_init, None, MeshFunctionInt)
MeshFunctionInt.set_value = new_instancemethod(_mesh.MeshFunctionInt_set_value, None, MeshFunctionInt)
MeshFunctionInt.set_values = new_instancemethod(_mesh.MeshFunctionInt_set_values, None, MeshFunctionInt)
MeshFunctionInt.set_all = new_instancemethod(_mesh.MeshFunctionInt_set_all, None, MeshFunctionInt)
MeshFunctionInt._array = new_instancemethod(_mesh.MeshFunctionInt__array, None, MeshFunctionInt)
MeshFunctionInt._getitem = new_instancemethod(_mesh.MeshFunctionInt__getitem, None, MeshFunctionInt)
MeshFunctionInt._setitem = new_instancemethod(_mesh.MeshFunctionInt__setitem, None, MeshFunctionInt)
MeshFunctionInt_swigregister = _mesh.MeshFunctionInt_swigregister
MeshFunctionInt_swigregister(MeshFunctionInt)

class CellFunctionInt(MeshFunctionInt):
    """

    A CellFunction is a MeshFunction of topological codimension 0.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _mesh.CellFunctionInt_swiginit(self, _mesh.new_CellFunctionInt(*args))
    __swig_destroy__ = _mesh.delete_CellFunctionInt
CellFunctionInt_swigregister = _mesh.CellFunctionInt_swigregister
CellFunctionInt_swigregister(CellFunctionInt)

class EdgeFunctionInt(MeshFunctionInt):
    """

    An EdgeFunction is a :py:class:`MeshFunction` of topological dimension 1.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _mesh.EdgeFunctionInt_swiginit(self, _mesh.new_EdgeFunctionInt(*args))
    __swig_destroy__ = _mesh.delete_EdgeFunctionInt
EdgeFunctionInt_swigregister = _mesh.EdgeFunctionInt_swigregister
EdgeFunctionInt_swigregister(EdgeFunctionInt)

class FaceFunctionInt(MeshFunctionInt):
    """

    A FaceFunction is a MeshFunction of topological dimension 2.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _mesh.FaceFunctionInt_swiginit(self, _mesh.new_FaceFunctionInt(*args))
    __swig_destroy__ = _mesh.delete_FaceFunctionInt
FaceFunctionInt_swigregister = _mesh.FaceFunctionInt_swigregister
FaceFunctionInt_swigregister(FaceFunctionInt)

class FacetFunctionInt(MeshFunctionInt):
    """

    A FacetFunction is a MeshFunction of topological codimension 1.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _mesh.FacetFunctionInt_swiginit(self, _mesh.new_FacetFunctionInt(*args))
    __swig_destroy__ = _mesh.delete_FacetFunctionInt
FacetFunctionInt_swigregister = _mesh.FacetFunctionInt_swigregister
FacetFunctionInt_swigregister(FacetFunctionInt)

class VertexFunctionInt(MeshFunctionInt):
    """

    A VertexFunction is a MeshFunction of topological dimension 0.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _mesh.VertexFunctionInt_swiginit(self, _mesh.new_VertexFunctionInt(*args))
    __swig_destroy__ = _mesh.delete_VertexFunctionInt
VertexFunctionInt_swigregister = _mesh.VertexFunctionInt_swigregister
VertexFunctionInt_swigregister(VertexFunctionInt)


HierarchicalMeshFunctionInt.leaf_node = HierarchicalMeshFunctionInt._leaf_node
HierarchicalMeshFunctionInt.root_node = HierarchicalMeshFunctionInt._root_node
HierarchicalMeshFunctionInt.child = HierarchicalMeshFunctionInt._child
HierarchicalMeshFunctionInt.parent = HierarchicalMeshFunctionInt._parent

class MeshFunctionDouble(common.Variable, HierarchicalMeshFunctionDouble):
    """

    A MeshFunction is a function that can be evaluated at a set of
    mesh entities. A MeshFunction is discrete and is only defined
    at the set of mesh entities of a fixed topological dimension.
    A MeshFunction may for example be used to store a global
    numbering scheme for the entities of a (parallel) mesh, marking
    sub domains or boolean markers for mesh refinement.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * MeshFunction\ ()

          Create empty mesh function

        * MeshFunction\ (mesh)

          Create empty mesh function on given mesh

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.

        * MeshFunction\ (mesh)

          Create empty mesh function on given mesh (shared_ptr version)

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.

        * MeshFunction\ (mesh, dim)

          Create mesh function of given dimension on given mesh

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.
              dim (int)
                  The mesh entity dimension for the mesh function.

        * MeshFunction\ (mesh, dim)

          Create mesh function of given dimension on given mesh
          (shared_ptr version)

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.
              dim (int)
                  The mesh entity dimension for the mesh function.

        * MeshFunction\ (mesh, dim, value)

          Create mesh of given dimension on given mesh and initialize
          to a value

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.
              dim (int)
                  The mesh entity dimension.
              value (T)
                  The value.

        * MeshFunction\ (mesh, dim, value)

          Create mesh of given dimension on given mesh and initialize
          to a value (shared_ptr version)

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.
              dim (int)
                  The mesh entity dimension.
              value (T)
                  The value.

        * MeshFunction\ (mesh, filename)

          Create function from data file

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.
              filename (str)
                  The filename to create mesh function from.

        * MeshFunction\ (mesh, filename)

          Create function from data file (shared_ptr version)

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.
              filename (str)
                  The filename to create mesh function from.

        * MeshFunction\ (mesh, value_collection)

          Create function from a MeshValueCollecion

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.
              value_collection (:py:class:`MeshValueCollection`)
                  The mesh value collection for the mesh function data.

        * MeshFunction\ (mesh, value_collection)

          Create function from a MeshValueCollecion (shared_ptr version)

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.
              value_collection (:py:class:`MeshValueCollection`)
                  The mesh value collection for the mesh function data.

        * MeshFunction\ (mesh, dim, domains)

          Create function from MeshDomains

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.
              dim (int)
                  The dimension of the MeshFunction
              domains (:py:class:`MeshDomains`)
                  The domains from which to extract the domain markers

        * MeshFunction\ (f)

          Copy constructor

          *Arguments*
              f (:py:class:`MeshFunction`)
                  The object to be copied.

        """
        _mesh.MeshFunctionDouble_swiginit(self, _mesh.new_MeshFunctionDouble(*args))
    __swig_destroy__ = _mesh.delete_MeshFunctionDouble

    def mesh(self):
        """

        Return mesh associated with mesh function

        *Returns*
            :py:class:`Mesh`
                The mesh.

        """
        return _mesh.MeshFunctionDouble_mesh(self)


    def dim(self):
        """

        Return topological dimension

        *Returns*
            int
                The dimension.

        """
        return _mesh.MeshFunctionDouble_dim(self)


    def empty(self):
        """

        Return true if empty

        *Returns*
            bool
                True if empty.

        """
        return _mesh.MeshFunctionDouble_empty(self)


    def size(self):
        """

        Return size (number of entities)

        *Returns*
            int
                The size.

        """
        return _mesh.MeshFunctionDouble_size(self)


    def init(self, *args):
        """

        **Overloaded versions**

        * init\ (dim)

          Initialize mesh function for given topological dimension

          *Arguments*
              dim (int)
                  The dimension.

        * init\ (dim, size)

          Initialize mesh function for given topological dimension of
          given size

          *Arguments*
              dim (int)
                  The dimension.
              size (int)
                  The size.

        * init\ (mesh, dim)

          Initialize mesh function for given topological dimension

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh.
              dim (int)
                  The dimension.

        * init\ (mesh, dim)

          Initialize mesh function for given topological dimension
          (shared_ptr version)

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh.
              dim (int)
                  The dimension.

        * init\ (mesh, dim, size)

          Initialize mesh function for given topological dimension of
          given size

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh.
              dim (int)
                  The dimension.
              size (int)
                  The size.

        * init\ (mesh, dim, size)

          Initialize mesh function for given topological dimension of
          given size (shared_ptr version)

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh.
              dim (int)
                  The dimension.
              size (int)
                  The size.

        """
        return _mesh.MeshFunctionDouble_init(self, *args)


    def set_value(self, *args):
        """

        **Overloaded versions**

        * set_value\ (index, value)

          Set value at given index

          *Arguments*
              index (int)
                  The index.
              value (T)
                  The value.

        * set_value\ (index, value, mesh)

          Compatibility function for use in SubDomains

        """
        return _mesh.MeshFunctionDouble_set_value(self, *args)


    def set_values(self, values):
        """

        Set values

        *Arguments*
            values (std::vector<T>)
                The values.

        """
        return _mesh.MeshFunctionDouble_set_values(self, values)


    def set_all(self, value):
        """

        Set all values to given value

        *Arguments*
            value (T)
                The value to set all values to.

        """
        return _mesh.MeshFunctionDouble_set_all(self, value)


    def _getitem(self, *args):
        """Missing docstring"""
        return _mesh.MeshFunctionDouble__getitem(self, *args)


    def _setitem(self, *args):
        """Missing docstring"""
        return _mesh.MeshFunctionDouble__setitem(self, *args)


    def array(self):
        """
        Return a NumPy array view of the data
        """
        data = self._array()
        _attach_base_to_numpy_array(data, self)
        return data

    def __getitem__(self, index):
        if not isinstance(index, (int, MeshEntity)):
            raise TypeError("expected an int or a MeshEntity as index argument")

        if isinstance(index, MeshEntity):
            entity = index
            assert entity.mesh().id() == self.mesh().id(), "MeshEntity and MeshFunction do not share the same mesh"
            assert entity.dim() == self.dim(), "MeshEntity and MeshFunction do not share the same topological dimensions"

            index = entity.index()

        while index < 0:
            index += self.size()
        if index >= self.size():
            raise IndexError("index out of range")
        return self._getitem(index)

    def __setitem__(self, index, value):
        if not isinstance(index, (int, MeshEntity)):
            raise TypeError("expected an int or a MeshEntity as index argument")

        if isinstance(index, MeshEntity):
            entity = index
            assert entity.mesh().id() == self.mesh().id(), "MeshEntity and MeshFunction do not share the same mesh"
            assert entity.dim() == self.dim(), "MeshEntity and MeshFunction do not share the same topological dimensions"

            index = entity.index()

        while index < 0:
            index += self.size()
        if index >= self.size():
            raise IndexError("index out of range")
        self._setitem(index, value)

    def __len__(self):
        return self.size()

    def ufl_id(self):
        "Returns an id that UFL can use to decide if two objects are the same."
        return self.id()


MeshFunctionDouble.mesh = new_instancemethod(_mesh.MeshFunctionDouble_mesh, None, MeshFunctionDouble)
MeshFunctionDouble.dim = new_instancemethod(_mesh.MeshFunctionDouble_dim, None, MeshFunctionDouble)
MeshFunctionDouble.empty = new_instancemethod(_mesh.MeshFunctionDouble_empty, None, MeshFunctionDouble)
MeshFunctionDouble.size = new_instancemethod(_mesh.MeshFunctionDouble_size, None, MeshFunctionDouble)
MeshFunctionDouble.init = new_instancemethod(_mesh.MeshFunctionDouble_init, None, MeshFunctionDouble)
MeshFunctionDouble.set_value = new_instancemethod(_mesh.MeshFunctionDouble_set_value, None, MeshFunctionDouble)
MeshFunctionDouble.set_values = new_instancemethod(_mesh.MeshFunctionDouble_set_values, None, MeshFunctionDouble)
MeshFunctionDouble.set_all = new_instancemethod(_mesh.MeshFunctionDouble_set_all, None, MeshFunctionDouble)
MeshFunctionDouble._array = new_instancemethod(_mesh.MeshFunctionDouble__array, None, MeshFunctionDouble)
MeshFunctionDouble._getitem = new_instancemethod(_mesh.MeshFunctionDouble__getitem, None, MeshFunctionDouble)
MeshFunctionDouble._setitem = new_instancemethod(_mesh.MeshFunctionDouble__setitem, None, MeshFunctionDouble)
MeshFunctionDouble_swigregister = _mesh.MeshFunctionDouble_swigregister
MeshFunctionDouble_swigregister(MeshFunctionDouble)

class CellFunctionDouble(MeshFunctionDouble):
    """

    A CellFunction is a MeshFunction of topological codimension 0.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _mesh.CellFunctionDouble_swiginit(self, _mesh.new_CellFunctionDouble(*args))
    __swig_destroy__ = _mesh.delete_CellFunctionDouble
CellFunctionDouble_swigregister = _mesh.CellFunctionDouble_swigregister
CellFunctionDouble_swigregister(CellFunctionDouble)

class EdgeFunctionDouble(MeshFunctionDouble):
    """

    An EdgeFunction is a :py:class:`MeshFunction` of topological dimension 1.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _mesh.EdgeFunctionDouble_swiginit(self, _mesh.new_EdgeFunctionDouble(*args))
    __swig_destroy__ = _mesh.delete_EdgeFunctionDouble
EdgeFunctionDouble_swigregister = _mesh.EdgeFunctionDouble_swigregister
EdgeFunctionDouble_swigregister(EdgeFunctionDouble)

class FaceFunctionDouble(MeshFunctionDouble):
    """

    A FaceFunction is a MeshFunction of topological dimension 2.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _mesh.FaceFunctionDouble_swiginit(self, _mesh.new_FaceFunctionDouble(*args))
    __swig_destroy__ = _mesh.delete_FaceFunctionDouble
FaceFunctionDouble_swigregister = _mesh.FaceFunctionDouble_swigregister
FaceFunctionDouble_swigregister(FaceFunctionDouble)

class FacetFunctionDouble(MeshFunctionDouble):
    """

    A FacetFunction is a MeshFunction of topological codimension 1.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _mesh.FacetFunctionDouble_swiginit(self, _mesh.new_FacetFunctionDouble(*args))
    __swig_destroy__ = _mesh.delete_FacetFunctionDouble
FacetFunctionDouble_swigregister = _mesh.FacetFunctionDouble_swigregister
FacetFunctionDouble_swigregister(FacetFunctionDouble)

class VertexFunctionDouble(MeshFunctionDouble):
    """

    A VertexFunction is a MeshFunction of topological dimension 0.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _mesh.VertexFunctionDouble_swiginit(self, _mesh.new_VertexFunctionDouble(*args))
    __swig_destroy__ = _mesh.delete_VertexFunctionDouble
VertexFunctionDouble_swigregister = _mesh.VertexFunctionDouble_swigregister
VertexFunctionDouble_swigregister(VertexFunctionDouble)


HierarchicalMeshFunctionDouble.leaf_node = HierarchicalMeshFunctionDouble._leaf_node
HierarchicalMeshFunctionDouble.root_node = HierarchicalMeshFunctionDouble._root_node
HierarchicalMeshFunctionDouble.child = HierarchicalMeshFunctionDouble._child
HierarchicalMeshFunctionDouble.parent = HierarchicalMeshFunctionDouble._parent

class MeshFunctionBool(common.Variable, HierarchicalMeshFunctionBool):
    """

    A MeshFunction is a function that can be evaluated at a set of
    mesh entities. A MeshFunction is discrete and is only defined
    at the set of mesh entities of a fixed topological dimension.
    A MeshFunction may for example be used to store a global
    numbering scheme for the entities of a (parallel) mesh, marking
    sub domains or boolean markers for mesh refinement.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * MeshFunction\ ()

          Create empty mesh function

        * MeshFunction\ (mesh)

          Create empty mesh function on given mesh

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.

        * MeshFunction\ (mesh)

          Create empty mesh function on given mesh (shared_ptr version)

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.

        * MeshFunction\ (mesh, dim)

          Create mesh function of given dimension on given mesh

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.
              dim (int)
                  The mesh entity dimension for the mesh function.

        * MeshFunction\ (mesh, dim)

          Create mesh function of given dimension on given mesh
          (shared_ptr version)

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.
              dim (int)
                  The mesh entity dimension for the mesh function.

        * MeshFunction\ (mesh, dim, value)

          Create mesh of given dimension on given mesh and initialize
          to a value

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.
              dim (int)
                  The mesh entity dimension.
              value (T)
                  The value.

        * MeshFunction\ (mesh, dim, value)

          Create mesh of given dimension on given mesh and initialize
          to a value (shared_ptr version)

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.
              dim (int)
                  The mesh entity dimension.
              value (T)
                  The value.

        * MeshFunction\ (mesh, filename)

          Create function from data file

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.
              filename (str)
                  The filename to create mesh function from.

        * MeshFunction\ (mesh, filename)

          Create function from data file (shared_ptr version)

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.
              filename (str)
                  The filename to create mesh function from.

        * MeshFunction\ (mesh, value_collection)

          Create function from a MeshValueCollecion

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.
              value_collection (:py:class:`MeshValueCollection`)
                  The mesh value collection for the mesh function data.

        * MeshFunction\ (mesh, value_collection)

          Create function from a MeshValueCollecion (shared_ptr version)

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.
              value_collection (:py:class:`MeshValueCollection`)
                  The mesh value collection for the mesh function data.

        * MeshFunction\ (mesh, dim, domains)

          Create function from MeshDomains

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh to create mesh function on.
              dim (int)
                  The dimension of the MeshFunction
              domains (:py:class:`MeshDomains`)
                  The domains from which to extract the domain markers

        * MeshFunction\ (f)

          Copy constructor

          *Arguments*
              f (:py:class:`MeshFunction`)
                  The object to be copied.

        """
        _mesh.MeshFunctionBool_swiginit(self, _mesh.new_MeshFunctionBool(*args))
    __swig_destroy__ = _mesh.delete_MeshFunctionBool

    def mesh(self):
        """

        Return mesh associated with mesh function

        *Returns*
            :py:class:`Mesh`
                The mesh.

        """
        return _mesh.MeshFunctionBool_mesh(self)


    def dim(self):
        """

        Return topological dimension

        *Returns*
            int
                The dimension.

        """
        return _mesh.MeshFunctionBool_dim(self)


    def empty(self):
        """

        Return true if empty

        *Returns*
            bool
                True if empty.

        """
        return _mesh.MeshFunctionBool_empty(self)


    def size(self):
        """

        Return size (number of entities)

        *Returns*
            int
                The size.

        """
        return _mesh.MeshFunctionBool_size(self)


    def init(self, *args):
        """

        **Overloaded versions**

        * init\ (dim)

          Initialize mesh function for given topological dimension

          *Arguments*
              dim (int)
                  The dimension.

        * init\ (dim, size)

          Initialize mesh function for given topological dimension of
          given size

          *Arguments*
              dim (int)
                  The dimension.
              size (int)
                  The size.

        * init\ (mesh, dim)

          Initialize mesh function for given topological dimension

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh.
              dim (int)
                  The dimension.

        * init\ (mesh, dim)

          Initialize mesh function for given topological dimension
          (shared_ptr version)

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh.
              dim (int)
                  The dimension.

        * init\ (mesh, dim, size)

          Initialize mesh function for given topological dimension of
          given size

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh.
              dim (int)
                  The dimension.
              size (int)
                  The size.

        * init\ (mesh, dim, size)

          Initialize mesh function for given topological dimension of
          given size (shared_ptr version)

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh.
              dim (int)
                  The dimension.
              size (int)
                  The size.

        """
        return _mesh.MeshFunctionBool_init(self, *args)


    def set_value(self, *args):
        """

        **Overloaded versions**

        * set_value\ (index, value)

          Set value at given index

          *Arguments*
              index (int)
                  The index.
              value (T)
                  The value.

        * set_value\ (index, value, mesh)

          Compatibility function for use in SubDomains

        """
        return _mesh.MeshFunctionBool_set_value(self, *args)


    def set_values(self, values):
        """

        Set values

        *Arguments*
            values (std::vector<T>)
                The values.

        """
        return _mesh.MeshFunctionBool_set_values(self, values)


    def set_all(self, value):
        """

        Set all values to given value

        *Arguments*
            value (T)
                The value to set all values to.

        """
        return _mesh.MeshFunctionBool_set_all(self, value)


    def _getitem(self, *args):
        """Missing docstring"""
        return _mesh.MeshFunctionBool__getitem(self, *args)


    def _setitem(self, *args):
        """Missing docstring"""
        return _mesh.MeshFunctionBool__setitem(self, *args)


    def array(self):
        """
        Return a NumPy array view of the data
        """
        data = self._array()
        _attach_base_to_numpy_array(data, self)
        return data

    def __getitem__(self, index):
        if not isinstance(index, (int, MeshEntity)):
            raise TypeError("expected an int or a MeshEntity as index argument")

        if isinstance(index, MeshEntity):
            entity = index
            assert entity.mesh().id() == self.mesh().id(), "MeshEntity and MeshFunction do not share the same mesh"
            assert entity.dim() == self.dim(), "MeshEntity and MeshFunction do not share the same topological dimensions"

            index = entity.index()

        while index < 0:
            index += self.size()
        if index >= self.size():
            raise IndexError("index out of range")
        return self._getitem(index)

    def __setitem__(self, index, value):
        if not isinstance(index, (int, MeshEntity)):
            raise TypeError("expected an int or a MeshEntity as index argument")

        if isinstance(index, MeshEntity):
            entity = index
            assert entity.mesh().id() == self.mesh().id(), "MeshEntity and MeshFunction do not share the same mesh"
            assert entity.dim() == self.dim(), "MeshEntity and MeshFunction do not share the same topological dimensions"

            index = entity.index()

        while index < 0:
            index += self.size()
        if index >= self.size():
            raise IndexError("index out of range")
        self._setitem(index, value)

    def __len__(self):
        return self.size()

    def ufl_id(self):
        "Returns an id that UFL can use to decide if two objects are the same."
        return self.id()


MeshFunctionBool.mesh = new_instancemethod(_mesh.MeshFunctionBool_mesh, None, MeshFunctionBool)
MeshFunctionBool.dim = new_instancemethod(_mesh.MeshFunctionBool_dim, None, MeshFunctionBool)
MeshFunctionBool.empty = new_instancemethod(_mesh.MeshFunctionBool_empty, None, MeshFunctionBool)
MeshFunctionBool.size = new_instancemethod(_mesh.MeshFunctionBool_size, None, MeshFunctionBool)
MeshFunctionBool.init = new_instancemethod(_mesh.MeshFunctionBool_init, None, MeshFunctionBool)
MeshFunctionBool.set_value = new_instancemethod(_mesh.MeshFunctionBool_set_value, None, MeshFunctionBool)
MeshFunctionBool.set_values = new_instancemethod(_mesh.MeshFunctionBool_set_values, None, MeshFunctionBool)
MeshFunctionBool.set_all = new_instancemethod(_mesh.MeshFunctionBool_set_all, None, MeshFunctionBool)
MeshFunctionBool._array = new_instancemethod(_mesh.MeshFunctionBool__array, None, MeshFunctionBool)
MeshFunctionBool._getitem = new_instancemethod(_mesh.MeshFunctionBool__getitem, None, MeshFunctionBool)
MeshFunctionBool._setitem = new_instancemethod(_mesh.MeshFunctionBool__setitem, None, MeshFunctionBool)
MeshFunctionBool_swigregister = _mesh.MeshFunctionBool_swigregister
MeshFunctionBool_swigregister(MeshFunctionBool)

class CellFunctionBool(MeshFunctionBool):
    """

    A CellFunction is a MeshFunction of topological codimension 0.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _mesh.CellFunctionBool_swiginit(self, _mesh.new_CellFunctionBool(*args))
    __swig_destroy__ = _mesh.delete_CellFunctionBool
CellFunctionBool_swigregister = _mesh.CellFunctionBool_swigregister
CellFunctionBool_swigregister(CellFunctionBool)

class EdgeFunctionBool(MeshFunctionBool):
    """

    An EdgeFunction is a :py:class:`MeshFunction` of topological dimension 1.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _mesh.EdgeFunctionBool_swiginit(self, _mesh.new_EdgeFunctionBool(*args))
    __swig_destroy__ = _mesh.delete_EdgeFunctionBool
EdgeFunctionBool_swigregister = _mesh.EdgeFunctionBool_swigregister
EdgeFunctionBool_swigregister(EdgeFunctionBool)

class FaceFunctionBool(MeshFunctionBool):
    """

    A FaceFunction is a MeshFunction of topological dimension 2.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _mesh.FaceFunctionBool_swiginit(self, _mesh.new_FaceFunctionBool(*args))
    __swig_destroy__ = _mesh.delete_FaceFunctionBool
FaceFunctionBool_swigregister = _mesh.FaceFunctionBool_swigregister
FaceFunctionBool_swigregister(FaceFunctionBool)

class FacetFunctionBool(MeshFunctionBool):
    """

    A FacetFunction is a MeshFunction of topological codimension 1.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _mesh.FacetFunctionBool_swiginit(self, _mesh.new_FacetFunctionBool(*args))
    __swig_destroy__ = _mesh.delete_FacetFunctionBool
FacetFunctionBool_swigregister = _mesh.FacetFunctionBool_swigregister
FacetFunctionBool_swigregister(FacetFunctionBool)

class VertexFunctionBool(MeshFunctionBool):
    """

    A VertexFunction is a MeshFunction of topological dimension 0.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _mesh.VertexFunctionBool_swiginit(self, _mesh.new_VertexFunctionBool(*args))
    __swig_destroy__ = _mesh.delete_VertexFunctionBool
VertexFunctionBool_swigregister = _mesh.VertexFunctionBool_swigregister
VertexFunctionBool_swigregister(VertexFunctionBool)


HierarchicalMeshFunctionBool.leaf_node = HierarchicalMeshFunctionBool._leaf_node
HierarchicalMeshFunctionBool.root_node = HierarchicalMeshFunctionBool._root_node
HierarchicalMeshFunctionBool.child = HierarchicalMeshFunctionBool._child
HierarchicalMeshFunctionBool.parent = HierarchicalMeshFunctionBool._parent


_doc_string = MeshFunctionInt.__doc__
_doc_string += """
  *Arguments*
    tp (str)
      String defining the type of the MeshFunction
      Allowed: 'int', 'size_t', 'double', and 'bool'
    mesh (_Mesh_)
      A DOLFIN mesh.
      Optional.
    dim (unsigned int)
      The topological dimension of the MeshFunction.
      Optional.
    filename (str)
      A filename with a stored MeshFunction.
      Optional.

"""
class MeshFunction(object):
    __doc__ = _doc_string
    def __new__(cls, tp, *args):
        if not isinstance(tp, str):
            raise TypeError("expected a 'str' as first argument")
        if tp == "int":
            return MeshFunctionInt(*args)
        if tp == "uint":
            from . import common
            common.deprecation("uint-valued MeshFunction", "1.1.0", "TBA",
                               "Typename \"uint\" has been changed to \"size_t\".")
            return MeshFunctionSizet(*args)
        elif tp == "size_t":
            return MeshFunctionSizet(*args)
        elif tp == "double":
            return MeshFunctionDouble(*args)
        elif tp == "bool":
            return MeshFunctionBool(*args)
        else:
            raise RuntimeError("Cannot create a MeshFunction of type '%s'." % (tp,))

del _doc_string

def _new_closure(MeshType):
    assert(isinstance(MeshType, str))
    def new(cls, tp, mesh, value=0):
        if not isinstance(tp, str):
            raise TypeError("expected a 'str' as first argument")
        if tp == "int":
            return eval("%sInt(mesh, value)"%MeshType)
        if tp == "uint":
            return eval("%sSizet(mesh, value)"%MeshType)
        if tp == "size_t":
            return eval("%sSizet(mesh, value)"%MeshType)
        elif tp == "double":
            return eval("%sDouble(mesh, float(value))"%MeshType)
        elif tp == "bool":
            value = bool(value) if isinstance(value, int) else value
            return eval("%sBool(mesh, value)"%MeshType)
        else:
            raise RuntimeError("Cannot create a %sFunction of type '%s'." % (MeshType, tp))

    return new

# Create the named MeshFunction types
VertexFunction = type("VertexFunction", (), \
		      {"__new__":_new_closure("VertexFunction"),\
                       "__doc__":"Create MeshFunction of topological"\
                       " dimension 0 on given mesh."})
EdgeFunction = type("EdgeFunction", (), \
                    {"__new__":_new_closure("EdgeFunction"),\
                     "__doc__":"Create MeshFunction of topological"\
                     " dimension 1 on given mesh."})
FaceFunction = type("FaceFunction", (),\
                    {"__new__":_new_closure("FaceFunction"),\
                     "__doc__":"Create MeshFunction of topological"\
                     " dimension 2 on given mesh."})
FacetFunction = type("FacetFunction", (),\
                     {"__new__":_new_closure("FacetFunction"),
                      "__doc__":"Create MeshFunction of topological"\
                      " codimension 1 on given mesh."})
CellFunction = type("CellFunction", (),\
                    {"__new__":_new_closure("CellFunction"),\
                     "__doc__":"Create MeshFunction of topological"\
                     " codimension 0 on given mesh."})

class MeshValueCollectionSizet(common.Variable):
    """

    The MeshValueCollection class can be used to store data
    associated with a subset of the entities of a mesh of a given
    topological dimension. It differs from the MeshFunction class in
    two ways. First, data does not need to be associated with all
    entities (only a subset). Second, data is associated with
    entities through the corresponding cell index and local entity
    number (relative to the cell), not by global entity index, which
    means that data may be stored robustly to file.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * MeshValueCollection\ ()

          Create empty mesh value collection


        * MeshValueCollection\ (mesh)

          Create an empty mesh value collection on a given mesh

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh.

        * MeshValueCollection\ (mesh_function)

          Create a mesh value collection from a MeshFunction

          *Arguments*
              mesh_function (:py:class:`MeshFunction`)
                  The mesh function for creating a MeshValueCollection.

        * MeshValueCollection\ (mesh, dim)

          Create a mesh value collection of entities of given dimension
          on a given mesh

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh associated with the collection.
              dim (int)
                  The mesh entity dimension for the mesh value collection.

        * MeshValueCollection\ (mesh, dim)

          Create a mesh value collection of entities of given dimension
          on a given mesh (shared_ptr version)

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh associated with the collection.
              dim (int)
                  The mesh entity dimension for the mesh value collection.

        * MeshValueCollection\ (mesh, filename)

          Create a mesh value collection from a file.

          *Arguments*
              mesh (Mesh)
                  A mesh associated with the collection. The mesh is used to
                  map collection values to the appropriate process.
              filename (str)
                  The XML file name.
              dim (int)
                  The mesh entity dimension for the mesh value collection.

        """
        _mesh.MeshValueCollectionSizet_swiginit(self, _mesh.new_MeshValueCollectionSizet(*args))
    __swig_destroy__ = _mesh.delete_MeshValueCollectionSizet

    def init(self, *args):
        """

        **Overloaded versions**

        * init\ (mesh, dim)

          Initialise MeshValueCollection with mesh and dimension

          *Arguments*
              mesh (_mesh)
                  The mesh on which the value collection is defined
              dim (int)
                  The mesh entity dimension for the mesh value collection.

        * init\ (mesh, dim)

          Initialise MeshValueCollection with mesh and dimension
          (shared_ptr version)

          *Arguments*
              mesh (_mesh)
                  The mesh on which the value collection is defined
              dim (int)
                  The mesh entity dimension for the mesh value collection.

        * init\ (dim)

          Set dimension. This function should not generally be used. It is
          for reading MeshValueCollections as the dimension is not
          generally known at construction.

          *Arguments*
              dim (int)
                  The mesh entity dimension for the mesh value collection.

        """
        return _mesh.MeshValueCollectionSizet_init(self, *args)


    def dim(self):
        """

        Return topological dimension

        *Returns*
            int
                The dimension.

        """
        return _mesh.MeshValueCollectionSizet_dim(self)


    def mesh(self):
        """

        Return associated mesh

        *Returns*
            :py:class:`Mesh`
                The mesh.

        """
        return _mesh.MeshValueCollectionSizet_mesh(self)


    def empty(self):
        """

        Return true if the subset is empty

        *Returns*
            bool
                True if the subset is empty.

        """
        return _mesh.MeshValueCollectionSizet_empty(self)


    def size(self):
        """

        Return size (number of entities in subset)

        *Returns*
            int
                The size.

        """
        return _mesh.MeshValueCollectionSizet_size(self)


    def set_value(self, *args):
        """

        **Overloaded versions**

        * set_value\ (cell_index, local_entity, value)

          Set marker value for given entity defined by a cell index and
          a local entity index

          *Arguments*
              cell_index (int)
                  The index of the cell.
              local_entity (int)
                  The local index of the entity relative to the cell.
              marker_value (T)
                  The value of the marker.

          *Returns*
              bool
                  True is a new value is inserted, false if overwriting
                  an existing value.

        * set_value\ (entity_index, value)

          Set value for given entity index

          *Arguments*
              entity_index (int)
                  Index of the entity.
              value (T)
                  The value of the marker.
              mesh (:py:class:`Mesh`)
                  The mesh.

          *Returns*
              bool
                  True is a new value is inserted, false if overwriting
                  an existing value.

        """
        return _mesh.MeshValueCollectionSizet_set_value(self, *args)


    def get_value(self, cell_index, local_entity):
        """

        Get marker value for given entity defined by a cell index and
        a local entity index

        *Arguments*
            cell_index (int)
                The index of the cell.
            local_entity (int)
                The local index of the entity relative to the cell.

        *Returns*
            marker_value (T)
                The value of the marker.

        """
        return _mesh.MeshValueCollectionSizet_get_value(self, cell_index, local_entity)


    def values(self, *args):
        """

        **Overloaded versions**

        * values\ ()

          Get all values

          *Returns*
              std::map<std::pair<std::size_t, std::size_t>, T>
                  A map from positions to values.

        * values\ ()

          Get all values (const version)

          *Returns*
              std::map<std::pair<std::size_t, std::size_t>, T>
                  A map from positions to values.

        """
        return _mesh.MeshValueCollectionSizet_values(self, *args)


    def clear(self):
        """

        Clear all values

        """
        return _mesh.MeshValueCollectionSizet_clear(self)


    def assign(self, *args):
        """Missing docstring"""
        return _mesh.MeshValueCollectionSizet_assign(self, *args)

MeshValueCollectionSizet.init = new_instancemethod(_mesh.MeshValueCollectionSizet_init, None, MeshValueCollectionSizet)
MeshValueCollectionSizet.dim = new_instancemethod(_mesh.MeshValueCollectionSizet_dim, None, MeshValueCollectionSizet)
MeshValueCollectionSizet.mesh = new_instancemethod(_mesh.MeshValueCollectionSizet_mesh, None, MeshValueCollectionSizet)
MeshValueCollectionSizet.empty = new_instancemethod(_mesh.MeshValueCollectionSizet_empty, None, MeshValueCollectionSizet)
MeshValueCollectionSizet.size = new_instancemethod(_mesh.MeshValueCollectionSizet_size, None, MeshValueCollectionSizet)
MeshValueCollectionSizet.set_value = new_instancemethod(_mesh.MeshValueCollectionSizet_set_value, None, MeshValueCollectionSizet)
MeshValueCollectionSizet.get_value = new_instancemethod(_mesh.MeshValueCollectionSizet_get_value, None, MeshValueCollectionSizet)
MeshValueCollectionSizet.values = new_instancemethod(_mesh.MeshValueCollectionSizet_values, None, MeshValueCollectionSizet)
MeshValueCollectionSizet.clear = new_instancemethod(_mesh.MeshValueCollectionSizet_clear, None, MeshValueCollectionSizet)
MeshValueCollectionSizet.assign = new_instancemethod(_mesh.MeshValueCollectionSizet_assign, None, MeshValueCollectionSizet)
MeshValueCollectionSizet_swigregister = _mesh.MeshValueCollectionSizet_swigregister
MeshValueCollectionSizet_swigregister(MeshValueCollectionSizet)

class MeshValueCollectionInt(common.Variable):
    """

    The MeshValueCollection class can be used to store data
    associated with a subset of the entities of a mesh of a given
    topological dimension. It differs from the MeshFunction class in
    two ways. First, data does not need to be associated with all
    entities (only a subset). Second, data is associated with
    entities through the corresponding cell index and local entity
    number (relative to the cell), not by global entity index, which
    means that data may be stored robustly to file.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * MeshValueCollection\ ()

          Create empty mesh value collection


        * MeshValueCollection\ (mesh)

          Create an empty mesh value collection on a given mesh

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh.

        * MeshValueCollection\ (mesh_function)

          Create a mesh value collection from a MeshFunction

          *Arguments*
              mesh_function (:py:class:`MeshFunction`)
                  The mesh function for creating a MeshValueCollection.

        * MeshValueCollection\ (mesh, dim)

          Create a mesh value collection of entities of given dimension
          on a given mesh

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh associated with the collection.
              dim (int)
                  The mesh entity dimension for the mesh value collection.

        * MeshValueCollection\ (mesh, dim)

          Create a mesh value collection of entities of given dimension
          on a given mesh (shared_ptr version)

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh associated with the collection.
              dim (int)
                  The mesh entity dimension for the mesh value collection.

        * MeshValueCollection\ (mesh, filename)

          Create a mesh value collection from a file.

          *Arguments*
              mesh (Mesh)
                  A mesh associated with the collection. The mesh is used to
                  map collection values to the appropriate process.
              filename (str)
                  The XML file name.
              dim (int)
                  The mesh entity dimension for the mesh value collection.

        """
        _mesh.MeshValueCollectionInt_swiginit(self, _mesh.new_MeshValueCollectionInt(*args))
    __swig_destroy__ = _mesh.delete_MeshValueCollectionInt

    def init(self, *args):
        """

        **Overloaded versions**

        * init\ (mesh, dim)

          Initialise MeshValueCollection with mesh and dimension

          *Arguments*
              mesh (_mesh)
                  The mesh on which the value collection is defined
              dim (int)
                  The mesh entity dimension for the mesh value collection.

        * init\ (mesh, dim)

          Initialise MeshValueCollection with mesh and dimension
          (shared_ptr version)

          *Arguments*
              mesh (_mesh)
                  The mesh on which the value collection is defined
              dim (int)
                  The mesh entity dimension for the mesh value collection.

        * init\ (dim)

          Set dimension. This function should not generally be used. It is
          for reading MeshValueCollections as the dimension is not
          generally known at construction.

          *Arguments*
              dim (int)
                  The mesh entity dimension for the mesh value collection.

        """
        return _mesh.MeshValueCollectionInt_init(self, *args)


    def dim(self):
        """

        Return topological dimension

        *Returns*
            int
                The dimension.

        """
        return _mesh.MeshValueCollectionInt_dim(self)


    def mesh(self):
        """

        Return associated mesh

        *Returns*
            :py:class:`Mesh`
                The mesh.

        """
        return _mesh.MeshValueCollectionInt_mesh(self)


    def empty(self):
        """

        Return true if the subset is empty

        *Returns*
            bool
                True if the subset is empty.

        """
        return _mesh.MeshValueCollectionInt_empty(self)


    def size(self):
        """

        Return size (number of entities in subset)

        *Returns*
            int
                The size.

        """
        return _mesh.MeshValueCollectionInt_size(self)


    def set_value(self, *args):
        """

        **Overloaded versions**

        * set_value\ (cell_index, local_entity, value)

          Set marker value for given entity defined by a cell index and
          a local entity index

          *Arguments*
              cell_index (int)
                  The index of the cell.
              local_entity (int)
                  The local index of the entity relative to the cell.
              marker_value (T)
                  The value of the marker.

          *Returns*
              bool
                  True is a new value is inserted, false if overwriting
                  an existing value.

        * set_value\ (entity_index, value)

          Set value for given entity index

          *Arguments*
              entity_index (int)
                  Index of the entity.
              value (T)
                  The value of the marker.
              mesh (:py:class:`Mesh`)
                  The mesh.

          *Returns*
              bool
                  True is a new value is inserted, false if overwriting
                  an existing value.

        """
        return _mesh.MeshValueCollectionInt_set_value(self, *args)


    def get_value(self, cell_index, local_entity):
        """

        Get marker value for given entity defined by a cell index and
        a local entity index

        *Arguments*
            cell_index (int)
                The index of the cell.
            local_entity (int)
                The local index of the entity relative to the cell.

        *Returns*
            marker_value (T)
                The value of the marker.

        """
        return _mesh.MeshValueCollectionInt_get_value(self, cell_index, local_entity)


    def values(self, *args):
        """

        **Overloaded versions**

        * values\ ()

          Get all values

          *Returns*
              std::map<std::pair<std::size_t, std::size_t>, T>
                  A map from positions to values.

        * values\ ()

          Get all values (const version)

          *Returns*
              std::map<std::pair<std::size_t, std::size_t>, T>
                  A map from positions to values.

        """
        return _mesh.MeshValueCollectionInt_values(self, *args)


    def clear(self):
        """

        Clear all values

        """
        return _mesh.MeshValueCollectionInt_clear(self)


    def assign(self, *args):
        """Missing docstring"""
        return _mesh.MeshValueCollectionInt_assign(self, *args)

MeshValueCollectionInt.init = new_instancemethod(_mesh.MeshValueCollectionInt_init, None, MeshValueCollectionInt)
MeshValueCollectionInt.dim = new_instancemethod(_mesh.MeshValueCollectionInt_dim, None, MeshValueCollectionInt)
MeshValueCollectionInt.mesh = new_instancemethod(_mesh.MeshValueCollectionInt_mesh, None, MeshValueCollectionInt)
MeshValueCollectionInt.empty = new_instancemethod(_mesh.MeshValueCollectionInt_empty, None, MeshValueCollectionInt)
MeshValueCollectionInt.size = new_instancemethod(_mesh.MeshValueCollectionInt_size, None, MeshValueCollectionInt)
MeshValueCollectionInt.set_value = new_instancemethod(_mesh.MeshValueCollectionInt_set_value, None, MeshValueCollectionInt)
MeshValueCollectionInt.get_value = new_instancemethod(_mesh.MeshValueCollectionInt_get_value, None, MeshValueCollectionInt)
MeshValueCollectionInt.values = new_instancemethod(_mesh.MeshValueCollectionInt_values, None, MeshValueCollectionInt)
MeshValueCollectionInt.clear = new_instancemethod(_mesh.MeshValueCollectionInt_clear, None, MeshValueCollectionInt)
MeshValueCollectionInt.assign = new_instancemethod(_mesh.MeshValueCollectionInt_assign, None, MeshValueCollectionInt)
MeshValueCollectionInt_swigregister = _mesh.MeshValueCollectionInt_swigregister
MeshValueCollectionInt_swigregister(MeshValueCollectionInt)

class MeshValueCollectionDouble(common.Variable):
    """

    The MeshValueCollection class can be used to store data
    associated with a subset of the entities of a mesh of a given
    topological dimension. It differs from the MeshFunction class in
    two ways. First, data does not need to be associated with all
    entities (only a subset). Second, data is associated with
    entities through the corresponding cell index and local entity
    number (relative to the cell), not by global entity index, which
    means that data may be stored robustly to file.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * MeshValueCollection\ ()

          Create empty mesh value collection


        * MeshValueCollection\ (mesh)

          Create an empty mesh value collection on a given mesh

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh.

        * MeshValueCollection\ (mesh_function)

          Create a mesh value collection from a MeshFunction

          *Arguments*
              mesh_function (:py:class:`MeshFunction`)
                  The mesh function for creating a MeshValueCollection.

        * MeshValueCollection\ (mesh, dim)

          Create a mesh value collection of entities of given dimension
          on a given mesh

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh associated with the collection.
              dim (int)
                  The mesh entity dimension for the mesh value collection.

        * MeshValueCollection\ (mesh, dim)

          Create a mesh value collection of entities of given dimension
          on a given mesh (shared_ptr version)

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh associated with the collection.
              dim (int)
                  The mesh entity dimension for the mesh value collection.

        * MeshValueCollection\ (mesh, filename)

          Create a mesh value collection from a file.

          *Arguments*
              mesh (Mesh)
                  A mesh associated with the collection. The mesh is used to
                  map collection values to the appropriate process.
              filename (str)
                  The XML file name.
              dim (int)
                  The mesh entity dimension for the mesh value collection.

        """
        _mesh.MeshValueCollectionDouble_swiginit(self, _mesh.new_MeshValueCollectionDouble(*args))
    __swig_destroy__ = _mesh.delete_MeshValueCollectionDouble

    def init(self, *args):
        """

        **Overloaded versions**

        * init\ (mesh, dim)

          Initialise MeshValueCollection with mesh and dimension

          *Arguments*
              mesh (_mesh)
                  The mesh on which the value collection is defined
              dim (int)
                  The mesh entity dimension for the mesh value collection.

        * init\ (mesh, dim)

          Initialise MeshValueCollection with mesh and dimension
          (shared_ptr version)

          *Arguments*
              mesh (_mesh)
                  The mesh on which the value collection is defined
              dim (int)
                  The mesh entity dimension for the mesh value collection.

        * init\ (dim)

          Set dimension. This function should not generally be used. It is
          for reading MeshValueCollections as the dimension is not
          generally known at construction.

          *Arguments*
              dim (int)
                  The mesh entity dimension for the mesh value collection.

        """
        return _mesh.MeshValueCollectionDouble_init(self, *args)


    def dim(self):
        """

        Return topological dimension

        *Returns*
            int
                The dimension.

        """
        return _mesh.MeshValueCollectionDouble_dim(self)


    def mesh(self):
        """

        Return associated mesh

        *Returns*
            :py:class:`Mesh`
                The mesh.

        """
        return _mesh.MeshValueCollectionDouble_mesh(self)


    def empty(self):
        """

        Return true if the subset is empty

        *Returns*
            bool
                True if the subset is empty.

        """
        return _mesh.MeshValueCollectionDouble_empty(self)


    def size(self):
        """

        Return size (number of entities in subset)

        *Returns*
            int
                The size.

        """
        return _mesh.MeshValueCollectionDouble_size(self)


    def set_value(self, *args):
        """

        **Overloaded versions**

        * set_value\ (cell_index, local_entity, value)

          Set marker value for given entity defined by a cell index and
          a local entity index

          *Arguments*
              cell_index (int)
                  The index of the cell.
              local_entity (int)
                  The local index of the entity relative to the cell.
              marker_value (T)
                  The value of the marker.

          *Returns*
              bool
                  True is a new value is inserted, false if overwriting
                  an existing value.

        * set_value\ (entity_index, value)

          Set value for given entity index

          *Arguments*
              entity_index (int)
                  Index of the entity.
              value (T)
                  The value of the marker.
              mesh (:py:class:`Mesh`)
                  The mesh.

          *Returns*
              bool
                  True is a new value is inserted, false if overwriting
                  an existing value.

        """
        return _mesh.MeshValueCollectionDouble_set_value(self, *args)


    def get_value(self, cell_index, local_entity):
        """

        Get marker value for given entity defined by a cell index and
        a local entity index

        *Arguments*
            cell_index (int)
                The index of the cell.
            local_entity (int)
                The local index of the entity relative to the cell.

        *Returns*
            marker_value (T)
                The value of the marker.

        """
        return _mesh.MeshValueCollectionDouble_get_value(self, cell_index, local_entity)


    def values(self, *args):
        """

        **Overloaded versions**

        * values\ ()

          Get all values

          *Returns*
              std::map<std::pair<std::size_t, std::size_t>, T>
                  A map from positions to values.

        * values\ ()

          Get all values (const version)

          *Returns*
              std::map<std::pair<std::size_t, std::size_t>, T>
                  A map from positions to values.

        """
        return _mesh.MeshValueCollectionDouble_values(self, *args)


    def clear(self):
        """

        Clear all values

        """
        return _mesh.MeshValueCollectionDouble_clear(self)


    def assign(self, *args):
        """Missing docstring"""
        return _mesh.MeshValueCollectionDouble_assign(self, *args)

MeshValueCollectionDouble.init = new_instancemethod(_mesh.MeshValueCollectionDouble_init, None, MeshValueCollectionDouble)
MeshValueCollectionDouble.dim = new_instancemethod(_mesh.MeshValueCollectionDouble_dim, None, MeshValueCollectionDouble)
MeshValueCollectionDouble.mesh = new_instancemethod(_mesh.MeshValueCollectionDouble_mesh, None, MeshValueCollectionDouble)
MeshValueCollectionDouble.empty = new_instancemethod(_mesh.MeshValueCollectionDouble_empty, None, MeshValueCollectionDouble)
MeshValueCollectionDouble.size = new_instancemethod(_mesh.MeshValueCollectionDouble_size, None, MeshValueCollectionDouble)
MeshValueCollectionDouble.set_value = new_instancemethod(_mesh.MeshValueCollectionDouble_set_value, None, MeshValueCollectionDouble)
MeshValueCollectionDouble.get_value = new_instancemethod(_mesh.MeshValueCollectionDouble_get_value, None, MeshValueCollectionDouble)
MeshValueCollectionDouble.values = new_instancemethod(_mesh.MeshValueCollectionDouble_values, None, MeshValueCollectionDouble)
MeshValueCollectionDouble.clear = new_instancemethod(_mesh.MeshValueCollectionDouble_clear, None, MeshValueCollectionDouble)
MeshValueCollectionDouble.assign = new_instancemethod(_mesh.MeshValueCollectionDouble_assign, None, MeshValueCollectionDouble)
MeshValueCollectionDouble_swigregister = _mesh.MeshValueCollectionDouble_swigregister
MeshValueCollectionDouble_swigregister(MeshValueCollectionDouble)

class MeshValueCollectionBool(common.Variable):
    """

    The MeshValueCollection class can be used to store data
    associated with a subset of the entities of a mesh of a given
    topological dimension. It differs from the MeshFunction class in
    two ways. First, data does not need to be associated with all
    entities (only a subset). Second, data is associated with
    entities through the corresponding cell index and local entity
    number (relative to the cell), not by global entity index, which
    means that data may be stored robustly to file.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * MeshValueCollection\ ()

          Create empty mesh value collection


        * MeshValueCollection\ (mesh)

          Create an empty mesh value collection on a given mesh

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh.

        * MeshValueCollection\ (mesh_function)

          Create a mesh value collection from a MeshFunction

          *Arguments*
              mesh_function (:py:class:`MeshFunction`)
                  The mesh function for creating a MeshValueCollection.

        * MeshValueCollection\ (mesh, dim)

          Create a mesh value collection of entities of given dimension
          on a given mesh

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh associated with the collection.
              dim (int)
                  The mesh entity dimension for the mesh value collection.

        * MeshValueCollection\ (mesh, dim)

          Create a mesh value collection of entities of given dimension
          on a given mesh (shared_ptr version)

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh associated with the collection.
              dim (int)
                  The mesh entity dimension for the mesh value collection.

        * MeshValueCollection\ (mesh, filename)

          Create a mesh value collection from a file.

          *Arguments*
              mesh (Mesh)
                  A mesh associated with the collection. The mesh is used to
                  map collection values to the appropriate process.
              filename (str)
                  The XML file name.
              dim (int)
                  The mesh entity dimension for the mesh value collection.

        """
        _mesh.MeshValueCollectionBool_swiginit(self, _mesh.new_MeshValueCollectionBool(*args))
    __swig_destroy__ = _mesh.delete_MeshValueCollectionBool

    def init(self, *args):
        """

        **Overloaded versions**

        * init\ (mesh, dim)

          Initialise MeshValueCollection with mesh and dimension

          *Arguments*
              mesh (_mesh)
                  The mesh on which the value collection is defined
              dim (int)
                  The mesh entity dimension for the mesh value collection.

        * init\ (mesh, dim)

          Initialise MeshValueCollection with mesh and dimension
          (shared_ptr version)

          *Arguments*
              mesh (_mesh)
                  The mesh on which the value collection is defined
              dim (int)
                  The mesh entity dimension for the mesh value collection.

        * init\ (dim)

          Set dimension. This function should not generally be used. It is
          for reading MeshValueCollections as the dimension is not
          generally known at construction.

          *Arguments*
              dim (int)
                  The mesh entity dimension for the mesh value collection.

        """
        return _mesh.MeshValueCollectionBool_init(self, *args)


    def dim(self):
        """

        Return topological dimension

        *Returns*
            int
                The dimension.

        """
        return _mesh.MeshValueCollectionBool_dim(self)


    def mesh(self):
        """

        Return associated mesh

        *Returns*
            :py:class:`Mesh`
                The mesh.

        """
        return _mesh.MeshValueCollectionBool_mesh(self)


    def empty(self):
        """

        Return true if the subset is empty

        *Returns*
            bool
                True if the subset is empty.

        """
        return _mesh.MeshValueCollectionBool_empty(self)


    def size(self):
        """

        Return size (number of entities in subset)

        *Returns*
            int
                The size.

        """
        return _mesh.MeshValueCollectionBool_size(self)


    def set_value(self, *args):
        """

        **Overloaded versions**

        * set_value\ (cell_index, local_entity, value)

          Set marker value for given entity defined by a cell index and
          a local entity index

          *Arguments*
              cell_index (int)
                  The index of the cell.
              local_entity (int)
                  The local index of the entity relative to the cell.
              marker_value (T)
                  The value of the marker.

          *Returns*
              bool
                  True is a new value is inserted, false if overwriting
                  an existing value.

        * set_value\ (entity_index, value)

          Set value for given entity index

          *Arguments*
              entity_index (int)
                  Index of the entity.
              value (T)
                  The value of the marker.
              mesh (:py:class:`Mesh`)
                  The mesh.

          *Returns*
              bool
                  True is a new value is inserted, false if overwriting
                  an existing value.

        """
        return _mesh.MeshValueCollectionBool_set_value(self, *args)


    def get_value(self, cell_index, local_entity):
        """

        Get marker value for given entity defined by a cell index and
        a local entity index

        *Arguments*
            cell_index (int)
                The index of the cell.
            local_entity (int)
                The local index of the entity relative to the cell.

        *Returns*
            marker_value (T)
                The value of the marker.

        """
        return _mesh.MeshValueCollectionBool_get_value(self, cell_index, local_entity)


    def values(self, *args):
        """

        **Overloaded versions**

        * values\ ()

          Get all values

          *Returns*
              std::map<std::pair<std::size_t, std::size_t>, T>
                  A map from positions to values.

        * values\ ()

          Get all values (const version)

          *Returns*
              std::map<std::pair<std::size_t, std::size_t>, T>
                  A map from positions to values.

        """
        return _mesh.MeshValueCollectionBool_values(self, *args)


    def clear(self):
        """

        Clear all values

        """
        return _mesh.MeshValueCollectionBool_clear(self)


    def assign(self, *args):
        """Missing docstring"""
        return _mesh.MeshValueCollectionBool_assign(self, *args)

MeshValueCollectionBool.init = new_instancemethod(_mesh.MeshValueCollectionBool_init, None, MeshValueCollectionBool)
MeshValueCollectionBool.dim = new_instancemethod(_mesh.MeshValueCollectionBool_dim, None, MeshValueCollectionBool)
MeshValueCollectionBool.mesh = new_instancemethod(_mesh.MeshValueCollectionBool_mesh, None, MeshValueCollectionBool)
MeshValueCollectionBool.empty = new_instancemethod(_mesh.MeshValueCollectionBool_empty, None, MeshValueCollectionBool)
MeshValueCollectionBool.size = new_instancemethod(_mesh.MeshValueCollectionBool_size, None, MeshValueCollectionBool)
MeshValueCollectionBool.set_value = new_instancemethod(_mesh.MeshValueCollectionBool_set_value, None, MeshValueCollectionBool)
MeshValueCollectionBool.get_value = new_instancemethod(_mesh.MeshValueCollectionBool_get_value, None, MeshValueCollectionBool)
MeshValueCollectionBool.values = new_instancemethod(_mesh.MeshValueCollectionBool_values, None, MeshValueCollectionBool)
MeshValueCollectionBool.clear = new_instancemethod(_mesh.MeshValueCollectionBool_clear, None, MeshValueCollectionBool)
MeshValueCollectionBool.assign = new_instancemethod(_mesh.MeshValueCollectionBool_assign, None, MeshValueCollectionBool)
MeshValueCollectionBool_swigregister = _mesh.MeshValueCollectionBool_swigregister
MeshValueCollectionBool_swigregister(MeshValueCollectionBool)


_meshvaluecollection_doc_string = MeshValueCollectionInt.__doc__
_meshvaluecollection_doc_string += """
  *Arguments*
      tp (str)
         String defining the type of the MeshValueCollection
          Allowed: 'int', 'size_t', 'double', and 'bool'
      dim (unsigned int)
          The topological dimension of the MeshValueCollection.
          Optional.
      mesh_function (_MeshFunction_)
          The MeshValueCollection will get the values from the mesh_function
          Optional.
       mesh (Mesh)
          A mesh associated with the collection. The mesh is used to
          map collection values to the appropriate process.
          Optional, used when read from file.
      filename (std::string)
          The XML file name.
          Optional, used when read from file.
      dim (unsigned int)
          The mesh entity dimension for the mesh value collection.
          Optional, used when read from file
"""
class MeshValueCollection(object):
    __doc__ = _meshvaluecollection_doc_string
    def __new__(cls, tp, *args):
        if not isinstance(tp, str):
            raise TypeError("expected a 'str' as first argument")
        if tp == "int":
            return MeshValueCollectionInt(*args)
        if tp == "uint":
            from . import common
            common.deprecation("uint-valued MeshFunction", "1.1.0", "TBA",
                               "Typename \"uint\" has been changed to \"size_t\".")
            return MeshValueCollectionSizet(*args)
        elif tp == "size_t":
            return MeshValueCollectionSizet(*args)
        elif tp == "double":
            return MeshValueCollectionDouble(*args)
        elif tp == "bool":
            return MeshValueCollectionBool(*args)
        else:
            raise RuntimeError("Cannot create a MeshValueCollection of type '%s'." % (tp,))

del _meshvaluecollection_doc_string


HierarchicalMesh.leaf_node = new_instancemethod(_mesh.HierarchicalMesh__leaf_node,None,HierarchicalMesh)
HierarchicalMesh.root_node = new_instancemethod(_mesh.HierarchicalMesh__root_node,None,HierarchicalMesh)
HierarchicalMesh.child = new_instancemethod(_mesh.HierarchicalMesh__child,None,HierarchicalMesh)
HierarchicalMesh.parent = new_instancemethod(_mesh.HierarchicalMesh__parent,None,HierarchicalMesh)

class BoxMesh(Mesh):
    """

    Tetrahedral mesh of the 3D rectangular prism spanned by two
    points p0 and p1. Given the number of cells (nx, ny, nz) in
    each direction, the total number of tetrahedra will be
    6*nx*ny*nz and the total number of vertices will be
    (nx + 1)*(ny + 1)*(nz + 1).

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * BoxMesh\ (p0, p1, nx, ny, nz)

          Create a uniform finite element :py:class:`Mesh` over the rectangular
          prism spanned by the two _Point_s p0 and p1. The order of the
          two points is not important in terms of minimum and maximum
          coordinates.

          *Arguments*
              p0 (:py:class:`Point`)
                  First point.
              p1 (:py:class:`Point`)
                  Second point.
              nx (float)
                  Number of cells in :math:`x`-direction.
              ny (float)
                  Number of cells in :math:`y`-direction.
              nz (float)
                  Number of cells in :math:`z`-direction.

          *Example*
              .. note::

                  No example code available for this function.

        * BoxMesh\ (comm, p0, p1, nx, ny, nz)

          Create a uniform finite element :py:class:`Mesh` over the rectangular
          prism spanned by the two _Point_s p0 and p1. The order of the
          two points is not important in terms of minimum and maximum
          coordinates.

          *Arguments*
              comm (:py:class:`MPI`)
                  MPI communicator
              p0 (:py:class:`Point`)
                  First point.
              p1 (:py:class:`Point`)
                  Second point.
              nx (float)
                  Number of cells in :math:`x`-direction.
              ny (float)
                  Number of cells in :math:`y`-direction.
              nz (float)
                  Number of cells in :math:`z`-direction.

          *Example*
              .. note::

                  No example code available for this function.

        """
        _mesh.BoxMesh_swiginit(self, _mesh.new_BoxMesh(*args))
    __swig_destroy__ = _mesh.delete_BoxMesh
BoxMesh_swigregister = _mesh.BoxMesh_swigregister
BoxMesh_swigregister(BoxMesh)

class IntervalMesh(Mesh):
    """

    Interval mesh of the 1D line [a,b].  Given the number of cells
    (nx) in the axial direction, the total number of intervals will
    be nx and the total number of vertices will be (nx + 1).

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * IntervalMesh\ (nx, a, b)

          Constructor

          *Arguments*
              nx (int)
                  The number of cells.
              a (float)
                  The minimum point (inclusive).
              b (float)
                  The maximum point (inclusive).

          *Example*
              .. note::

                  No example code available for this function.

        * IntervalMesh\ (comm, nx, a, b)

          Constructor

          *Arguments*
              comm (:py:class:`MPI`)
                  MPI communicator
              nx (int)
                  The number of cells.
              a (float)
                  The minimum point (inclusive).
              b (float)
                  The maximum point (inclusive).

          *Example*
              .. note::

                  No example code available for this function.

        """
        _mesh.IntervalMesh_swiginit(self, _mesh.new_IntervalMesh(*args))
    __swig_destroy__ = _mesh.delete_IntervalMesh
IntervalMesh_swigregister = _mesh.IntervalMesh_swigregister
IntervalMesh_swigregister(IntervalMesh)

class RectangleMesh(Mesh):
    """

    Triangular mesh of the 2D rectangle spanned by two points p0 and
    p1. Given the number of cells (nx, ny) in each direction, the
    total number of triangles will be 2*nx*ny and the total number
    of vertices will be (nx + 1)*(ny + 1).

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * RectangleMesh\ (p0, p1, nx, ny, diagonal="right")

          *Arguments*
              p0 (:py:class:`Point`)
                  First point.
              p1 (:py:class:`Point`)
                  Second point.
              nx (float)
                  Number of cells in :math:`x`-direction.
              ny (float)
                  Number of cells in :math:`y`-direction.
              diagonal (str)
                  Direction of diagonals: "left", "right", "left/right", "crossed"

          *Example*
              .. note::

                  No example code available for this function.

        * RectangleMesh\ (comm, p0, p1, nx, ny, diagonal="right")

          *Arguments*
              comm (:py:class:`MPI`)
                  MPI communicator
              p0 (:py:class:`Point`)
                  First point.
              p1 (:py:class:`Point`)
                  Second point.
              nx (float)
                  Number of cells in :math:`x`-direction.
              ny (float)
                  Number of cells in :math:`y`-direction.
              diagonal (str)
                  Direction of diagonals: "left", "right", "left/right", "crossed"

          *Example*
              .. note::

                  No example code available for this function.

        """
        _mesh.RectangleMesh_swiginit(self, _mesh.new_RectangleMesh(*args))
    __swig_destroy__ = _mesh.delete_RectangleMesh
RectangleMesh_swigregister = _mesh.RectangleMesh_swigregister
RectangleMesh_swigregister(RectangleMesh)

class UnitTetrahedronMesh(Mesh):
    """

    A mesh consisting of a single tetrahedron with vertices at

      (0, 0, 0)
      (1, 0, 0)
      (0, 1, 0)
      (0, 0, 1)

    This class is useful for testing.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """

        Create mesh of unit tetrahedron

        """
        _mesh.UnitTetrahedronMesh_swiginit(self, _mesh.new_UnitTetrahedronMesh())
    __swig_destroy__ = _mesh.delete_UnitTetrahedronMesh
UnitTetrahedronMesh_swigregister = _mesh.UnitTetrahedronMesh_swigregister
UnitTetrahedronMesh_swigregister(UnitTetrahedronMesh)

class UnitCubeMesh(BoxMesh):
    """

    Tetrahedral mesh of the 3D unit cube [0,1] x [0,1] x [0,1].
    Given the number of cells (nx, ny, nz) in each direction,
    the total number of tetrahedra will be 6*nx*ny*nz and the
    total number of vertices will be (nx + 1)*(ny + 1)*(nz + 1).

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * UnitCubeMesh\ (nx, ny, nz)

          Create a uniform finite element :py:class:`Mesh` over the unit cube
          [0,1] x [0,1] x [0,1].

          *Arguments*
              nx (int)
                  Number of cells in :math:`x` direction.
              ny (int)
                  Number of cells in :math:`y` direction.
              nz (int)
                  Number of cells in :math:`z` direction.

          *Example*
              .. note::

                  No example code available for this function.

        * UnitCubeMesh\ (comm, nx, ny, nz)

          Create a uniform finite element :py:class:`Mesh` over the unit cube
          [0,1] x [0,1] x [0,1].

          *Arguments*
              comm (:py:class:`MPI`)
                  MPI communicator
              nx (int)
                  Number of cells in :math:`x` direction.
              ny (int)
                  Number of cells in :math:`y` direction.
              nz (int)
                  Number of cells in :math:`z` direction.

          *Example*
              .. note::

                  No example code available for this function.

        """
        _mesh.UnitCubeMesh_swiginit(self, _mesh.new_UnitCubeMesh(*args))
    __swig_destroy__ = _mesh.delete_UnitCubeMesh
UnitCubeMesh_swigregister = _mesh.UnitCubeMesh_swigregister
UnitCubeMesh_swigregister(UnitCubeMesh)

class UnitIntervalMesh(IntervalMesh):
    """

    A mesh of the unit interval (0, 1) with a given number of cells
    (nx) in the axial direction. The total number of intervals will
    be nx and the total number of vertices will be (nx + 1).

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * UnitIntervalMesh\ (nx)

          Constructor

          *Arguments*
              nx (int)
                  The number of cells.

          *Example*
              .. note::

                  No example code available for this function.

        * UnitIntervalMesh\ (comm, nx)

          Constructor

          *Arguments*
              comm (:py:class:`MPI`)
                  MPI communicator
              nx (int)
                  The number of cells.

          *Example*
              .. note::

                  No example code available for this function.

        """
        _mesh.UnitIntervalMesh_swiginit(self, _mesh.new_UnitIntervalMesh(*args))
    __swig_destroy__ = _mesh.delete_UnitIntervalMesh
UnitIntervalMesh_swigregister = _mesh.UnitIntervalMesh_swigregister
UnitIntervalMesh_swigregister(UnitIntervalMesh)

class UnitTriangleMesh(Mesh):
    """

    A mesh consisting of a single triangle with vertices at

      (0, 0)
      (1, 0)
      (0, 1)

    This class is useful for testing.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """

        Create mesh of unit triangle

        """
        _mesh.UnitTriangleMesh_swiginit(self, _mesh.new_UnitTriangleMesh())
    __swig_destroy__ = _mesh.delete_UnitTriangleMesh
UnitTriangleMesh_swigregister = _mesh.UnitTriangleMesh_swigregister
UnitTriangleMesh_swigregister(UnitTriangleMesh)

class UnitSquareMesh(RectangleMesh):
    """

    Triangular mesh of the 2D unit square [0,1] x [0,1].
    Given the number of cells (nx, ny) in each direction,
    the total number of triangles will be 2*nx*ny and the
    total number of vertices will be (nx + 1)*(ny + 1).

    std::string diagonal ("left", "right", "right/left", "left/right",
    or "crossed") indicates the direction of the diagonals.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * UnitSquareMesh\ (nx, ny, diagonal="right")

          Create a uniform finite element :py:class:`Mesh` over the unit square
          [0,1] x [0,1].

          *Arguments*
              nx (int)
                  Number of cells in horizontal direction.
              ny (int)
                  Number of cells in vertical direction.
              diagonal (str)
                  Optional argument: A std::string indicating
                  the direction of the diagonals.

          *Example*
              .. note::

                  No example code available for this function.

        * UnitSquareMesh\ (comm, nx, ny, diagonal="right")

          Create a uniform finite element :py:class:`Mesh` over the unit square
          [0,1] x [0,1].

          *Arguments*
              comm (:py:class:`MPI`)
                  MPI communicator
              nx (int)
                  Number of cells in horizontal direction.
              ny (int)
                  Number of cells in vertical direction.
              diagonal (str)
                  Optional argument: A std::string indicating
                  the direction of the diagonals.

          *Example*
              .. note::

                  No example code available for this function.

        """
        _mesh.UnitSquareMesh_swiginit(self, _mesh.new_UnitSquareMesh(*args))
    __swig_destroy__ = _mesh.delete_UnitSquareMesh
UnitSquareMesh_swigregister = _mesh.UnitSquareMesh_swigregister
UnitSquareMesh_swigregister(UnitSquareMesh)

class UnitQuadMesh(Mesh):
    """

    NB: this code is experimental, just for testing, and will generally not
    work with anything else

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, nx, ny):
        """

        NB: this code is experimental, just for testing, and will generally not
        work with anything else

        """
        _mesh.UnitQuadMesh_swiginit(self, _mesh.new_UnitQuadMesh(nx, ny))
    __swig_destroy__ = _mesh.delete_UnitQuadMesh
UnitQuadMesh_swigregister = _mesh.UnitQuadMesh_swigregister
UnitQuadMesh_swigregister(UnitQuadMesh)

class UnitHexMesh(Mesh):
    """

    NB: this code is experimental, just for testing, and will generally not
    work with anything else

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, nx, ny, nz):
        """

        NB: this code is experimental, just for testing, and will generally not
        work with anything else

        """
        _mesh.UnitHexMesh_swiginit(self, _mesh.new_UnitHexMesh(nx, ny, nz))
    __swig_destroy__ = _mesh.delete_UnitHexMesh
UnitHexMesh_swigregister = _mesh.UnitHexMesh_swigregister
UnitHexMesh_swigregister(UnitHexMesh)

class Point(object):
    """

    A Point represents a point in :math:`\mathbb{R}^3` with
    coordinates :math:`x, y, z,` or alternatively, a vector in
    :math:`\mathbb{R}^3`, supporting standard operations like the
    norm, distances, scalar and vector products etc.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * Point\ (x=0.0, y=0.0, z=0.0)

          Create a point at (x, y, z). Default value (0, 0, 0).

          *Arguments*
              x (float)
                  The x-coordinate.
              y (float)
                  The y-coordinate.
              z (float)
                  The z-coordinate.

        * Point\ (dim, x)

          Create point from array

          *Arguments*
              dim (int)
                  Dimension of the array.
              x (float)
                  The array to create a Point from.

        * Point\ (x)

          Create point from Array

          *Arguments*
              x (Array<double>)
                  Array of coordinates.

        * Point\ (p)

          Copy constructor

          *Arguments*
              p (:py:class:`Point`)
                  The object to be copied.

        """
        _mesh.Point_swiginit(self, _mesh.new_Point(*args))
    __swig_destroy__ = _mesh.delete_Point

    def x(self):
        """

        Return x-coordinate

        *Returns*
            float
                The x-coordinate.

        """
        return _mesh.Point_x(self)


    def y(self):
        """

        Return y-coordinate

        *Returns*
            float
                The y-coordinate.

        """
        return _mesh.Point_y(self)


    def z(self):
        """

        Return z-coordinate

        *Returns*
            float
                The z-coordinate.

        """
        return _mesh.Point_z(self)


    def coordinates(self, *args):
        """

        **Overloaded versions**

        * coordinates\ ()

          Return coordinate array

          *Returns*
              list of doubles
                  The coordinates.

        * coordinates\ ()

          Return coordinate array (const. version)

          *Returns*
              list of doubles
                  The coordinates.

        """
        return _mesh.Point_coordinates(self, *args)


    def __add__(self, p):
        """

        Compute sum of two points

        """
        return _mesh.Point___add__(self, p)


    def __sub__(self, p):
        """

        **Overloaded versions**

        * operator-\ (p)

          Compute difference of two points

        * operator-\ ()

          Unary minus

        """
        return _mesh.Point___sub__(self, p)


    def __iadd__(self, p):
        """

        Add given point

        """
        return _mesh.Point___iadd__(self, p)


    def __isub__(self, p):
        """

        Subtract given point

        """
        return _mesh.Point___isub__(self, p)


    def __neg__(self):
        """

        **Overloaded versions**

        * operator-\ (p)

          Compute difference of two points

        * operator-\ ()

          Unary minus

        """
        return _mesh.Point___neg__(self)


    def __mul__(self, a):
        """

        **Overloaded versions**

        * operator*\ (a)

          Multiplication with scalar

        * operator*\ (a, p)

          Multiplication with scalar

        """
        return _mesh.Point___mul__(self, a)


    def __imul__(self, a):
        """

        Incremental multiplication with scalar

        """
        return _mesh.Point___imul__(self, a)


    def __div__(self, a):
        """

        Division by scalar

        """
        return _mesh.Point___div__(self, a)


    def __idiv__(self, a):
        """

        Incremental division by scalar

        """
        return _mesh.Point___idiv__(self, a)


    def squared_distance(self, p):
        """

        Compute squared distance to given point

        *Arguments*
            p (:py:class:`Point`)
                The point to compute distance to.

        *Returns*
            float
                The squared distance.

        *Example*
            .. note::

                No example code available for this function.

        """
        return _mesh.Point_squared_distance(self, p)


    def distance(self, p):
        """

        Compute distance to given point

        *Arguments*
            p (:py:class:`Point`)
                The point to compute distance to.

        *Returns*
            float
                The distance.

        *Example*
            .. note::

                No example code available for this function.

        """
        return _mesh.Point_distance(self, p)


    def norm(self):
        """

        Compute norm of point representing a vector from the origin

        *Returns*
            float
                The (Euclidean) norm of the vector from the origin to
                the point.

        *Example*
            .. note::

                No example code available for this function.

        """
        return _mesh.Point_norm(self)


    def squared_norm(self):
        """

        Compute norm of point representing a vector from the origin

        *Returns*
            float
                The squared (Euclidean) norm of the vector from the
                origin of the point.

        *Example*
            .. note::

                No example code available for this function.

        """
        return _mesh.Point_squared_norm(self)


    def cross(self, p):
        """

        Compute cross product with given vector

        *Arguments*
            p (:py:class:`Point`)
                Another point.

        *Returns*
            Point
                The cross product.

        """
        return _mesh.Point_cross(self, p)


    def dot(self, p):
        """

        Compute dot product with given vector

        *Arguments*
            p (:py:class:`Point`)
                Another point.

        *Returns*
            float
                The dot product.

        *Example*
            .. note::

                No example code available for this function.

        """
        return _mesh.Point_dot(self, p)


    def rotate(self, a, theta):
        """

        Rotate around a given axis

        *Arguments*
            a (:py:class:`Point`)
                The axis to rotate around. Must be unit length.
            theta (_double_)
                The rotation angle.

        *Returns*
            Point
                The rotated point.

        """
        return _mesh.Point_rotate(self, a, theta)


    def str(self, verbose=False):
        """

        Return informal string representation (pretty-print)

        *Arguments*
            verbose (bool)
                Flag to turn on additional output.

        *Returns*
            str
                An informal representation of the function space.

        """
        return _mesh.Point_str(self, verbose)


    __truediv__ = __div__
    __itruediv__ = __idiv__


    def __getitem__(self, i):
        """Missing docstring"""
        return _mesh.Point___getitem__(self, i)


    def __setitem__(self, i, val):
        """Missing docstring"""
        return _mesh.Point___setitem__(self, i, val)

Point.x = new_instancemethod(_mesh.Point_x, None, Point)
Point.y = new_instancemethod(_mesh.Point_y, None, Point)
Point.z = new_instancemethod(_mesh.Point_z, None, Point)
Point.coordinates = new_instancemethod(_mesh.Point_coordinates, None, Point)
Point.__add__ = new_instancemethod(_mesh.Point___add__, None, Point)
Point.__sub__ = new_instancemethod(_mesh.Point___sub__, None, Point)
Point.__iadd__ = new_instancemethod(_mesh.Point___iadd__, None, Point)
Point.__isub__ = new_instancemethod(_mesh.Point___isub__, None, Point)
Point.__neg__ = new_instancemethod(_mesh.Point___neg__, None, Point)
Point.__mul__ = new_instancemethod(_mesh.Point___mul__, None, Point)
Point.__imul__ = new_instancemethod(_mesh.Point___imul__, None, Point)
Point.__div__ = new_instancemethod(_mesh.Point___div__, None, Point)
Point.__idiv__ = new_instancemethod(_mesh.Point___idiv__, None, Point)
Point.squared_distance = new_instancemethod(_mesh.Point_squared_distance, None, Point)
Point.distance = new_instancemethod(_mesh.Point_distance, None, Point)
Point.norm = new_instancemethod(_mesh.Point_norm, None, Point)
Point.squared_norm = new_instancemethod(_mesh.Point_squared_norm, None, Point)
Point.cross = new_instancemethod(_mesh.Point_cross, None, Point)
Point.dot = new_instancemethod(_mesh.Point_dot, None, Point)
Point.rotate = new_instancemethod(_mesh.Point_rotate, None, Point)
Point.str = new_instancemethod(_mesh.Point_str, None, Point)
Point.__getitem__ = new_instancemethod(_mesh.Point___getitem__, None, Point)
Point.__setitem__ = new_instancemethod(_mesh.Point___setitem__, None, Point)
Point_swigregister = _mesh.Point_swigregister
Point_swigregister(Point)


def __mul__(a, p):
    return _mesh.__mul__(a, p)
__mul__ = _mesh.__mul__

def __lshift__(stream, point):
    return _mesh.__lshift__(stream, point)
__lshift__ = _mesh.__lshift__
class BoundingBoxTree(object):
    """

    This class implements a (distributed) axis aligned bounding box
    tree (AABB tree). Bounding box trees can be created from meshes
    and [other data structures, to be filled in].

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """

        Create empty bounding box tree

        """
        _mesh.BoundingBoxTree_swiginit(self, _mesh.new_BoundingBoxTree())
    __swig_destroy__ = _mesh.delete_BoundingBoxTree

    def build(self, *args):
        """

        **Overloaded versions**

        * build\ (mesh)

          Build bounding box tree for cells of mesh.

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh for which to compute the bounding box tree.

        * build\ (mesh, tdim)

          Build bounding box tree for mesh entities of given dimension.

          *Arguments*
              mesh (:py:class:`Mesh`)
                  The mesh for which to compute the bounding box tree.
              dimension (int)
                  The entity dimension (topological dimension) for which
                  to compute the bounding box tree.

        * build\ (points, gdim)

          Build bounding box tree for point cloud.

          *Arguments*
              points (list of :py:class:`Point`)
                  The list of points.
              gdim (int)
                  The geometric dimension.

        """
        return _mesh.BoundingBoxTree_build(self, *args)


    def compute_collisions(self, *args):
        """

        **Overloaded versions**

        * compute_collisions\ (point)

          Compute all collisions between bounding boxes and :py:class:`Point`.

          *Returns*
              numpy.array(int)
                  A list of local indices for entities contained in
                  (leaf) bounding boxes that collide with (intersect)
                  the given point.

          *Arguments*
              point (:py:class:`Point`)
                  The point.

        * compute_collisions\ (tree)

          Compute all collisions between bounding boxes and :py:class:`BoundingBoxTree`.

          *Returns*
              numpy.array(int)
                  A list of local indices for entities in this tree that
                  collide with (intersect) entities in other tree.
              std::vector<unsigned int>
                  A list of local indices for entities in other tree that
                  collide with (intersect) entities in this tree.

          The two lists have equal length and contain matching entities,
          such that entity `i` in the first list collides with entity
          `i` in the second list.

          Note that this means that the entity lists may contain
          duplicate entities since a single entity may collide with
          several different entities.

          *Arguments*
              tree (:py:class:`BoundingBoxTree`)
                  The bounding box tree.

          Note that this function only checks collisions between bounding
          boxes of entities. It does not check that the entities
          themselves actually collide. To compute entity collisions, use
          the function compute_entity_collisions.

        """
        return _mesh.BoundingBoxTree_compute_collisions(self, *args)


    def compute_entity_collisions(self, *args):
        """

        **Overloaded versions**

        * compute_entity_collisions\ (point)

          Compute all collisions between entities and :py:class:`Point`.

          *Returns*
              numpy.array(int)
                  A list of local indices for entities that collide with
                  (intersect) the given point.

          *Arguments*
              point (:py:class:`Point`)
                  The point.

        * compute_entity_collisions\ (tree)

          Compute all collisions between entities and :py:class:`BoundingBoxTree`.

          *Returns*
              numpy.array(int)
                  A list of local indices for entities in this tree that
                  collide with (intersect) entities in other tree.
              std::vector<unsigned int>
                  A list of local indices for entities in other tree that
                  collide with (intersect) entities in this tree.

          The two lists have equal length and contain matching entities,
          such that entity `i` in the first list collides with entity
          `i` in the second list.

          Note that this means that the entity lists may contain
          duplicate entities since a single entity may collide with
          several different entities.

          *Arguments*
              tree (:py:class:`BoundingBoxTree`)
                  The bounding box tree.

        """
        return _mesh.BoundingBoxTree_compute_entity_collisions(self, *args)


    def compute_first_collision(self, point):
        """

        Compute first collision between bounding boxes and :py:class:`Point`.

        *Returns*
            int
                The local index for the first found entity contained
                in a (leaf) bounding box that collides with
                (intersects) the given point. If not found,
                std::numeric_limits<unsigned int>::max() is returned.

        *Arguments*
            point (:py:class:`Point`)
                The point.

        """
        return _mesh.BoundingBoxTree_compute_first_collision(self, point)


    def compute_first_entity_collision(self, point):
        """

        Compute first collision between entities and :py:class:`Point`.

        *Returns*
            int
                The local index for the first found entity that
                collides with (intersects) the given point. If not
                found, std::numeric_limits<unsigned int>::max() is
                returned.

        *Arguments*
            point (:py:class:`Point`)
                The point.

        """
        return _mesh.BoundingBoxTree_compute_first_entity_collision(self, point)


    def compute_closest_entity(self, point):
        """

        Compute closest entity to :py:class:`Point`.

        *Returns*
            int
                The local index for the entity that is closest to the
                point. If more than one entity is at the same distance
                (or point contained in entity), then the first entity
                is returned.
            double
                The distance to the closest entity.

        *Arguments*
            point (:py:class:`Point`)
                The point.

        """
        return _mesh.BoundingBoxTree_compute_closest_entity(self, point)


    def compute_closest_point(self, point):
        """

        Compute closest point to :py:class:`Point`. This function assumes
        that the tree has been built for a point cloud.

        Developer note: This function should not be confused with
        computing the closest point in all entities of a mesh. That
        function could be added with relative ease since we actually
        compute the closest points to get the distance in the above
        function (compute_closest_entity) inside the specialized
        implementations in TetrahedronCell.cpp etc.

        *Returns*
            int
                The local index for the point that is closest to the
                point. If more than one point is at the same distance
                (or point contained in entity), then the first point
                is returned.
            double
                The distance to the closest point.

        *Arguments*
            point (:py:class:`Point`)
                The point.

        """
        return _mesh.BoundingBoxTree_compute_closest_point(self, point)


    def collides(self, point):
        """

        Check whether given point collides with the bounding box tree.
        This is equivalent to calling compute_first_collision and
        checking whether any collision was detected.

        *Returns*
            bool
                True iff the point is inside the tree.

        """
        return _mesh.BoundingBoxTree_collides(self, point)


    def collides_entity(self, point):
        """

        Check whether given point collides with any entity contained
        in the bounding box tree. This is equivalent to calling
        compute_first_entity_collision and checking whether any
        collision was detected.

        *Returns*
            bool
                True iff the point is inside the tree.

        """
        return _mesh.BoundingBoxTree_collides_entity(self, point)

BoundingBoxTree.build = new_instancemethod(_mesh.BoundingBoxTree_build, None, BoundingBoxTree)
BoundingBoxTree.compute_collisions = new_instancemethod(_mesh.BoundingBoxTree_compute_collisions, None, BoundingBoxTree)
BoundingBoxTree.compute_entity_collisions = new_instancemethod(_mesh.BoundingBoxTree_compute_entity_collisions, None, BoundingBoxTree)
BoundingBoxTree.compute_first_collision = new_instancemethod(_mesh.BoundingBoxTree_compute_first_collision, None, BoundingBoxTree)
BoundingBoxTree.compute_first_entity_collision = new_instancemethod(_mesh.BoundingBoxTree_compute_first_entity_collision, None, BoundingBoxTree)
BoundingBoxTree.compute_closest_entity = new_instancemethod(_mesh.BoundingBoxTree_compute_closest_entity, None, BoundingBoxTree)
BoundingBoxTree.compute_closest_point = new_instancemethod(_mesh.BoundingBoxTree_compute_closest_point, None, BoundingBoxTree)
BoundingBoxTree.collides = new_instancemethod(_mesh.BoundingBoxTree_collides, None, BoundingBoxTree)
BoundingBoxTree.collides_entity = new_instancemethod(_mesh.BoundingBoxTree_collides_entity, None, BoundingBoxTree)
BoundingBoxTree_swigregister = _mesh.BoundingBoxTree_swigregister
BoundingBoxTree_swigregister(BoundingBoxTree)

class GenericBoundingBoxTree(object):
    """

    Base class for bounding box implementations (envelope-letter
    design)

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _mesh.delete_GenericBoundingBoxTree

    def build(self, *args):
        """

        **Overloaded versions**

        * build\ (mesh, tdim)

          Build bounding box tree for mesh entities of given dimension

        * build\ (points)

          Build bounding box tree for point cloud

        """
        return _mesh.GenericBoundingBoxTree_build(self, *args)


    def compute_collisions(self, *args):
        """

        **Overloaded versions**

        * compute_collisions\ (point)

          Compute all collisions between bounding boxes and :py:class:`Point`

        * compute_collisions\ (tree)

          Compute all collisions between bounding boxes and :py:class:`BoundingBoxTree`

        """
        return _mesh.GenericBoundingBoxTree_compute_collisions(self, *args)


    def compute_entity_collisions(self, *args):
        """

        **Overloaded versions**

        * compute_entity_collisions\ (point, mesh)

          Compute all collisions between entities and :py:class:`Point`

        * compute_entity_collisions\ (tree, mesh_A, mesh_B)

          Compute all collisions between entities and :py:class:`BoundingBoxTree`

        """
        return _mesh.GenericBoundingBoxTree_compute_entity_collisions(self, *args)


    def compute_first_collision(self, point):
        """

        Compute first collision between bounding boxes and :py:class:`Point`

        """
        return _mesh.GenericBoundingBoxTree_compute_first_collision(self, point)


    def compute_first_entity_collision(self, point, mesh):
        """

        Compute first collision between entities and :py:class:`Point`

        """
        return _mesh.GenericBoundingBoxTree_compute_first_entity_collision(self, point, mesh)


    def compute_closest_entity(self, point, mesh):
        """

        Compute closest entity and distance to :py:class:`Point`

        """
        return _mesh.GenericBoundingBoxTree_compute_closest_entity(self, point, mesh)


    def compute_closest_point(self, point):
        """

        Compute closest point and distance to :py:class:`Point`

        """
        return _mesh.GenericBoundingBoxTree_compute_closest_point(self, point)

GenericBoundingBoxTree.build = new_instancemethod(_mesh.GenericBoundingBoxTree_build, None, GenericBoundingBoxTree)
GenericBoundingBoxTree.compute_collisions = new_instancemethod(_mesh.GenericBoundingBoxTree_compute_collisions, None, GenericBoundingBoxTree)
GenericBoundingBoxTree.compute_entity_collisions = new_instancemethod(_mesh.GenericBoundingBoxTree_compute_entity_collisions, None, GenericBoundingBoxTree)
GenericBoundingBoxTree.compute_first_collision = new_instancemethod(_mesh.GenericBoundingBoxTree_compute_first_collision, None, GenericBoundingBoxTree)
GenericBoundingBoxTree.compute_first_entity_collision = new_instancemethod(_mesh.GenericBoundingBoxTree_compute_first_entity_collision, None, GenericBoundingBoxTree)
GenericBoundingBoxTree.compute_closest_entity = new_instancemethod(_mesh.GenericBoundingBoxTree_compute_closest_entity, None, GenericBoundingBoxTree)
GenericBoundingBoxTree.compute_closest_point = new_instancemethod(_mesh.GenericBoundingBoxTree_compute_closest_point, None, GenericBoundingBoxTree)
GenericBoundingBoxTree_swigregister = _mesh.GenericBoundingBoxTree_swigregister
GenericBoundingBoxTree_swigregister(GenericBoundingBoxTree)

class BoundingBoxTree3D(GenericBoundingBoxTree):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _mesh.delete_BoundingBoxTree3D
BoundingBoxTree3D_swigregister = _mesh.BoundingBoxTree3D_swigregister
BoundingBoxTree3D_swigregister(BoundingBoxTree3D)

class MeshPointIntersection(object):
    """

    This class represents an intersection between a :py:class:`Mesh` and a
    :py:class:`Point`. The resulting intersection is stored as a list of zero
    or more cells.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, mesh, point):
        """

        Compute intersection between mesh and point

        """
        _mesh.MeshPointIntersection_swiginit(self, _mesh.new_MeshPointIntersection(mesh, point))
    __swig_destroy__ = _mesh.delete_MeshPointIntersection

    def intersected_cells(self):
        """

        Return the list of (local) indices for intersected cells

        """
        return _mesh.MeshPointIntersection_intersected_cells(self)

MeshPointIntersection.intersected_cells = new_instancemethod(_mesh.MeshPointIntersection_intersected_cells, None, MeshPointIntersection)
MeshPointIntersection_swigregister = _mesh.MeshPointIntersection_swigregister
MeshPointIntersection_swigregister(MeshPointIntersection)


def intersect(mesh, point):
    """

    Compute and return intersection between :py:class:`Mesh` and :py:class:`Point`.

    *Arguments*
        mesh (:py:class:`Mesh`)
            The mesh to be intersected.
        point (:py:class:`Point`)
            The point to be intersected.

    *Returns*
        :py:class:`MeshPointIntersection`
            The intersection data.

    """
    return _mesh.intersect(mesh, point)

def refine(*args):
    """

    **Overloaded versions**

    * refine\ (mesh, true)

      Create uniformly refined mesh

      *Arguments*
          mesh (:py:class:`Mesh`)
              The mesh to refine.
          redistribute (_bool_)
              Optional argument to redistribute the refined mesh if mesh is a
              distributed mesh.

      *Returns*
          :py:class:`Mesh`
              The refined mesh.

      *Example*
          .. note::

              No example code available for this function.

    * refine\ (hierarchy, markers)

      Refine a MeshHierarchy

    * refine\ (refined_mesh, mesh, true)

      Create uniformly refined mesh

      *Arguments*
          refined_mesh (:py:class:`Mesh`)
              The mesh that will be the refined mesh.
          mesh (:py:class:`Mesh`)
              The original mesh.
          redistribute (_bool_)
              Optional argument to redistribute the refined mesh if mesh is a
              distributed mesh.

    * refine\ (mesh, cell_markers, true)

      Create locally refined mesh

      *Arguments*
          mesh (:py:class:`Mesh`)
              The mesh to refine.
          cell_markers (:py:class:`MeshFunction`)
              A mesh function over booleans specifying which cells
              that should be refined (and which should not).
          redistribute (_bool_)
              Optional argument to redistribute the refined mesh if mesh is a
              distributed mesh.

      *Returns*
          :py:class:`Mesh`
              The locally refined mesh.

      *Example*
          .. note::

              No example code available for this function.

    * refine\ (refined_mesh, mesh, cell_markers, true)

      Create locally refined mesh

      *Arguments*
          refined_mesh (:py:class:`Mesh`)
              The mesh that will be the refined mesh.
          mesh (:py:class:`Mesh`)
              The original mesh.
          cell_markers (:py:class:`MeshFunction`)
              A mesh function over booleans specifying which cells
              that should be refined (and which should not).
          redistribute (_bool_)
              Optional argument to redistribute the refined mesh if mesh is a
              distributed mesh.

    """
    return _mesh.refine(*args)
class GraphBuilder(object):
    """

    This class builds a Graph corresponding to various objects

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def local_graph(*args):
        """

        **Overloaded versions**

        * local_graph\ (mesh, dofmap0, dofmap1)

          Build local graph from dofmap

        * local_graph\ (mesh, coloring_type)

          Build local graph from mesh (general version)

        * local_graph\ (mesh, dim0, dim1)

          Build local graph (specialized version)

        """
        return _mesh.GraphBuilder_local_graph(*args)

    local_graph = staticmethod(local_graph)

    def compute_dual_graph(mpi_comm, mesh_data, local_graph, ghost_vertices):
        """

        Build distributed dual graph (cell-cell connections) for from
        LocalMeshData

        """
        return _mesh.GraphBuilder_compute_dual_graph(mpi_comm, mesh_data, local_graph, ghost_vertices)

    compute_dual_graph = staticmethod(compute_dual_graph)

    def __init__(self):
        _mesh.GraphBuilder_swiginit(self, _mesh.new_GraphBuilder())
    __swig_destroy__ = _mesh.delete_GraphBuilder
GraphBuilder_swigregister = _mesh.GraphBuilder_swigregister
GraphBuilder_swigregister(GraphBuilder)

def GraphBuilder_local_graph(*args):
    """

    **Overloaded versions**

    * local_graph\ (mesh, dofmap0, dofmap1)

      Build local graph from dofmap

    * local_graph\ (mesh, coloring_type)

      Build local graph from mesh (general version)

    * local_graph\ (mesh, dim0, dim1)

      Build local graph (specialized version)

    """
    return _mesh.GraphBuilder_local_graph(*args)

def GraphBuilder_compute_dual_graph(mpi_comm, mesh_data, local_graph, ghost_vertices):
    """

    Build distributed dual graph (cell-cell connections) for from
    LocalMeshData

    """
    return _mesh.GraphBuilder_compute_dual_graph(mpi_comm, mesh_data, local_graph, ghost_vertices)

class BoostGraphOrdering(object):
    """

    This class computes graph re-orderings. It uses Boost Graph.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def compute_cuthill_mckee(*args):
        """

        **Overloaded versions**

        * compute_cuthill_mckee\ (graph, reverse=false)

          Compute re-ordering (map[old] -> new) using Cuthill-McKee algorithm

        * compute_cuthill_mckee\ (edges, size, reverse=false)

          Compute re-ordering (map[old] -> new) using Cuthill-McKee algorithm

        """
        return _mesh.BoostGraphOrdering_compute_cuthill_mckee(*args)

    compute_cuthill_mckee = staticmethod(compute_cuthill_mckee)

    def __init__(self):
        _mesh.BoostGraphOrdering_swiginit(self, _mesh.new_BoostGraphOrdering())
    __swig_destroy__ = _mesh.delete_BoostGraphOrdering
BoostGraphOrdering_swigregister = _mesh.BoostGraphOrdering_swigregister
BoostGraphOrdering_swigregister(BoostGraphOrdering)

def BoostGraphOrdering_compute_cuthill_mckee(*args):
    """

    **Overloaded versions**

    * compute_cuthill_mckee\ (graph, reverse=false)

      Compute re-ordering (map[old] -> new) using Cuthill-McKee algorithm

    * compute_cuthill_mckee\ (edges, size, reverse=false)

      Compute re-ordering (map[old] -> new) using Cuthill-McKee algorithm

    """
    return _mesh.BoostGraphOrdering_compute_cuthill_mckee(*args)

class SCOTCH(object):
    """

    This class provides an interface to SCOTCH-PT (parallel version)

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def compute_partition(mpi_comm, cell_partition, ghost_procs, mesh_data):
        """

        Compute cell partition from local mesh data.  The vector
        cell_partition contains the desired destination process
        numbers for each cell.  Cells shared on multiple processes
        have an entry in ghost_procs pointing to the set of sharing
        process numbers.

        """
        return _mesh.SCOTCH_compute_partition(mpi_comm, cell_partition, ghost_procs, mesh_data)

    compute_partition = staticmethod(compute_partition)

    def compute_gps(graph, num_passes=5):
        """

        Compute reordering (map[old] -> new) using
        Gibbs-Poole-Stockmeyer re-ordering

        """
        return _mesh.SCOTCH_compute_gps(graph, num_passes)

    compute_gps = staticmethod(compute_gps)
    compute_reordering = staticmethod(_mesh.SCOTCH_compute_reordering)

    def __init__(self):
        _mesh.SCOTCH_swiginit(self, _mesh.new_SCOTCH())
    __swig_destroy__ = _mesh.delete_SCOTCH
SCOTCH_swigregister = _mesh.SCOTCH_swigregister
SCOTCH_swigregister(SCOTCH)

def SCOTCH_compute_partition(mpi_comm, cell_partition, ghost_procs, mesh_data):
    """

    Compute cell partition from local mesh data.  The vector
    cell_partition contains the desired destination process
    numbers for each cell.  Cells shared on multiple processes
    have an entry in ghost_procs pointing to the set of sharing
    process numbers.

    """
    return _mesh.SCOTCH_compute_partition(mpi_comm, cell_partition, ghost_procs, mesh_data)

def SCOTCH_compute_gps(graph, num_passes=5):
    """

    Compute reordering (map[old] -> new) using
    Gibbs-Poole-Stockmeyer re-ordering

    """
    return _mesh.SCOTCH_compute_gps(graph, num_passes)

def SCOTCH_compute_reordering(*args):
    return _mesh.SCOTCH_compute_reordering(*args)
SCOTCH_compute_reordering = _mesh.SCOTCH_compute_reordering

class Graph(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        _mesh.Graph_swiginit(self, _mesh.new_Graph())
    __swig_destroy__ = _mesh.delete_Graph
Graph_swigregister = _mesh.Graph_swigregister
Graph_swigregister(Graph)



