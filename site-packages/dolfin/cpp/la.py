# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _la.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_la', [dirname(__file__)])
        except ImportError:
            import _la
            return _la
        if fp is not None:
            try:
                _mod = imp.load_module('_la', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _la = swig_import_helper()
    del swig_import_helper
else:
    import _la
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0



def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except Exception:
    weakref_proxy = lambda x: x



_la.SHARED_PTR_DISOWN_swigconstant(_la)
SHARED_PTR_DISOWN = _la.SHARED_PTR_DISOWN
import ufc

def _attach_base_to_numpy_array(obj, owner):
    return _la._attach_base_to_numpy_array(obj, owner)
_attach_base_to_numpy_array = _la._attach_base_to_numpy_array

def dolfin_swigversion():
    return _la.dolfin_swigversion()
dolfin_swigversion = _la.dolfin_swigversion

def dolfin_pythonversion():
    return _la.dolfin_pythonversion()
dolfin_pythonversion = _la.dolfin_pythonversion

tmp = hex(dolfin_swigversion())
__swigversion__ = "%d.%d.%d"%(tuple(map(int, [tmp[-5], tmp[-3], tmp[-2:]])))
tmp = hex(dolfin_pythonversion())
__pythonversion__ = "%d.%d.%d"%(tuple(map(lambda x: int(x,16), [tmp[2], tmp[3:5], tmp[5:7]])))
del tmp, dolfin_pythonversion, dolfin_swigversion


def has_petsc4py():
    return _la.has_petsc4py()
has_petsc4py = _la.has_petsc4py

def has_slepc4py():
    return _la.has_slepc4py()
has_slepc4py = _la.has_slepc4py
import common
class LinearAlgebraObject(common.Variable):
    """

    This is a common base class for all DOLFIN linear algebra
    objects. In particular, it provides casting mechanisms between
    different types.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def shared_instance(self, *args):
        """

        **Overloaded versions**

        * shared_instance\ ()

          Return concrete shared ptr instance / unwrap (const version)

        * shared_instance\ ()

          Return concrete shared ptr instance / unwrap (non-const version)

        """
        return _la.LinearAlgebraObject_shared_instance(self, *args)


    def __init__(self):
        _la.LinearAlgebraObject_swiginit(self, _la.new_LinearAlgebraObject())
    __swig_destroy__ = _la.delete_LinearAlgebraObject
LinearAlgebraObject.shared_instance = new_instancemethod(_la.LinearAlgebraObject_shared_instance, None, LinearAlgebraObject)
LinearAlgebraObject_swigregister = _la.LinearAlgebraObject_swigregister
LinearAlgebraObject_swigregister(LinearAlgebraObject)

class GenericLinearOperator(LinearAlgebraObject):
    """

    This class defines a common interface for linear operators,
    including actual matrices (class :py:class:`GenericMatrix`) and linear
    operators only defined in terms of their action on vectors.

    This class is used internally by DOLFIN to define a class
    hierarchy of backend independent linear operators and solvers.
    Users should not interface to this class directly but instead
    use the :py:class:`LinearOperator` class.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _la.delete_GenericLinearOperator

    def size(self, dim):
        """

        Return size of given dimension

        """
        return _la.GenericLinearOperator_size(self, dim)


    def mult(self, x, y):
        """

        Compute matrix-vector product y = Ax

        """
        return _la.GenericLinearOperator_mult(self, x, y)

GenericLinearOperator.size = new_instancemethod(_la.GenericLinearOperator_size, None, GenericLinearOperator)
GenericLinearOperator.mult = new_instancemethod(_la.GenericLinearOperator_mult, None, GenericLinearOperator)
GenericLinearOperator_swigregister = _la.GenericLinearOperator_swigregister
GenericLinearOperator_swigregister(GenericLinearOperator)

class GenericTensor(LinearAlgebraObject):
    """

    This class defines a common interface for arbitrary rank tensors.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _la.delete_GenericTensor

    def init(self, tensor_layout):
        """

        Initialize zero tensor using tensor layout

        """
        return _la.GenericTensor_init(self, tensor_layout)


    def empty(self):
        """

        Return true if empty

        """
        return _la.GenericTensor_empty(self)


    def rank(self):
        """

        Return tensor rank (number of dimensions)

        """
        return _la.GenericTensor_rank(self)


    def size(self, dim):
        """

        Return size of given dimension

        """
        return _la.GenericTensor_size(self, dim)


    def local_range(self, dim):
        """

        Return local ownership range

        """
        return _la.GenericTensor_local_range(self, dim)


    def set_local(self, block, num_rows, rows):
        """

        Set block of values using local indices

        """
        return _la.GenericTensor_set_local(self, block, num_rows, rows)


    def add(self, block, rows):
        """

        **Overloaded versions**

        * add\ (block, rows)

          Add block of values using global indices

        * add\ (block, num_rows, rows)

          Add block of values using global indices

        """
        return _la.GenericTensor_add(self, block, rows)


    def add_local(self, *args):
        """

        **Overloaded versions**

        * add_local\ (block, rows)

          Add block of values using local indices

        * add_local\ (block, num_rows, rows)

          Add block of values using local indices

        """
        return _la.GenericTensor_add_local(self, *args)


    def zero(self):
        """

        Set all entries to zero and keep any sparse structure

        """
        return _la.GenericTensor_zero(self)


    def apply(self, mode):
        """

        Finalize assembly of tensor

        """
        return _la.GenericTensor_apply(self, mode)


    def mpi_comm(self):
        """

        Return MPI communicator

        """
        return _la.GenericTensor_mpi_comm(self)


    def factory(self):
        """

        Return linear algebra backend factory

        """
        return _la.GenericTensor_factory(self)

GenericTensor.init = new_instancemethod(_la.GenericTensor_init, None, GenericTensor)
GenericTensor.empty = new_instancemethod(_la.GenericTensor_empty, None, GenericTensor)
GenericTensor.rank = new_instancemethod(_la.GenericTensor_rank, None, GenericTensor)
GenericTensor.size = new_instancemethod(_la.GenericTensor_size, None, GenericTensor)
GenericTensor.local_range = new_instancemethod(_la.GenericTensor_local_range, None, GenericTensor)
GenericTensor.set_local = new_instancemethod(_la.GenericTensor_set_local, None, GenericTensor)
GenericTensor.add = new_instancemethod(_la.GenericTensor_add, None, GenericTensor)
GenericTensor.add_local = new_instancemethod(_la.GenericTensor_add_local, None, GenericTensor)
GenericTensor.zero = new_instancemethod(_la.GenericTensor_zero, None, GenericTensor)
GenericTensor.apply = new_instancemethod(_la.GenericTensor_apply, None, GenericTensor)
GenericTensor.mpi_comm = new_instancemethod(_la.GenericTensor_mpi_comm, None, GenericTensor)
GenericTensor.factory = new_instancemethod(_la.GenericTensor_factory, None, GenericTensor)
GenericTensor_swigregister = _la.GenericTensor_swigregister
GenericTensor_swigregister(GenericTensor)

class GenericMatrix(GenericTensor, GenericLinearOperator):
    """

    This class defines a common interface for matrices.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _la.delete_GenericMatrix

    def nnz(self):
        """

        Return number of non-zero entries in matrix (collective)

        """
        return _la.GenericMatrix_nnz(self)


    def copy(self):
        """

        Return copy of matrix

        """
        return _la.GenericMatrix_copy(self)


    def init_vector(self, z, dim):
        """

        Initialize vector z to be compatible with the matrix-vector
        product y = Ax. In the parallel case, both size and layout are
        important.

        *Arguments*
            dim (int)
                The dimension (axis): dim = 0 --> z = y, dim = 1 --> z = x

        """
        return _la.GenericMatrix_init_vector(self, z, dim)


    def get(self, block, m, n):
        """

        **Overloaded versions**

        * get\ (block, num_rows, rows)

          Get block of values

        * get\ (block, m, rows, n, cols)

          Get block of values

        """
        return _la.GenericMatrix_get(self, block, m, n)


    def set(self, block, m, n):
        """

        **Overloaded versions**

        * set\ (block, num_rows, rows)

          Set block of values using global indices

        * set\ (block, m, rows, n, cols)

          Set block of values using global indices

        """
        return _la.GenericMatrix_set(self, block, m, n)


    def set_local(self, *args):
        """

        **Overloaded versions**

        * set_local\ (block, num_rows, rows)

          Set block of values using local indices

        * set_local\ (block, m, rows, n, cols)

          Set block of values using local indices

        """
        return _la.GenericMatrix_set_local(self, *args)


    def add(self, *args):
        """

        **Overloaded versions**

        * add\ (block, num_rows, rows)

          Add block of values using global indices

        * add\ (block, rows)

          Add block of values using global indices

        * add\ (block, m, rows, n, cols)

          Add block of values using global indices

        """
        return _la.GenericMatrix_add(self, *args)


    def add_local(self, *args):
        """

        **Overloaded versions**

        * add_local\ (block, num_rows, rows)

          Add block of values using local indices

        * add_local\ (block, rows)

          Add block of values using local indices

        * add_local\ (block, m, rows, n, cols)

          Add block of values using local indices

        """
        return _la.GenericMatrix_add_local(self, *args)


    def axpy(self, a, A, same_nonzero_pattern):
        """

        Add multiple of given matrix (AXPY operation)

        """
        return _la.GenericMatrix_axpy(self, a, A, same_nonzero_pattern)


    def norm(self, norm_type):
        """

        Return norm of matrix

        """
        return _la.GenericMatrix_norm(self, norm_type)


    def getrow(self, row):
        """

        Get non-zero values of given row (global index) on local process

        """
        return _la.GenericMatrix_getrow(self, row)


    def setrow(self, row, columns, values):
        """

        Set values for given row (global index) on local process

        """
        return _la.GenericMatrix_setrow(self, row, columns, values)


    def zero(self, *args):
        """

        **Overloaded versions**

        * zero\ ()

          Set all entries to zero and keep any sparse structure

        * zero\ (m, rows)

          Set given rows (global row indices) to zero

        """
        return _la.GenericMatrix_zero(self, *args)


    def zero_local(self, m):
        """

        Set given rows (local row indices) to zero

        """
        return _la.GenericMatrix_zero_local(self, m)


    def ident(self, m):
        """

        Set given rows (global row indices) to identity matrix

        """
        return _la.GenericMatrix_ident(self, m)


    def ident_local(self, m):
        """

        Set given rows (local row indices) to identity matrix

        """
        return _la.GenericMatrix_ident_local(self, m)


    def transpmult(self, x, y):
        """

        Matrix-vector product, y = A^T x. The y vector must either be
        zero-sized or have correct size and parallel layout.

        """
        return _la.GenericMatrix_transpmult(self, x, y)


    def get_diagonal(self, x):
        """

        Get diagonal of a matrix

        """
        return _la.GenericMatrix_get_diagonal(self, x)


    def set_diagonal(self, x):
        """

        Set diagonal of a matrix

        """
        return _la.GenericMatrix_set_diagonal(self, x)


    def is_symmetric(self, tol):
        """

        Test if matrix is symmetric

        """
        return _la.GenericMatrix_is_symmetric(self, tol)


    def assign(self, x):
        """

        Assignment operator

        """
        return _la.GenericMatrix_assign(self, x)


    def ident_zeros(self):
        """

        Insert one on the diagonal for all zero rows

        """
        return _la.GenericMatrix_ident_zeros(self)


    def _scale(self, a):
        """Missing docstring"""
        return _la.GenericMatrix__scale(self, a)


    def __is_compatible(self,other):
        "Returns True if self, and other are compatible Vectors"
        if not isinstance(other,GenericMatrix):
            return False
        self_type = get_tensor_type(self)
        return self_type == get_tensor_type(other)

    def array(self):
        "Return a numpy array representation of Matrix"
        from numpy import zeros
        m_range = self.local_range(0);
        A = zeros((m_range[1] - m_range[0], self.size(1)))
        for i, row in enumerate(range(*m_range)):
            column, values = self.getrow(row)
            A[i, column] = values
        return A


    # FIXME: Getting matrix entries need to be carefully examined, especially
    #          for parallel objects.
    """
    def __getitem__(self,indices):
        from numpy import ndarray
        from types import SliceType
        if not (isinstance(indices, tuple) and len(indices) == 2):
            raise TypeError("expected two indices")
        if not all(isinstance(ind, (int, SliceType, list, ndarray)) for ind in indices):
            raise TypeError("an int, slice, list or numpy array as indices")

        if isinstance(indices[0], int):
            if isinstance(indices[1], int):
                return _get_matrix_single_item(self,indices[0],indices[1])
            return as_backend_type(_get_matrix_sub_vector(self,indices[0], indices[1], True))
        elif isinstance(indices[1],int):
            return as_backend_type(_get_matrix_sub_vector(self,indices[1], indices[0], False))
        else:
            same_indices = id(indices[0]) == id(indices[1])

            if not same_indices and ( type(indices[0]) == type(indices[1]) ):
                if isinstance(indices[0],(list,SliceType)):
                    same_indices = indices[0] == indices[1]
                else:
                    same_indices = (indices[0] == indices[1]).all()

            if same_indices:
                return as_backend_type(_get_matrix_sub_matrix(self, indices[0], None))
            else:
                return as_backend_type(_get_matrix_sub_matrix(self, indices[0], indices[1]))

    def __setitem__(self, indices, values):
        from numpy import ndarray, isscalar
        from types import SliceType
        if not (isinstance(indices, tuple) and len(indices) == 2):
            raise TypeError("expected two indices")
        if not all(isinstance(ind, (int, SliceType, list, ndarray)) for ind in indices):
            raise TypeError("an int, slice, list or numpy array as indices")

        if isinstance(indices[0], int):
            if isinstance(indices[1], int):
                if not isscalar(values):
                    raise TypeError("expected scalar for single value assigment")
                _set_matrix_single_item(self, indices[0], indices[1], values)
            else:
                raise NotImplementedError
                if isinstance(values,GenericVector):
                    _set_matrix_items_vector(self, indices[0], indices[1], values, True)
                elif isinstance(values,ndarray):
                    _set_matrix_items_array_of_float(self, indices[0], indices[1], values, True)
                else:
                    raise TypeError("expected a GenericVector or numpy array of float")
        elif isinstance(indices[1], int):
            raise NotImplementedError
            if isinstance(values, GenericVector):
                _set_matrix_items_vector(self, indices[1], indices[0], values, False)
            elif isinstance(values, ndarray):
                _set_matrix_items_array_of_float(self, indices[1], indices[0], values, False)
            else:
                raise TypeError("expected a GenericVector or numpy array of float")

        else:
            raise NotImplementedError
            same_indices = id(indices[0]) == id(indices[1])

            if not same_indices and ( type(indices[0]) == type(indices[1]) ):
                if isinstance(indices[0], (list, SliceType)):
                    same_indices = indices[0] == indices[1]
                else:
                    same_indices = (indices[0] == indices[1]).all()

            if same_indices:
                if isinstance(values,GenericMatrix):
                    _set_matrix_items_matrix(self, indices[0], None, values)
                elif isinstance(values, ndarray) and len(values.shape)==2:
                    _set_matrix_items_array_of_float(self, indices[0], None, values)
                else:
                    raise TypeError("expected a GenericMatrix or 2D numpy array of float")
            else:
                if isinstance(values,GenericMatrix):
                    _set_matrix_items_matrix(self, indices[0], indices[1], values)
                elif isinstance(values,ndarray) and len(values.shape) == 2:
                    _set_matrix_items_array_of_float(self, indices[0], indices[1], values)
                else:
                    raise TypeError("expected a GenericMatrix or 2D numpy array of float")
    """

    def __add__(self,other):
        """x.__add__(y) <==> x+y"""
        if self.__is_compatible(other):
            ret = self.copy()
            ret.axpy(1.0, other, False)
            return ret
        return NotImplemented

    def __sub__(self,other):
        """x.__sub__(y) <==> x-y"""
        if self.__is_compatible(other):
            ret = self.copy()
            ret.axpy(-1.0, other, False)
            return ret
        return NotImplemented

    def __mul__(self,other):
        """x.__mul__(y) <==> x*y"""
        from numpy import ndarray, isscalar
        if isscalar(other):
            ret = self.copy()
            ret._scale(other)
            return ret
        elif isinstance(other,GenericVector):
            matrix_type = get_tensor_type(self)
            vector_type = get_tensor_type(other)
            if vector_type not in _matrix_vector_mul_map[matrix_type]:
                raise TypeError("Provide a Vector which can be as_backend_typeed to ''"%vector_type.__name__)
            if type(other) == Vector:
                ret = Vector()
            else:
                ret = vector_type()
            self.mult(other, ret)
            return ret
        elif isinstance(other, ndarray):
            if len(other.shape) != 1:
                raise ValueError("Provide an 1D NumPy array")
            vec_size = other.shape[0]
            if vec_size != self.size(1):
                raise ValueError("Provide a NumPy array with length %d"%self.size(1))
            vec_type = _matrix_vector_mul_map[get_tensor_type(self)][0]
            vec = vec_type()
            vec.init(self.mpi_comm(), vec_size)
            vec.set_local(other)
            vec.apply("insert")
            result_vec = vec.copy()
            self.mult(vec, result_vec)
    #ret = other.copy()
    #result_vec.get_local(ret)
    #return ret
            return result_vec.get_local()
        return NotImplemented

    def __div__(self,other):
        """x.__div__(y) <==> x/y"""
        from numpy import isscalar
        if isscalar(other):
            ret = self.copy()
            ret._scale(1.0/other)
            return ret
        return NotImplemented

    def __truediv__(self,other):
        """x.__div__(y) <==> x/y"""
        from numpy import isscalar
        if isscalar(other):
            ret = self.copy()
            ret._scale(1.0/other)
            return ret
        return NotImplemented

    def __radd__(self,other):
        """x.__radd__(y) <==> y+x"""
        return self.__add__(other)

    def __rsub__(self,other):
        """x.__rsub__(y) <==> y-x"""
        return self.__sub__(other)

    def __rmul__(self,other):
        """x.__rmul__(y) <==> y*x"""
        from numpy import isscalar
        if isscalar(other):
            ret = self.copy()
            ret._scale(other)
            return ret
        return NotImplemented

    def __rdiv__(self,other):
        """x.__rdiv__(y) <==> y/x"""
        return NotImplemented

    def __iadd__(self,other):
        """x.__iadd__(y) <==> x+y"""
        if self.__is_compatible(other):
            self.axpy(1.0, other, False)
            return self
        return NotImplemented

    def __isub__(self,other):
        """x.__isub__(y) <==> x-y"""
        if self.__is_compatible(other):
            self.axpy(-1.0, other, False)
            return self
        return NotImplemented

    def __imul__(self,other):
        """x.__imul__(y) <==> x*y"""
        from numpy import isscalar
        if isscalar(other):
            self._scale(other)
            return self
        return NotImplemented

    def __idiv__(self,other):
        """x.__idiv__(y) <==> x/y"""
        from numpy import isscalar
        if isscalar(other):
            self._scale(1.0 / other)
            return self
        return NotImplemented

    def __itruediv__(self,other):
        """x.__idiv__(y) <==> x/y"""
        from numpy import isscalar
        if isscalar(other):
            self._scale(1.0 / other)
            return self
        return NotImplemented


GenericMatrix.nnz = new_instancemethod(_la.GenericMatrix_nnz, None, GenericMatrix)
GenericMatrix.copy = new_instancemethod(_la.GenericMatrix_copy, None, GenericMatrix)
GenericMatrix.init_vector = new_instancemethod(_la.GenericMatrix_init_vector, None, GenericMatrix)
GenericMatrix.get = new_instancemethod(_la.GenericMatrix_get, None, GenericMatrix)
GenericMatrix.set = new_instancemethod(_la.GenericMatrix_set, None, GenericMatrix)
GenericMatrix.set_local = new_instancemethod(_la.GenericMatrix_set_local, None, GenericMatrix)
GenericMatrix.add = new_instancemethod(_la.GenericMatrix_add, None, GenericMatrix)
GenericMatrix.add_local = new_instancemethod(_la.GenericMatrix_add_local, None, GenericMatrix)
GenericMatrix.axpy = new_instancemethod(_la.GenericMatrix_axpy, None, GenericMatrix)
GenericMatrix.norm = new_instancemethod(_la.GenericMatrix_norm, None, GenericMatrix)
GenericMatrix.getrow = new_instancemethod(_la.GenericMatrix_getrow, None, GenericMatrix)
GenericMatrix.setrow = new_instancemethod(_la.GenericMatrix_setrow, None, GenericMatrix)
GenericMatrix.zero = new_instancemethod(_la.GenericMatrix_zero, None, GenericMatrix)
GenericMatrix.zero_local = new_instancemethod(_la.GenericMatrix_zero_local, None, GenericMatrix)
GenericMatrix.ident = new_instancemethod(_la.GenericMatrix_ident, None, GenericMatrix)
GenericMatrix.ident_local = new_instancemethod(_la.GenericMatrix_ident_local, None, GenericMatrix)
GenericMatrix.transpmult = new_instancemethod(_la.GenericMatrix_transpmult, None, GenericMatrix)
GenericMatrix.get_diagonal = new_instancemethod(_la.GenericMatrix_get_diagonal, None, GenericMatrix)
GenericMatrix.set_diagonal = new_instancemethod(_la.GenericMatrix_set_diagonal, None, GenericMatrix)
GenericMatrix.is_symmetric = new_instancemethod(_la.GenericMatrix_is_symmetric, None, GenericMatrix)
GenericMatrix.assign = new_instancemethod(_la.GenericMatrix_assign, None, GenericMatrix)
GenericMatrix.ident_zeros = new_instancemethod(_la.GenericMatrix_ident_zeros, None, GenericMatrix)
GenericMatrix._scale = new_instancemethod(_la.GenericMatrix__scale, None, GenericMatrix)
GenericMatrix_swigregister = _la.GenericMatrix_swigregister
GenericMatrix_swigregister(GenericMatrix)

class GenericSparsityPattern(common.Variable):
    """

    Base class (interface) for generic tensor sparsity patterns.
    Currently, this interface is mostly limited to matrices.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    sorted = _la.GenericSparsityPattern_sorted
    unsorted = _la.GenericSparsityPattern_unsorted
    __swig_destroy__ = _la.delete_GenericSparsityPattern

    def init(self, mpi_comm, dims, local_range, local_to_global, off_process_owner, block_sizes):
        """

        Initialize sparsity pattern for a generic tensor

        """
        return _la.GenericSparsityPattern_init(self, mpi_comm, dims, local_range, local_to_global, off_process_owner, block_sizes)


    def insert_global(self, entries):
        """

        Insert non-zero entries using global indices

        """
        return _la.GenericSparsityPattern_insert_global(self, entries)


    def insert_local(self, entries):
        """

        Insert non-zero entries using local (process-wise) entries

        """
        return _la.GenericSparsityPattern_insert_local(self, entries)


    def rank(self):
        """

        Return rank

        """
        return _la.GenericSparsityPattern_rank(self)


    def primary_dim(self):
        """

        Return primary dimension (e.g., 0=row partition, 1=column
        partition)

        """
        return _la.GenericSparsityPattern_primary_dim(self)


    def local_range(self, dim):
        """

        Return local range for dimension dim

        """
        return _la.GenericSparsityPattern_local_range(self, dim)


    def num_nonzeros(self):
        """

        Return total number of nonzeros in local_range

        """
        return _la.GenericSparsityPattern_num_nonzeros(self)


    def num_nonzeros_diagonal(self):
        """

        Fill vector with number of nonzeros for diagonal block in
        local_range for primary dimension

        """
        return _la.GenericSparsityPattern_num_nonzeros_diagonal(self)


    def num_nonzeros_off_diagonal(self):
        """

        Fill vector with number of nonzeros for off-diagonal block in
        local_range for primary dimension

        """
        return _la.GenericSparsityPattern_num_nonzeros_off_diagonal(self)


    def num_local_nonzeros(self):
        """

        Fill vector with number of nonzeros in local_range for primary
        dimension

        """
        return _la.GenericSparsityPattern_num_local_nonzeros(self)


    def diagonal_pattern(self, type):
        """

        Return underlying sparsity pattern (diagonal). Options are
        'sorted' and 'unsorted'.

        """
        return _la.GenericSparsityPattern_diagonal_pattern(self, type)


    def off_diagonal_pattern(self, type):
        """

        Return underlying sparsity pattern (off-diagonal). Options
        are 'sorted' and 'unsorted'.

        """
        return _la.GenericSparsityPattern_off_diagonal_pattern(self, type)


    def apply(self):
        """

        Finalize sparsity pattern

        """
        return _la.GenericSparsityPattern_apply(self)


    def mpi_comm(self):
        """

        Return MPI communicator

        """
        return _la.GenericSparsityPattern_mpi_comm(self)

GenericSparsityPattern.init = new_instancemethod(_la.GenericSparsityPattern_init, None, GenericSparsityPattern)
GenericSparsityPattern.insert_global = new_instancemethod(_la.GenericSparsityPattern_insert_global, None, GenericSparsityPattern)
GenericSparsityPattern.insert_local = new_instancemethod(_la.GenericSparsityPattern_insert_local, None, GenericSparsityPattern)
GenericSparsityPattern.rank = new_instancemethod(_la.GenericSparsityPattern_rank, None, GenericSparsityPattern)
GenericSparsityPattern.primary_dim = new_instancemethod(_la.GenericSparsityPattern_primary_dim, None, GenericSparsityPattern)
GenericSparsityPattern.local_range = new_instancemethod(_la.GenericSparsityPattern_local_range, None, GenericSparsityPattern)
GenericSparsityPattern.num_nonzeros = new_instancemethod(_la.GenericSparsityPattern_num_nonzeros, None, GenericSparsityPattern)
GenericSparsityPattern.num_nonzeros_diagonal = new_instancemethod(_la.GenericSparsityPattern_num_nonzeros_diagonal, None, GenericSparsityPattern)
GenericSparsityPattern.num_nonzeros_off_diagonal = new_instancemethod(_la.GenericSparsityPattern_num_nonzeros_off_diagonal, None, GenericSparsityPattern)
GenericSparsityPattern.num_local_nonzeros = new_instancemethod(_la.GenericSparsityPattern_num_local_nonzeros, None, GenericSparsityPattern)
GenericSparsityPattern.diagonal_pattern = new_instancemethod(_la.GenericSparsityPattern_diagonal_pattern, None, GenericSparsityPattern)
GenericSparsityPattern.off_diagonal_pattern = new_instancemethod(_la.GenericSparsityPattern_off_diagonal_pattern, None, GenericSparsityPattern)
GenericSparsityPattern.apply = new_instancemethod(_la.GenericSparsityPattern_apply, None, GenericSparsityPattern)
GenericSparsityPattern.mpi_comm = new_instancemethod(_la.GenericSparsityPattern_mpi_comm, None, GenericSparsityPattern)
GenericSparsityPattern_swigregister = _la.GenericSparsityPattern_swigregister
GenericSparsityPattern_swigregister(GenericSparsityPattern)

class GenericVector(GenericTensor):
    """

    This class defines a common interface for vectors.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _la.delete_GenericVector

    def copy(self):
        """

        Return copy of vector

        """
        return _la.GenericVector_copy(self)


    def init(self, *args):
        """

        **Overloaded versions**

        * init\ (tensor_layout)

          Initialize zero tensor using sparsity pattern

        * init\ (comm, N)

          Initialize vector to global size N

        * init\ (comm, range)

          Initialize vector with given local ownership range

        * init\ (comm, range, local_to_global_map, ghost_indices)

          Initialise vector with given ownership range and with ghost
          values

        """
        return _la.GenericVector_init(self, *args)


    def size(self, *args):
        """

        **Overloaded versions**

        * size\ (dim)

          Return size of given dimension

        * size\ ()

          Return global size of vector

        """
        return _la.GenericVector_size(self, *args)


    def local_size(self):
        """

        Return local size of vector

        """
        return _la.GenericVector_local_size(self)


    def local_range(self, *args):
        """

        **Overloaded versions**

        * local_range\ (dim)

          Return local ownership range

        * local_range\ ()

          Return local ownership range of a vector

        """
        return _la.GenericVector_local_range(self, *args)


    def owns_index(self, i):
        """

        Determine whether global vector index is owned by this process

        """
        return _la.GenericVector_owns_index(self, i)


    def add(self, *args):
        """

        **Overloaded versions**

        * add\ (block, num_rows, rows)

          Add block of values using global indices

        * add\ (block, rows)

          Add block of values using global indices

        * add\ (block, m, rows)

          Add block of values using global indices

        """
        return _la.GenericVector_add(self, *args)


    def get_local(self, *args):
        """

        **Overloaded versions**

        * get_local\ (block, num_rows, rows)

          Get block of values using local indices

        * get_local\ (block, m, rows)

          Get block of values using local indices (values must all live
          on the local process, ghost are accessible)

        * get_local\ (values)

          Get all values on local process

        """
        return _la.GenericVector_get_local(self, *args)


    def set_local(self, *args):
        """

        **Overloaded versions**

        * set_local\ (block, num_rows, rows)

          Set block of values using local indices

        * set_local\ (block, m, rows)

          Set block of values using local indices

        * set_local\ (values)

          Set all values on local process

        """
        return _la.GenericVector_set_local(self, *args)


    def add_local(self, *args):
        """

        **Overloaded versions**

        * add_local\ (block, num_rows, rows)

          Add block of values using local indices

        * add_local\ (block, rows)

          Add block of values using local indices

        * add_local\ (block, m, rows)

          Add block of values using local indices

        * add_local\ (values)

          Add values to each entry on local process

        """
        return _la.GenericVector_add_local(self, *args)


    def gather(self, *args):
        """

        **Overloaded versions**

        * gather\ (x, indices)

          Gather entries into local vector x

        * gather\ (x, indices)

          Gather entries into x

        """
        return _la.GenericVector_gather(self, *args)


    def gather_on_zero(self):
        """

        Gather all entries into x on process 0

        """
        return _la.GenericVector_gather_on_zero(self)


    def axpy(self, a, x):
        """

        Add multiple of given vector (AXPY operation)

        """
        return _la.GenericVector_axpy(self, a, x)


    def abs(self):
        """

        Replace all entries in the vector by their absolute values

        """
        return _la.GenericVector_abs(self)


    def inner(self, x):
        """

        Return inner product with given vector

        """
        return _la.GenericVector_inner(self, x)


    def norm(self, norm_type):
        """

        Return norm of vector

        """
        return _la.GenericVector_norm(self, norm_type)


    def min(self):
        """

        Return minimum value of vector

        """
        return _la.GenericVector_min(self)


    def max(self):
        """

        Return maximum value of vector

        """
        return _la.GenericVector_max(self)


    def sum(self, *args):
        """

        **Overloaded versions**

        * sum\ ()

          Return sum of vector

        * sum\ (rows)

          Return sum of selected rows in vector. Repeated entries are
          only summed once.

        """
        return _la.GenericVector_sum(self, *args)


    def _assign(self, *args):
        """

        **Overloaded versions**

        * operator=\ (x)

          Assignment operator

        * operator=\ (a)

          Assignment operator

        """
        return _la.GenericVector__assign(self, *args)


    def _scale(self, a):
        """Missing docstring"""
        return _la.GenericVector__scale(self, a)


    def _vec_mul(self, other):
        """Missing docstring"""
        return _la.GenericVector__vec_mul(self, other)


    def __in_parallel(self):
        first, last = self.local_range()
        return first > 0 or len(self) > last

    def __is_compatible(self, other):
        "Returns True if self, and other are compatible Vectors"
        if not isinstance(other, GenericVector):
            return False
        self_type = get_tensor_type(self)
        return self_type == get_tensor_type(other)

    def array(self):
        "Return a numpy array representation of the local part of a Vector"
        return self.get_local()

    def __contains__(self, value):
        from numpy import isscalar
        if isscalar(value):
            return value in self.get_local()
        return NotImplemented

    def __gt__(self, value):
        from numpy import isscalar
        if isscalar(value):
            return self.get_local() > value
        if isinstance(value, GenericVector):
            return self.get_local() > value.get_local()
        return NotImplemented

    def __ge__(self, value):
        from numpy import isscalar
        if isscalar(value):
            return self.get_local() >= value
        if isinstance(value, GenericVector):
            return self.get_local() >= value.get_local()
        return NotImplemented

    def __lt__(self, value):
        from numpy import isscalar
        if isscalar(value):
            return self.get_local() < value
        if isinstance(value, GenericVector):
            return self.get_local() < value.get_local()
        return NotImplemented

    def __le__(self, value):
        from numpy import isscalar
        if isscalar(value):
            return self.get_local() <= value
        if isinstance(value, GenericVector):
            return self.get_local() <= value.get_local()
        return NotImplemented

    def __eq__(self, value):
        from numpy import isscalar
        if isscalar(value):
            return self.get_local() == value
        if isinstance(value, GenericVector):
            return self.get_local() == value.get_local()
        return NotImplemented

    def __neq__(self, value):
        from numpy import isscalar
        if isscalar(value):
            return self.get_local() != value
        if isinstance(value, GenericVector):
            return self.get_local() != value.get_local()
        return NotImplemented

    def __neg__(self):
        ret = self.copy()
        ret *= -1
        return ret

    def __delitem__(self,i):
        raise ValueError("cannot delete Vector elements")

    def __delslice__(self,i,j):
        raise ValueError("cannot delete Vector elements")

    def __setslice__(self, i, j, values):
        from numpy import ndarray, arange
        if i == 0 and (j >= len(self) or j == -1): # slice == whole
            from numpy import isscalar
    # No test for equal lengths because this is checked by DOLFIN in _assign
            if isinstance(values, GenericVector) or isscalar(values):
                self._assign(values)
                return
            elif isinstance(values, ndarray):
                indices = arange(self.local_size(), dtype=la_index_dtype())
                self[indices] = values
                return

        raise IndexError("can only set full slices v[:]")

    def __getslice__(self, i, j):
        if i == 0 and (j >= len(self) or j == -1):
            return self.copy()
        raise IndexError("can only return full slices v[:]")

    def _check_indices(self, indices):
        from numpy import asarray, ndarray

    # Only accpect list and ndarrays
        if not isinstance(indices, (ndarray, list)):
            raise TypeError("expected an int or a list or numpy array of "\
                            "integers or a boolean numpy array as indices.")

    # If boolean array
        elif isinstance(indices, ndarray) and indices.dtype==bool:
            indices = indices.nonzero()[0]

    # Convert to correct indextypes
        if isinstance(indices, ndarray):

    # For some obscure reason we need to compare the char
    # attribute of the dtype to be able to differentiate
    # between correct dtypes. And to get the char attribute we
    # need to instantiate the bloody dtype and then access the
    # fraking dtype of the dtype, which can be asked for its
    # char...
            if indices.dtype.char != la_index_dtype()().dtype.char:
                indices = indices.astype(la_index_dtype())
        else:
            indices = asarray(indices, dtype=la_index_dtype())

    # Check range
    # FIXME: What should local_size mean?
        if not ((0<=indices).all() and (indices<self.local_size()).all()):
            raise IndexError("expected indices to be in [0..{}]".format(\
                self.local_size()))

        return indices

    def __getitem__(self, indices):
        """Return values corresponding to the given local indices"""
        from numpy import ndarray, integer, long, array, zeros, float_

    # If indices is a slice
        if isinstance(indices, slice):
            if not (indices.start is None and indices.stop is None and \
                    indices.step is None):
                raise IndexError("can only return full slices v[:]")
            return self.__getslice__(0, len(self))

        elif isinstance(indices, (int, integer, long)):
            indices = array([indices], dtype=la_index_dtype())

        indices = self._check_indices(indices)

        values = zeros(len(indices), dtype=float_)
        if len(values)>0:
            self.get_local(values, indices)
        return values

    def __setitem__(self, indices, values):
        """Set values corresponding to the given local indices

        This method is collective and user need to take care when this
        method is called, preventing MPI-deadlocks.
        """
        from numpy import asarray, ndarray, array, integer, isscalar, long, float_, ones
        try:

    # If indices is a slice
            if isinstance(indices, slice):
                if not (indices.start is None and indices.stop is None and \
                        indices.step is None):
                    raise IndexError("can only set full slices v[:]")
                self.__setslice__(0, len(self), values)
                return

    # If indices is a single integer
            elif isinstance(indices, (int, integer, long)):
                if isscalar(values):
                    indices = array([indices], dtype=la_index_dtype())
                else:
                    raise TypeError("provide a scalar to set single item")

    # Check indices
            indices = self._check_indices(indices)

    # Check passed values and convert scalar to ndarray of that value
            if isscalar(values):
                vec_values = ones(len(indices), dtype=float_)
                vec_values *= values
                values = vec_values

            elif isinstance(values, GenericVector):
                values = values.get_local()

            elif isinstance(values, ndarray):
                values = asarray(values, dtype=float_)

            else:
                raise TypeError("provide a scalar, GenericVector or numpy array of "\
                                "float to set items in Vector")

            if len(values) != len(indices):
                raise IndexError("expected same size of indices and values")

    # If values passed.
            if len(values) > 0:
                self.set_local(values, indices)

        finally:
    # Always call apply insert to avoid MPI dead locks if one or more
    # ranks fails
            self.apply("insert")

    def __len__(self):
        return self.size()

    def __iter__(self):
        for i in range(self.size()):
            yield self[i]

    def __add__(self, other):
        """x.__add__(y) <==> x+y"""
        from numpy import isscalar
        if isscalar(other):
            ret = self.copy()
            ret._iadd_scalar(other)
            return ret
        elif self.__is_compatible(other):
            ret = self.copy()
            ret.axpy(1.0, other)
            return ret
        return NotImplemented

    def __sub__(self, other):
        """x.__sub__(y) <==> x-y"""
        from numpy import isscalar
        if isscalar(other):
            ret = self.copy()
            ret._iadd_scalar(-other)
            return ret
        elif self.__is_compatible(other):
            ret = self.copy()
            ret.axpy(-1.0, other)
            return ret
        return NotImplemented

    def __mul__(self, other):
        """x.__mul__(y) <==> x*y"""
        from numpy import isscalar
        if isscalar(other):
            ret = self.copy()
            ret._scale(other)
            return ret
        if isinstance(other,GenericVector):
            ret = self.copy()
            ret._vec_mul(other)
            return ret
        return NotImplemented

    def __div__(self,other):
        """x.__div__(y) <==> x/y"""
        from numpy import isscalar
        if isscalar(other):
            ret = self.copy()
            ret._scale(1.0 / other)
            return ret
        return NotImplemented

    def __truediv__(self,other):
        """x.__div__(y) <==> x/y"""
        from numpy import isscalar
        if isscalar(other):
            ret = self.copy()
            ret._scale(1.0 / other)
            return ret
        return NotImplemented

    def __radd__(self,other):
        """x.__radd__(y) <==> y+x"""
        return self.__add__(other)

    def __rsub__(self, other):
        """x.__rsub__(y) <==> y-x"""
        return self.__sub__(other)

    def __rmul__(self, other):
        """x.__rmul__(y) <==> y*x"""
        from numpy import isscalar
        if isscalar(other):
            ret = self.copy()
            ret._scale(other)
            return ret
        return NotImplemented

    def __rdiv__(self, other):
        """x.__rdiv__(y) <==> y/x"""
        return NotImplemented

    def __iadd__(self, other):
        """x.__iadd__(y) <==> x+y"""
        from numpy import isscalar
        if isscalar(other):
            self._iadd_scalar(other)
            return self
        elif self.__is_compatible(other):
            self.axpy(1.0, other)
            return self
        return NotImplemented

    def __isub__(self, other):
        """x.__isub__(y) <==> x-y"""
        from numpy import isscalar
        if isscalar(other):
            self._iadd_scalar(-other)
            return self
        elif self.__is_compatible(other):
            self.axpy(-1.0, other)
            return self
        return NotImplemented

    def __imul__(self, other):
        """x.__imul__(y) <==> x*y"""
        from numpy import isscalar
        if isscalar(other):
            self._scale(other)
            return self
        if isinstance(other, GenericVector):
            self._vec_mul(other)
            return self
        return NotImplemented

    def __idiv__(self, other):
        """x.__idiv__(y) <==> x/y"""
        from numpy import isscalar
        if isscalar(other):
            self._scale(1.0 / other)
            return self
        return NotImplemented

    def __itruediv__(self, other):
        """x.__idiv__(y) <==> x/y"""
        from numpy import isscalar
        if isscalar(other):
            self._scale(1.0 / other)
            return self
        return NotImplemented

    def __iter__(self):
        return iter(self.array())

GenericVector.copy = new_instancemethod(_la.GenericVector_copy, None, GenericVector)
GenericVector.init = new_instancemethod(_la.GenericVector_init, None, GenericVector)
GenericVector.size = new_instancemethod(_la.GenericVector_size, None, GenericVector)
GenericVector.local_size = new_instancemethod(_la.GenericVector_local_size, None, GenericVector)
GenericVector.local_range = new_instancemethod(_la.GenericVector_local_range, None, GenericVector)
GenericVector.owns_index = new_instancemethod(_la.GenericVector_owns_index, None, GenericVector)
GenericVector.add = new_instancemethod(_la.GenericVector_add, None, GenericVector)
GenericVector.get_local = new_instancemethod(_la.GenericVector_get_local, None, GenericVector)
GenericVector.set_local = new_instancemethod(_la.GenericVector_set_local, None, GenericVector)
GenericVector.add_local = new_instancemethod(_la.GenericVector_add_local, None, GenericVector)
GenericVector.gather = new_instancemethod(_la.GenericVector_gather, None, GenericVector)
GenericVector.gather_on_zero = new_instancemethod(_la.GenericVector_gather_on_zero, None, GenericVector)
GenericVector.axpy = new_instancemethod(_la.GenericVector_axpy, None, GenericVector)
GenericVector.abs = new_instancemethod(_la.GenericVector_abs, None, GenericVector)
GenericVector.inner = new_instancemethod(_la.GenericVector_inner, None, GenericVector)
GenericVector.norm = new_instancemethod(_la.GenericVector_norm, None, GenericVector)
GenericVector.min = new_instancemethod(_la.GenericVector_min, None, GenericVector)
GenericVector.max = new_instancemethod(_la.GenericVector_max, None, GenericVector)
GenericVector.sum = new_instancemethod(_la.GenericVector_sum, None, GenericVector)
GenericVector._assign = new_instancemethod(_la.GenericVector__assign, None, GenericVector)
GenericVector._iadd_scalar = new_instancemethod(_la.GenericVector__iadd_scalar, None, GenericVector)
GenericVector._scale = new_instancemethod(_la.GenericVector__scale, None, GenericVector)
GenericVector._vec_mul = new_instancemethod(_la.GenericVector__vec_mul, None, GenericVector)
GenericVector_swigregister = _la.GenericVector_swigregister
GenericVector_swigregister(GenericVector)

class VectorSpaceBasis(object):
    """

    This class defines a basis for vector spaces,
    typically used for expressing nullspaces, transpose nullspaces
    and near nullspaces of singular operators

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, basis):
        """

        Constructor

        """
        _la.VectorSpaceBasis_swiginit(self, _la.new_VectorSpaceBasis(basis))
    __swig_destroy__ = _la.delete_VectorSpaceBasis

    def is_orthonormal(self):
        """

        Test if basis is orthonormal

        """
        return _la.VectorSpaceBasis_is_orthonormal(self)


    def is_orthogonal(self):
        """

        Test if basis is orthogonal

        """
        return _la.VectorSpaceBasis_is_orthogonal(self)


    def orthogonalize(self, x):
        """

        Orthogonalize x with respect to basis

        """
        return _la.VectorSpaceBasis_orthogonalize(self, x)


    def dim(self):
        """

        Dimension of the basis

        """
        return _la.VectorSpaceBasis_dim(self)


    def _sub(self, i):
        """

        Get a particular basis vector

        """
        return _la.VectorSpaceBasis__sub(self, i)

VectorSpaceBasis.is_orthonormal = new_instancemethod(_la.VectorSpaceBasis_is_orthonormal, None, VectorSpaceBasis)
VectorSpaceBasis.is_orthogonal = new_instancemethod(_la.VectorSpaceBasis_is_orthogonal, None, VectorSpaceBasis)
VectorSpaceBasis.orthogonalize = new_instancemethod(_la.VectorSpaceBasis_orthogonalize, None, VectorSpaceBasis)
VectorSpaceBasis.dim = new_instancemethod(_la.VectorSpaceBasis_dim, None, VectorSpaceBasis)
VectorSpaceBasis._sub = new_instancemethod(_la.VectorSpaceBasis__sub, None, VectorSpaceBasis)
VectorSpaceBasis_swigregister = _la.VectorSpaceBasis_swigregister
VectorSpaceBasis_swigregister(VectorSpaceBasis)

class GenericLinearSolver(common.Variable):
    """

    This class provides a general solver for linear systems Ax = b.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def set_operator(self, A):
        """

        Set operator (matrix)

        """
        return _la.GenericLinearSolver_set_operator(self, A)


    def set_operators(self, A, P):
        """

        Set operator (matrix) and preconditioner matrix

        """
        return _la.GenericLinearSolver_set_operators(self, A, P)


    def set_nullspace(self, nullspace):
        """

        Set null space of the operator (matrix). This is used to solve
        singular systems

        """
        return _la.GenericLinearSolver_set_nullspace(self, nullspace)


    def solve(self, *args):
        """

        **Overloaded versions**

        * solve\ (A, x, b)

          Solve linear system Ax = b

        * solve\ (x, b)

          Solve linear system Ax = b

        """
        return _la.GenericLinearSolver_solve(self, *args)


    def solve_transpose(self, *args):
        """

        **Overloaded versions**

        * solve_transpose\ (A, x, b)

          Solve linear system A^Tx = b

        * solve_transpose\ (x, b)

          Solve linear system A^Tx = b

        """
        return _la.GenericLinearSolver_solve_transpose(self, *args)


    def parameter_type(self):
        """

        Return parameter type: "krylov_solver" or "lu_solver"

        """
        return _la.GenericLinearSolver_parameter_type(self)


    def update_parameters(self, parameters):
        """

        Update solver parameters (useful for LinearSolver wrapper)

        """
        return _la.GenericLinearSolver_update_parameters(self, parameters)

    __swig_destroy__ = _la.delete_GenericLinearSolver
GenericLinearSolver.set_operator = new_instancemethod(_la.GenericLinearSolver_set_operator, None, GenericLinearSolver)
GenericLinearSolver.set_operators = new_instancemethod(_la.GenericLinearSolver_set_operators, None, GenericLinearSolver)
GenericLinearSolver.set_nullspace = new_instancemethod(_la.GenericLinearSolver_set_nullspace, None, GenericLinearSolver)
GenericLinearSolver.solve = new_instancemethod(_la.GenericLinearSolver_solve, None, GenericLinearSolver)
GenericLinearSolver.solve_transpose = new_instancemethod(_la.GenericLinearSolver_solve_transpose, None, GenericLinearSolver)
GenericLinearSolver.parameter_type = new_instancemethod(_la.GenericLinearSolver_parameter_type, None, GenericLinearSolver)
GenericLinearSolver.update_parameters = new_instancemethod(_la.GenericLinearSolver_update_parameters, None, GenericLinearSolver)
GenericLinearSolver_swigregister = _la.GenericLinearSolver_swigregister
GenericLinearSolver_swigregister(GenericLinearSolver)

class GenericLUSolver(GenericLinearSolver):
    """

    This a base class for LU solvers

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def solve(self, *args):
        """

        **Overloaded versions**

        * solve\ (x, b)

          Solve linear system Ax = b

        * solve\ (A, x, b)

          Solve linear system Ax = b

        """
        return _la.GenericLUSolver_solve(self, *args)


    def solve_transpose(self, *args):
        """

        **Overloaded versions**

        * solve_transpose\ (x, b)

          Solve linear system A^Tx = b

        * solve_transpose\ (A, x, b)

          Solve linear system A^Tx = b

        """
        return _la.GenericLUSolver_solve_transpose(self, *args)

    __swig_destroy__ = _la.delete_GenericLUSolver
GenericLUSolver.solve = new_instancemethod(_la.GenericLUSolver_solve, None, GenericLUSolver)
GenericLUSolver.solve_transpose = new_instancemethod(_la.GenericLUSolver_solve_transpose, None, GenericLUSolver)
GenericLUSolver_swigregister = _la.GenericLUSolver_swigregister
GenericLUSolver_swigregister(GenericLUSolver)

class GenericPreconditioner(object):
    """

    This class provides a common base preconditioners.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    __swig_destroy__ = _la.delete_GenericPreconditioner

    def set_nullspace(self, nullspace):
        """

        Set the (approximate) null space of the preconditioner operator
        (matrix). This is required for certain preconditioner types,
        e.g. smoothed aggregation multigrid

        """
        return _la.GenericPreconditioner_set_nullspace(self, nullspace)


    def set_coordinates(self, x, dim):
        """

        Set the coordinates of the operator (matrix) rows and geometric
        dimension d. This is can be used by required for certain
        preconditioners, e.g. ML. The input for this function can be
        generated using GenericDofMap::tabulate_all_dofs.

        """
        return _la.GenericPreconditioner_set_coordinates(self, x, dim)


    def __init__(self):
        _la.GenericPreconditioner_swiginit(self, _la.new_GenericPreconditioner())
GenericPreconditioner.set_nullspace = new_instancemethod(_la.GenericPreconditioner_set_nullspace, None, GenericPreconditioner)
GenericPreconditioner.set_coordinates = new_instancemethod(_la.GenericPreconditioner_set_coordinates, None, GenericPreconditioner)
GenericPreconditioner_swigregister = _la.GenericPreconditioner_swigregister
GenericPreconditioner_swigregister(GenericPreconditioner)

class PETScOptions(object):
    """

    These class provides static functions that permit users to set
    and retrieve PETSc options via the PETSc option/parameter
    system. The option should be prefixed by '-', e.g.

        PETScOptions::set("mat_mumps_icntl_14", 40.0);

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def set(*args):
        """

        **Overloaded versions**

        * set\ (option)

          Set PETSc option that takes no value

        * set\ (option, value)

          Set PETSc boolean option

        * set\ (option, value)

          Set PETSc integer option

        * set\ (option, value)

          Set PETSc double option

        * set\ (option, value)

          Set PETSc string option

        * set\ (option, value)

          Genetic function for setting PETSc option

        """
        return _la.PETScOptions_set(*args)

    set = staticmethod(set)

    def clear(option):
        """

        Clear PETSc option

        """
        return _la.PETScOptions_clear(option)

    clear = staticmethod(clear)

    def __init__(self):
        _la.PETScOptions_swiginit(self, _la.new_PETScOptions())
    __swig_destroy__ = _la.delete_PETScOptions
PETScOptions_swigregister = _la.PETScOptions_swigregister
PETScOptions_swigregister(PETScOptions)

def PETScOptions_set(*args):
    """

    **Overloaded versions**

    * set\ (option)

      Set PETSc option that takes no value

    * set\ (option, value)

      Set PETSc boolean option

    * set\ (option, value)

      Set PETSc integer option

    * set\ (option, value)

      Set PETSc double option

    * set\ (option, value)

      Set PETSc string option

    * set\ (option, value)

      Genetic function for setting PETSc option

    """
    return _la.PETScOptions_set(*args)

def PETScOptions_clear(option):
    """

    Clear PETSc option

    """
    return _la.PETScOptions_clear(option)

class PETScObject(object):
    """

    This class calls SubSystemsManager to initialise PETSc.

    All PETSc objects must be derived from this class.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """

        Constructor. Ensures that PETSc has been initialised.

        """
        _la.PETScObject_swiginit(self, _la.new_PETScObject())
    __swig_destroy__ = _la.delete_PETScObject

    def petsc_error(error_code, filename, petsc_function):
        """

        Print error message for PETSc calls that return an error

        """
        return _la.PETScObject_petsc_error(error_code, filename, petsc_function)

    petsc_error = staticmethod(petsc_error)
PETScObject_swigregister = _la.PETScObject_swigregister
PETScObject_swigregister(PETScObject)

def PETScObject_petsc_error(error_code, filename, petsc_function):
    """

    Print error message for PETSc calls that return an error

    """
    return _la.PETScObject_petsc_error(error_code, filename, petsc_function)

class PETScBaseMatrix(PETScObject, common.Variable):
    """

    This class is a base class for matrices that can be used in
    PETScKrylovSolver.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _la.delete_PETScBaseMatrix

    def size(self, dim):
        """

        Return number of rows (dim = 0) or columns (dim = 1)

        """
        return _la.PETScBaseMatrix_size(self, dim)


    def local_range(self, dim):
        """

        Return local range along dimension dim

        """
        return _la.PETScBaseMatrix_local_range(self, dim)


    def init_vector(self, z, dim):
        """

        Initialize vector to be compatible with the matrix-vector product
        y = Ax. In the parallel case, both size and layout are
        important.

        *Arguments*
            dim (int)
                The dimension (axis): dim = 0 --> z = y, dim = 1 --> z = x

        """
        return _la.PETScBaseMatrix_init_vector(self, z, dim)


    def mat(self):
        """Return petsc4py representation of PETSc Mat"""
        return _la.PETScBaseMatrix_mat(self)

PETScBaseMatrix.size = new_instancemethod(_la.PETScBaseMatrix_size, None, PETScBaseMatrix)
PETScBaseMatrix.local_range = new_instancemethod(_la.PETScBaseMatrix_local_range, None, PETScBaseMatrix)
PETScBaseMatrix.init_vector = new_instancemethod(_la.PETScBaseMatrix_init_vector, None, PETScBaseMatrix)
PETScBaseMatrix.mat = new_instancemethod(_la.PETScBaseMatrix_mat, None, PETScBaseMatrix)
PETScBaseMatrix_swigregister = _la.PETScBaseMatrix_swigregister
PETScBaseMatrix_swigregister(PETScBaseMatrix)

class EigenMatrix(GenericMatrix):
    """

    This class provides a sparse matrix class based on Eigen.  It is
    a simple wrapper for Eigen::SparseMatrix implementing the
    GenericMatrix interface.

    The interface is intentionally simple. For advanced usage,
    access the underlying Eigen matrix and use the standard Eigen
    interface which is documented at http://eigen.tuxfamily.org

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * EigenMatrix\ ()

          Create empty matrix

        * EigenMatrix\ (M, N)

          Create M x N matrix

        * EigenMatrix\ (A)

          Copy constructor

        """
        _la.EigenMatrix_swiginit(self, _la.new_EigenMatrix(*args))
    __swig_destroy__ = _la.delete_EigenMatrix

    def resize(self, M, N):
        """

        Resize matrix to M x N

        """
        return _la.EigenMatrix_resize(self, M, N)


    def zero(self, *args):
        """

        **Overloaded versions**

        * zero\ ()

          Set all entries to zero and keep any sparse structure

        * zero\ (m, rows)

          Set given rows (global row indices) to zero

        """
        return _la.EigenMatrix_zero(self, *args)


    def mat(self, *args):
        """

        **Overloaded versions**

        * mat\ ()

          Return reference to Eigen matrix (const version)

        * mat\ ()

          Return reference to Eigen matrix (non-const version)

        """
        return _la.EigenMatrix_mat(self, *args)


    def compress(self):
        """

        Compress matrix (eliminate all zeros from a sparse matrix)

        """
        return _la.EigenMatrix_compress(self)


    def assign(self, *args):
        """

        **Overloaded versions**

        * operator=\ (A)

          Assignment operator

        * operator=\ (A)

          Assignment operator

        """
        return _la.EigenMatrix_assign(self, *args)


    def _data(self):
        """Missing docstring"""
        return _la.EigenMatrix__data(self)


    def data(self, deepcopy=True):
        """
        Return arrays to underlaying compresssed row/column storage data

        This method is only available for the Eigen linear algebra backend.

        *Arguments*
            deepcopy
                Return a copy of the data. If set to False a reference
                to the Matrix need to be kept, otherwise the data will be
                destroyed together with the destruction of the Matrix
        """
        rows, cols, values = self._data()
        if deepcopy:
            rows, cols, values = rows.astype(int), cols.astype(int), values.copy()
        else:
            _attach_base_to_numpy_array(rows, self)
            _attach_base_to_numpy_array(cols, self)
            _attach_base_to_numpy_array(values, self)

        return rows, cols, values

    def sparray(self):
        "Return a scipy.sparse representation of Matrix"
        from scipy.sparse import csr_matrix
        data = self.data(deepcopy=True)
        C = csr_matrix((data[2], data[1], data[0]))
        return C

EigenMatrix.resize = new_instancemethod(_la.EigenMatrix_resize, None, EigenMatrix)
EigenMatrix.zero = new_instancemethod(_la.EigenMatrix_zero, None, EigenMatrix)
EigenMatrix.mat = new_instancemethod(_la.EigenMatrix_mat, None, EigenMatrix)
EigenMatrix.compress = new_instancemethod(_la.EigenMatrix_compress, None, EigenMatrix)
EigenMatrix.assign = new_instancemethod(_la.EigenMatrix_assign, None, EigenMatrix)
EigenMatrix._data = new_instancemethod(_la.EigenMatrix__data, None, EigenMatrix)
EigenMatrix_swigregister = _la.EigenMatrix_swigregister
EigenMatrix_swigregister(EigenMatrix)

class PETScMatrix(GenericMatrix, PETScBaseMatrix):
    """

    This class provides a simple matrix class based on PETSc.
    It is a wrapper for a PETSc matrix pointer (Mat)
    implementing the GenericMatrix interface.

    The interface is intentionally simple. For advanced usage,
    access the PETSc Mat pointer using the function mat() and
    use the standard PETSc interface.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * PETScMatrix\ ()

          Create empty matrix

        * PETScMatrix\ (A)

          Create a wrapper around a PETSc Mat pointer

        * PETScMatrix\ (A)

          Copy constructor

        """
        _la.PETScMatrix_swiginit(self, _la.new_PETScMatrix(*args))
    __swig_destroy__ = _la.delete_PETScMatrix

    def zero(self, *args):
        """

        **Overloaded versions**

        * zero\ ()

          Set all entries to zero and keep any sparse structure

        * zero\ (m, rows)

          Set given rows (global row indices) to zero

        """
        return _la.PETScMatrix_zero(self, *args)


    def set_options_prefix(self, options_prefix):
        """

        Sets the prefix used by PETSc when searching the options
        database

        """
        return _la.PETScMatrix_set_options_prefix(self, options_prefix)


    def get_options_prefix(self):
        """

        Returns the prefix used by PETSc when searching the options
        database

        """
        return _la.PETScMatrix_get_options_prefix(self)


    def assign(self, *args):
        """

        **Overloaded versions**

        * operator=\ (A)

          Assignment operator

        * operator=\ (A)

          Assignment operator

        """
        return _la.PETScMatrix_assign(self, *args)


    def set_nullspace(self, nullspace):
        """

        Attach nullspace to matrix

        """
        return _la.PETScMatrix_set_nullspace(self, nullspace)


    def binary_dump(self, file_name):
        """

        Dump matrix to PETSc binary format

        """
        return _la.PETScMatrix_binary_dump(self, file_name)

PETScMatrix.zero = new_instancemethod(_la.PETScMatrix_zero, None, PETScMatrix)
PETScMatrix.set_options_prefix = new_instancemethod(_la.PETScMatrix_set_options_prefix, None, PETScMatrix)
PETScMatrix.get_options_prefix = new_instancemethod(_la.PETScMatrix_get_options_prefix, None, PETScMatrix)
PETScMatrix.assign = new_instancemethod(_la.PETScMatrix_assign, None, PETScMatrix)
PETScMatrix.set_nullspace = new_instancemethod(_la.PETScMatrix_set_nullspace, None, PETScMatrix)
PETScMatrix.binary_dump = new_instancemethod(_la.PETScMatrix_binary_dump, None, PETScMatrix)
PETScMatrix_swigregister = _la.PETScMatrix_swigregister
PETScMatrix_swigregister(PETScMatrix)

class PETScLinearOperator(PETScBaseMatrix, GenericLinearOperator):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """

        Constructor

        """
        if self.__class__ == PETScLinearOperator:
            _self = None
        else:
            _self = self
        _la.PETScLinearOperator_swiginit(self, _la.new_PETScLinearOperator(_self, ))

    def size(self, dim):
        """

        Return size of given dimension

        """
        return _la.PETScLinearOperator_size(self, dim)


    def mult(self, x, y):
        """

        Compute matrix-vector product y = Ax

        """
        return _la.PETScLinearOperator_mult(self, x, y)

    __swig_destroy__ = _la.delete_PETScLinearOperator
    def __disown__(self):
        self.this.disown()
        _la.disown_PETScLinearOperator(self)
        return weakref_proxy(self)
PETScLinearOperator.size = new_instancemethod(_la.PETScLinearOperator_size, None, PETScLinearOperator)
PETScLinearOperator.mult = new_instancemethod(_la.PETScLinearOperator_mult, None, PETScLinearOperator)
PETScLinearOperator.init_layout = new_instancemethod(_la.PETScLinearOperator_init_layout, None, PETScLinearOperator)
PETScLinearOperator_swigregister = _la.PETScLinearOperator_swigregister
PETScLinearOperator_swigregister(PETScLinearOperator)

class PETScPreconditioner(PETScObject, GenericPreconditioner, common.Variable):
    """

    This class is a wrapper for configuring PETSc
    preconditioners. It does not own a preconditioner. It can take a
    PETScKrylovSolver and set the preconditioner type and
    parameters.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        Create a particular preconditioner object

        """
        _la.PETScPreconditioner_swiginit(self, _la.new_PETScPreconditioner(*args))
    __swig_destroy__ = _la.delete_PETScPreconditioner

    def set(self, solver):
        """

        Set the preconditioner type and parameters

        """
        return _la.PETScPreconditioner_set(self, solver)


    def preconditioners():
        """

        Return a list of available preconditioners

        """
        return _la.PETScPreconditioner_preconditioners()

    preconditioners = staticmethod(preconditioners)

    def default_parameters():
        """

        Default parameter values

        """
        return _la.PETScPreconditioner_default_parameters()

    default_parameters = staticmethod(default_parameters)
PETScPreconditioner.set = new_instancemethod(_la.PETScPreconditioner_set, None, PETScPreconditioner)
PETScPreconditioner.set_fieldsplit = new_instancemethod(_la.PETScPreconditioner_set_fieldsplit, None, PETScPreconditioner)
PETScPreconditioner_swigregister = _la.PETScPreconditioner_swigregister
PETScPreconditioner_swigregister(PETScPreconditioner)

def PETScPreconditioner_preconditioners():
    """

    Return a list of available preconditioners

    """
    return _la.PETScPreconditioner_preconditioners()

def PETScPreconditioner_default_parameters():
    """

    Default parameter values

    """
    return _la.PETScPreconditioner_default_parameters()

class EigenKrylovSolver(GenericLinearSolver):
    """

    This class implements Krylov methods for linear systems of the
    form Ax = b. It is a wrapper for the Krylov solvers of Eigen.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        Create Krylov solver for a particular method and names
        preconditioner

        """
        _la.EigenKrylovSolver_swiginit(self, _la.new_EigenKrylovSolver(*args))
    __swig_destroy__ = _la.delete_EigenKrylovSolver

    def set_operator(self, *args):
        """

        **Overloaded versions**

        * set_operator\ (A)

          Set operator (matrix)

        * set_operator\ (A)

          Set operator (matrix)

        """
        return _la.EigenKrylovSolver_set_operator(self, *args)


    def set_operators(self, *args):
        """

        **Overloaded versions**

        * set_operators\ (A, P)

          Set operator (matrix) and preconditioner matrix

        * set_operators\ (A, P)

          Set operator (matrix) and preconditioner matrix

        """
        return _la.EigenKrylovSolver_set_operators(self, *args)


    def get_operator(self):
        """

        Get operator (matrix)

        """
        return _la.EigenKrylovSolver_get_operator(self)


    def solve(self, *args):
        """

        **Overloaded versions**

        * solve\ (x, b)

          Solve linear system Ax = b and return number of iterations

        * solve\ (x, b)

          Solve linear system Ax = b and return number of iterations

        * solve\ (A, x, b)

          Solve linear system Ax = b and return number of iterations

        * solve\ (A, x, b)

          Solve linear system Ax = b and return number of iterations

        """
        return _la.EigenKrylovSolver_solve(self, *args)


    def methods():
        """

        Return a list of available solver methods

        """
        return _la.EigenKrylovSolver_methods()

    methods = staticmethod(methods)

    def preconditioners():
        """

        Return a list of available preconditioners

        """
        return _la.EigenKrylovSolver_preconditioners()

    preconditioners = staticmethod(preconditioners)

    def default_parameters():
        """

        Default parameter values

        """
        return _la.EigenKrylovSolver_default_parameters()

    default_parameters = staticmethod(default_parameters)
EigenKrylovSolver.set_operator = new_instancemethod(_la.EigenKrylovSolver_set_operator, None, EigenKrylovSolver)
EigenKrylovSolver.set_operators = new_instancemethod(_la.EigenKrylovSolver_set_operators, None, EigenKrylovSolver)
EigenKrylovSolver.get_operator = new_instancemethod(_la.EigenKrylovSolver_get_operator, None, EigenKrylovSolver)
EigenKrylovSolver.solve = new_instancemethod(_la.EigenKrylovSolver_solve, None, EigenKrylovSolver)
EigenKrylovSolver_swigregister = _la.EigenKrylovSolver_swigregister
EigenKrylovSolver_swigregister(EigenKrylovSolver)

def EigenKrylovSolver_methods():
    """

    Return a list of available solver methods

    """
    return _la.EigenKrylovSolver_methods()

def EigenKrylovSolver_preconditioners():
    """

    Return a list of available preconditioners

    """
    return _la.EigenKrylovSolver_preconditioners()

def EigenKrylovSolver_default_parameters():
    """

    Default parameter values

    """
    return _la.EigenKrylovSolver_default_parameters()

class EigenLUSolver(GenericLUSolver):
    """

    This class implements the direct solution (LU factorization) for
    linear systems of the form Ax = b.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * EigenLUSolver\ (method="default")

          Constructor

        * EigenLUSolver\ (A, method="default")

          Constructor

        """
        _la.EigenLUSolver_swiginit(self, _la.new_EigenLUSolver(*args))
    __swig_destroy__ = _la.delete_EigenLUSolver

    def set_operator(self, *args):
        """

        **Overloaded versions**

        * set_operator\ (A)

          Set operator (matrix)

        * set_operator\ (A)

          Set operator (matrix)

        """
        return _la.EigenLUSolver_set_operator(self, *args)


    def get_operator(self):
        """

        Get operator (matrix)

        """
        return _la.EigenLUSolver_get_operator(self)


    def solve(self, *args):
        """

        **Overloaded versions**

        * solve\ (x, b)

          Solve linear system Ax = b

        * solve\ (x, b, transpose)

          Solve linear system Ax = b

        * solve\ (A, x, b)

          Solve linear system Ax = b

        * solve\ (A, x, b)

          Solve linear system Ax = b

        """
        return _la.EigenLUSolver_solve(self, *args)


    def solve_transpose(self, *args):
        """

        **Overloaded versions**

        * solve_transpose\ (x, b)

          Solve linear system A^Tx = b

        * solve_transpose\ (A, x, b)

          Solve linear system A^Tx = b

        * solve_transpose\ (A, x, b)

          Solve linear system A^Tx = b

        """
        return _la.EigenLUSolver_solve_transpose(self, *args)


    def methods():
        """

        Return a list of available solver methods

        """
        return _la.EigenLUSolver_methods()

    methods = staticmethod(methods)

    def default_parameters():
        """

        Default parameter values

        """
        return _la.EigenLUSolver_default_parameters()

    default_parameters = staticmethod(default_parameters)
EigenLUSolver.set_operator = new_instancemethod(_la.EigenLUSolver_set_operator, None, EigenLUSolver)
EigenLUSolver.get_operator = new_instancemethod(_la.EigenLUSolver_get_operator, None, EigenLUSolver)
EigenLUSolver.solve = new_instancemethod(_la.EigenLUSolver_solve, None, EigenLUSolver)
EigenLUSolver.solve_transpose = new_instancemethod(_la.EigenLUSolver_solve_transpose, None, EigenLUSolver)
EigenLUSolver_swigregister = _la.EigenLUSolver_swigregister
EigenLUSolver_swigregister(EigenLUSolver)

def EigenLUSolver_methods():
    """

    Return a list of available solver methods

    """
    return _la.EigenLUSolver_methods()

def EigenLUSolver_default_parameters():
    """

    Default parameter values

    """
    return _la.EigenLUSolver_default_parameters()

class PETScKrylovSolver(GenericLinearSolver, PETScObject):
    """

    This class implements Krylov methods for linear systems
    of the form Ax = b. It is a wrapper for the Krylov solvers
    of PETSc.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * PETScKrylovSolver\ ("default", "default")

          Create Krylov solver for a particular method and names
          preconditioner

        * PETScKrylovSolver\ (method, preconditioner)

          Create Krylov solver for a particular method and
          PETScPreconditioner

        * PETScKrylovSolver\ (method, preconditioner)

          Create Krylov solver for a particular method and
          PETScPreconditioner (shared_ptr version)

        * PETScKrylovSolver\ (method, preconditioner)

          Create Krylov solver for a particular method and
          PETScPreconditioner

        * PETScKrylovSolver\ (method, preconditioner)

          Create Krylov solver for a particular method and
          PETScPreconditioner (shared_ptr version)

        * PETScKrylovSolver\ (ksp)

          Create solver wrapper of a PETSc KSP object

        """
        _la.PETScKrylovSolver_swiginit(self, _la.new_PETScKrylovSolver(*args))
    __swig_destroy__ = _la.delete_PETScKrylovSolver

    def get_operator(self):
        """

        Get operator (matrix)

        """
        return _la.PETScKrylovSolver_get_operator(self)


    def solve(self, *args):
        """

        **Overloaded versions**

        * solve\ (x, b)

          Solve linear system Ax = b and return number of iterations

        * solve\ (x, b)

          Solve linear system Ax = b and return number of iterations

        * solve\ (A, x, b)

          Solve linear system Ax = b and return number of iterations

        """
        return _la.PETScKrylovSolver_solve(self, *args)


    def set_reuse_preconditioner(self, reuse_pc):
        """

        Reuse preconditioner if true, otherwise do not, even if matrix
        operator changes (by default preconditioner is re-built if the
        matrix changes)

        """
        return _la.PETScKrylovSolver_set_reuse_preconditioner(self, reuse_pc)


    def set_options_prefix(self, options_prefix):
        """

        Sets the prefix used by PETSc when searching the options
        database

        """
        return _la.PETScKrylovSolver_set_options_prefix(self, options_prefix)


    def get_options_prefix(self):
        """

        Returns the prefix used by PETSc when searching the options
        database

        """
        return _la.PETScKrylovSolver_get_options_prefix(self)


    def methods():
        """

        Return a list of available solver methods

        """
        return _la.PETScKrylovSolver_methods()

    methods = staticmethod(methods)

    def preconditioners():
        """

        Return a list of available preconditioners

        """
        return _la.PETScKrylovSolver_preconditioners()

    preconditioners = staticmethod(preconditioners)

    def default_parameters():
        """

        Default parameter values

        """
        return _la.PETScKrylovSolver_default_parameters()

    default_parameters = staticmethod(default_parameters)

    def ksp(self):
        """Return petsc4py representation of PETSc KSP solver"""
        return _la.PETScKrylovSolver_ksp(self)

PETScKrylovSolver.get_operator = new_instancemethod(_la.PETScKrylovSolver_get_operator, None, PETScKrylovSolver)
PETScKrylovSolver.solve = new_instancemethod(_la.PETScKrylovSolver_solve, None, PETScKrylovSolver)
PETScKrylovSolver.set_reuse_preconditioner = new_instancemethod(_la.PETScKrylovSolver_set_reuse_preconditioner, None, PETScKrylovSolver)
PETScKrylovSolver.set_options_prefix = new_instancemethod(_la.PETScKrylovSolver_set_options_prefix, None, PETScKrylovSolver)
PETScKrylovSolver.get_options_prefix = new_instancemethod(_la.PETScKrylovSolver_get_options_prefix, None, PETScKrylovSolver)
PETScKrylovSolver.ksp = new_instancemethod(_la.PETScKrylovSolver_ksp, None, PETScKrylovSolver)
PETScKrylovSolver_swigregister = _la.PETScKrylovSolver_swigregister
PETScKrylovSolver_swigregister(PETScKrylovSolver)

def PETScKrylovSolver_methods():
    """

    Return a list of available solver methods

    """
    return _la.PETScKrylovSolver_methods()

def PETScKrylovSolver_preconditioners():
    """

    Return a list of available preconditioners

    """
    return _la.PETScKrylovSolver_preconditioners()

def PETScKrylovSolver_default_parameters():
    """

    Default parameter values

    """
    return _la.PETScKrylovSolver_default_parameters()

class PETScLUSolver(GenericLUSolver, PETScObject):
    """

    This class implements the direct solution (LU factorization) for
    linear systems of the form Ax = b. It is a wrapper for the LU
    solver of PETSc.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * PETScLUSolver\ (method="default")

          Constructor

        * PETScLUSolver\ (A, method="default")

          Constructor

        """
        _la.PETScLUSolver_swiginit(self, _la.new_PETScLUSolver(*args))
    __swig_destroy__ = _la.delete_PETScLUSolver

    def set_operator(self, *args):
        """

        **Overloaded versions**

        * set_operator\ (A)

          Set operator (matrix)

        * set_operator\ (A)

          Set operator (matrix)

        """
        return _la.PETScLUSolver_set_operator(self, *args)


    def get_operator(self):
        """

        Get operator (matrix)

        """
        return _la.PETScLUSolver_get_operator(self)


    def solve(self, *args):
        """

        **Overloaded versions**

        * solve\ (x, b)

          Solve linear system Ax = b

        * solve\ (x, b, transpose)

          Solve linear system Ax = b

        * solve\ (A, x, b)

          Solve linear system Ax = b

        * solve\ (A, x, b)

          Solve linear system Ax = b

        """
        return _la.PETScLUSolver_solve(self, *args)


    def solve_transpose(self, *args):
        """

        **Overloaded versions**

        * solve_transpose\ (x, b)

          Solve linear system A^Tx = b

        * solve_transpose\ (A, x, b)

          Solve linear system A^Tx = b

        * solve_transpose\ (A, x, b)

          Solve linear system A^Tx = b

        """
        return _la.PETScLUSolver_solve_transpose(self, *args)


    def set_options_prefix(self, options_prefix):
        """

        Sets the prefix used by PETSc when searching the options
        database

        """
        return _la.PETScLUSolver_set_options_prefix(self, options_prefix)


    def get_options_prefix(self):
        """

        Returns the prefix used by PETSc when searching the options
        database

        """
        return _la.PETScLUSolver_get_options_prefix(self)


    def methods():
        """

        Return a list of available solver methods

        """
        return _la.PETScLUSolver_methods()

    methods = staticmethod(methods)

    def default_parameters():
        """

        Default parameter values

        """
        return _la.PETScLUSolver_default_parameters()

    default_parameters = staticmethod(default_parameters)

    def ksp(self):
        """Return petsc4py representation of PETSc LU solver"""
        return _la.PETScLUSolver_ksp(self)

PETScLUSolver.set_operator = new_instancemethod(_la.PETScLUSolver_set_operator, None, PETScLUSolver)
PETScLUSolver.get_operator = new_instancemethod(_la.PETScLUSolver_get_operator, None, PETScLUSolver)
PETScLUSolver.solve = new_instancemethod(_la.PETScLUSolver_solve, None, PETScLUSolver)
PETScLUSolver.solve_transpose = new_instancemethod(_la.PETScLUSolver_solve_transpose, None, PETScLUSolver)
PETScLUSolver.set_options_prefix = new_instancemethod(_la.PETScLUSolver_set_options_prefix, None, PETScLUSolver)
PETScLUSolver.get_options_prefix = new_instancemethod(_la.PETScLUSolver_get_options_prefix, None, PETScLUSolver)
PETScLUSolver.ksp = new_instancemethod(_la.PETScLUSolver_ksp, None, PETScLUSolver)
PETScLUSolver_swigregister = _la.PETScLUSolver_swigregister
PETScLUSolver_swigregister(PETScLUSolver)

def PETScLUSolver_methods():
    """

    Return a list of available solver methods

    """
    return _la.PETScLUSolver_methods()

def PETScLUSolver_default_parameters():
    """

    Default parameter values

    """
    return _la.PETScLUSolver_default_parameters()

class STLMatrix(GenericMatrix):
    """

    Simple STL-based implementation of the GenericMatrix interface.
    The sparse matrix is stored as a pair of std::vector of
    std::vector, one for the columns and one for the values.

    Historically, this class has undergone a number of different
    incarnations, based on various combinations of std::vector,
    std::set and std::map. The current implementation has proven to
    be the fastest.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, primary_dim=0):
        """

        Create empty matrix

        """
        _la.STLMatrix_swiginit(self, _la.new_STLMatrix(primary_dim))
    __swig_destroy__ = _la.delete_STLMatrix

    def zero(self, *args):
        """

        **Overloaded versions**

        * zero\ ()

          Set all entries to zero and keep any sparse structure

        * zero\ (m, rows)

          Set given rows (global row indices) to zero

        """
        return _la.STLMatrix_zero(self, *args)


    def block_size(self):
        """

        --- STLMatrix interface ---
        Return matrix block size

        """
        return _la.STLMatrix_block_size(self)


    def clear(self):
        """

        Clear matrix. Destroys data and sparse layout

        """
        return _la.STLMatrix_clear(self)


    def local_nnz(self):
        """

        Return number of local non-zero entries

        """
        return _la.STLMatrix_local_nnz(self)

STLMatrix.zero = new_instancemethod(_la.STLMatrix_zero, None, STLMatrix)
STLMatrix.block_size = new_instancemethod(_la.STLMatrix_block_size, None, STLMatrix)
STLMatrix.clear = new_instancemethod(_la.STLMatrix_clear, None, STLMatrix)
STLMatrix.sort = new_instancemethod(_la.STLMatrix_sort, None, STLMatrix)
STLMatrix.local_nnz = new_instancemethod(_la.STLMatrix_local_nnz, None, STLMatrix)
STLMatrix_swigregister = _la.STLMatrix_swigregister
STLMatrix_swigregister(STLMatrix)

class CoordinateMatrix(object):
    """

    Coordinate sparse matrix.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, A, symmetric, base_one):
        """

        Constructor

        """
        _la.CoordinateMatrix_swiginit(self, _la.new_CoordinateMatrix(A, symmetric, base_one))
    __swig_destroy__ = _la.delete_CoordinateMatrix

    def norm(self, norm_type):
        """

        Return norm of matrix

        """
        return _la.CoordinateMatrix_norm(self, norm_type)

CoordinateMatrix.size = new_instancemethod(_la.CoordinateMatrix_size, None, CoordinateMatrix)
CoordinateMatrix.rows = new_instancemethod(_la.CoordinateMatrix_rows, None, CoordinateMatrix)
CoordinateMatrix.columns = new_instancemethod(_la.CoordinateMatrix_columns, None, CoordinateMatrix)
CoordinateMatrix.values = new_instancemethod(_la.CoordinateMatrix_values, None, CoordinateMatrix)
CoordinateMatrix.norm = new_instancemethod(_la.CoordinateMatrix_norm, None, CoordinateMatrix)
CoordinateMatrix.mpi_comm = new_instancemethod(_la.CoordinateMatrix_mpi_comm, None, CoordinateMatrix)
CoordinateMatrix.base_one = new_instancemethod(_la.CoordinateMatrix_base_one, None, CoordinateMatrix)
CoordinateMatrix_swigregister = _la.CoordinateMatrix_swigregister
CoordinateMatrix_swigregister(CoordinateMatrix)

class EigenVector(GenericVector):
    """

    This class provides a simple vector class based on Eigen.
    It is a simple wrapper for a Eigen vector implementing the
    GenericVector interface.

    The interface is intentionally simple. For advanced usage,
    access the underlying Eigen vector and use the standard Eigen
    interface which is documented at http://eigen.tuxfamily.org

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * EigenVector\ ()

          Create empty vector

        * EigenVector\ (N)

          Create vector of size N

        * EigenVector\ (x)

          Copy constructor

        * EigenVector\ (x)

          Construct vector from an Eigen shared_ptr

        """
        _la.EigenVector_swiginit(self, _la.new_EigenVector(*args))
    __swig_destroy__ = _la.delete_EigenVector

    def init(self, *args):
        """

        **Overloaded versions**

        * init\ (tensor_layout)

          Initialize zero tensor using sparsity pattern

        * init\ (comm, N)

          Initialize vector to global size N

        * init\ (comm, range)

          Initialize vector with given local ownership range

        * init\ (comm, range, local_to_global_map, ghost_indices)

          Initialise vector with given ownership range and with ghost
          values

        """
        return _la.EigenVector_init(self, *args)


    def get_local(self, *args):
        """

        **Overloaded versions**

        * get_local\ (block, m, rows)

          Get block of values using local indices

        * get_local\ (values)

          Get all values on local process

        """
        return _la.EigenVector_get_local(self, *args)


    def set_local(self, *args):
        """

        **Overloaded versions**

        * set_local\ (block, m, rows)

          Set block of values using local indices

        * set_local\ (values)

          Set all values on local process

        """
        return _la.EigenVector_set_local(self, *args)


    def add_local(self, *args):
        """

        **Overloaded versions**

        * add_local\ (block, m, rows)

          Add block of values using local indices

        * add_local\ (values)

          Add values to each entry on local process

        """
        return _la.EigenVector_add_local(self, *args)


    def gather(self, *args):
        """

        **Overloaded versions**

        * gather\ (x, indices)

          Gather entries into local vector x

        * gather\ (x, indices)

          Gather entries into x

        """
        return _la.EigenVector_gather(self, *args)


    def sum(self, *args):
        """

        **Overloaded versions**

        * sum\ ()

          Return sum of values of vector

        * sum\ (rows)

          Return sum of selected rows in vector. Repeated entries are
          only summed once.

        """
        return _la.EigenVector_sum(self, *args)


    def resize(self, N):
        """

        Resize vector to size N

        """
        return _la.EigenVector_resize(self, N)


    def vec(self, *args):
        """

        **Overloaded versions**

        * vec\ ()

          Return reference to Eigen vector (const version)

        * vec\ ()

          Return reference to Eigen vector (non-const version)

        """
        return _la.EigenVector_vec(self, *args)


    def _assign(self, *args):
        """

        **Overloaded versions**

        * operator=\ (x)

          Assignment operator

        * operator=\ (a)

          Assignment operator

        * operator=\ (x)

          Assignment operator

        """
        return _la.EigenVector__assign(self, *args)


    def _data(self):
        """Missing docstring"""
        return _la.EigenVector__data(self)


    def data(self, deepcopy=True):
        """
        Return an array to underlaying data

        This method is only available for the Eigen linear algebra
        backend.

        *Arguments*
            deepcopy
                Return a copy of the data. If set to False a reference
                to the Matrix need to be kept, otherwise the data will be
                destroyed together with the destruction of the Matrix
        """
        ret = self._data()
        if deepcopy:
            ret = ret.copy()
        else:
            _attach_base_to_numpy_array(ret, self)

        return ret

EigenVector.init = new_instancemethod(_la.EigenVector_init, None, EigenVector)
EigenVector.get_local = new_instancemethod(_la.EigenVector_get_local, None, EigenVector)
EigenVector.set_local = new_instancemethod(_la.EigenVector_set_local, None, EigenVector)
EigenVector.add_local = new_instancemethod(_la.EigenVector_add_local, None, EigenVector)
EigenVector.gather = new_instancemethod(_la.EigenVector_gather, None, EigenVector)
EigenVector.sum = new_instancemethod(_la.EigenVector_sum, None, EigenVector)
EigenVector.resize = new_instancemethod(_la.EigenVector_resize, None, EigenVector)
EigenVector.vec = new_instancemethod(_la.EigenVector_vec, None, EigenVector)
EigenVector._assign = new_instancemethod(_la.EigenVector__assign, None, EigenVector)
EigenVector._data = new_instancemethod(_la.EigenVector__data, None, EigenVector)
EigenVector_swigregister = _la.EigenVector_swigregister
EigenVector_swigregister(EigenVector)

class PETScVector(GenericVector, PETScObject):
    """

    This class provides a simple vector class based on PETSc.
    It is a simple wrapper for a PETSc vector pointer (Vec)
    implementing the GenericVector interface.

    The interface is intentionally simple. For advanced usage,
    access the PETSc Vec pointer using the function vec() and
    use the standard PETSc interface.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * PETScVector\ ()

          Create empty vector

        * PETScVector\ (comm, N)

          Create vector of size N

        * PETScVector\ (sparsity_pattern)

          Create vector

        * PETScVector\ (x)

          Copy constructor

        * PETScVector\ (x)

          Create vector wrapper of PETSc Vec pointer

        """
        _la.PETScVector_swiginit(self, _la.new_PETScVector(*args))
    __swig_destroy__ = _la.delete_PETScVector

    def init(self, *args):
        """

        **Overloaded versions**

        * init\ (tensor_layout)

          Initialize zero tensor using sparsity pattern

        * init\ (comm, N)

          Initialize vector to global size N

        * init\ (comm, range)

          Initialize vector with given local ownership range

        * init\ (comm, range, local_to_global_map, ghost_indices)

          Initialise vector with given ownership range and with ghost
          values

        """
        return _la.PETScVector_init(self, *args)


    def get_local(self, *args):
        """

        **Overloaded versions**

        * get_local\ (block, m, rows)

          Get block of values using local indices

        * get_local\ (values)

          Get all values on local process

        """
        return _la.PETScVector_get_local(self, *args)


    def set_local(self, *args):
        """

        **Overloaded versions**

        * set_local\ (block, m, rows)

          Set block of values using local indices

        * set_local\ (values)

          Set all values on local process

        """
        return _la.PETScVector_set_local(self, *args)


    def add_local(self, *args):
        """

        **Overloaded versions**

        * add_local\ (block, m, rows)

          Add block of values using local indices

        * add_local\ (values)

          Add values to each entry on local process

        """
        return _la.PETScVector_add_local(self, *args)


    def gather(self, *args):
        """

        **Overloaded versions**

        * gather\ (y, indices)

          Gather vector entries into a local vector

        * gather\ (x, indices)

          Gather entries into x

        """
        return _la.PETScVector_gather(self, *args)


    def sum(self, *args):
        """

        **Overloaded versions**

        * sum\ ()

          Return sum of values of vector

        * sum\ (rows)

          Return sum of selected rows in vector

        """
        return _la.PETScVector_sum(self, *args)


    def set_options_prefix(self, options_prefix):
        """

        Sets the prefix used by PETSc when searching the options
        database

        """
        return _la.PETScVector_set_options_prefix(self, options_prefix)


    def get_options_prefix(self):
        """

        Returns the prefix used by PETSc when searching the options
        database

        """
        return _la.PETScVector_get_options_prefix(self)


    def _assign(self, *args):
        """

        **Overloaded versions**

        * operator=\ (x)

          Assignment operator

        * operator=\ (a)

          Assignment operator

        * operator=\ (x)

          Assignment operator

        """
        return _la.PETScVector__assign(self, *args)


    def vec(self):
        """Return petsc4py representation of PETSc Vec"""
        return _la.PETScVector_vec(self)

PETScVector.init = new_instancemethod(_la.PETScVector_init, None, PETScVector)
PETScVector.get_local = new_instancemethod(_la.PETScVector_get_local, None, PETScVector)
PETScVector.set_local = new_instancemethod(_la.PETScVector_set_local, None, PETScVector)
PETScVector.add_local = new_instancemethod(_la.PETScVector_add_local, None, PETScVector)
PETScVector.gather = new_instancemethod(_la.PETScVector_gather, None, PETScVector)
PETScVector.sum = new_instancemethod(_la.PETScVector_sum, None, PETScVector)
PETScVector.update_ghost_values = new_instancemethod(_la.PETScVector_update_ghost_values, None, PETScVector)
PETScVector.set_options_prefix = new_instancemethod(_la.PETScVector_set_options_prefix, None, PETScVector)
PETScVector.get_options_prefix = new_instancemethod(_la.PETScVector_get_options_prefix, None, PETScVector)
PETScVector._assign = new_instancemethod(_la.PETScVector__assign, None, PETScVector)
PETScVector.vec = new_instancemethod(_la.PETScVector_vec, None, PETScVector)
PETScVector_swigregister = _la.PETScVector_swigregister
PETScVector_swigregister(PETScVector)

class TensorLayout(common.Variable):
    """

    This class described the size and possibly the sparsity of a
    (sparse) tensor. It is used by the linear algebra backends to
    initialise tensors.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * TensorLayout\ (primary_dim, sparsity_pattern)

          Create empty tensor layout

        * TensorLayout\ (mpi_comm, dims, primary_dim, block_size, ownership_range, sparsity_pattern)

          Create a tensor layout

        """
        _la.TensorLayout_swiginit(self, _la.new_TensorLayout(*args))

    def init(self, mpi_comm, dims, block_size, ownership_range):
        """

        Initialize tensor layout

        """
        return _la.TensorLayout_init(self, mpi_comm, dims, block_size, ownership_range)


    def rank(self):
        """

        Return rank

        """
        return _la.TensorLayout_rank(self)


    def size(self, i):
        """

        Return global size for dimension i (size of tensor, includes
        non-zeroes)

        """
        return _la.TensorLayout_size(self, i)


    def local_range(self, dim):
        """

        Return local range for dimension dim

        """
        return _la.TensorLayout_local_range(self, dim)


    def sparsity_pattern(self, *args):
        """

        **Overloaded versions**

        * sparsity_pattern\ ()

          Return sparsity pattern (possibly null)

        * sparsity_pattern\ ()

          Return sparsity pattern (possibly null), const version

        """
        return _la.TensorLayout_sparsity_pattern(self, *args)

    primary_dim = _swig_property(_la.TensorLayout_primary_dim_get)
    block_size = _swig_property(_la.TensorLayout_block_size_get, _la.TensorLayout_block_size_set)

    def mpi_comm(self):
        """

        Return MPI communicator

        """
        return _la.TensorLayout_mpi_comm(self)

    local_to_global_map = _swig_property(_la.TensorLayout_local_to_global_map_get, _la.TensorLayout_local_to_global_map_set)
    __swig_destroy__ = _la.delete_TensorLayout
TensorLayout.init = new_instancemethod(_la.TensorLayout_init, None, TensorLayout)
TensorLayout.rank = new_instancemethod(_la.TensorLayout_rank, None, TensorLayout)
TensorLayout.size = new_instancemethod(_la.TensorLayout_size, None, TensorLayout)
TensorLayout.local_range = new_instancemethod(_la.TensorLayout_local_range, None, TensorLayout)
TensorLayout.sparsity_pattern = new_instancemethod(_la.TensorLayout_sparsity_pattern, None, TensorLayout)
TensorLayout.mpi_comm = new_instancemethod(_la.TensorLayout_mpi_comm, None, TensorLayout)
TensorLayout_swigregister = _la.TensorLayout_swigregister
TensorLayout_swigregister(TensorLayout)

class SparsityPattern(GenericSparsityPattern):
    """

    This class implements the GenericSparsityPattern interface.  It
    is used by most linear algebra backends.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * SparsityPattern\ (primary_dim)

          Create empty sparsity pattern

        * SparsityPattern\ (mpi_comm, dims, ownership_range, local_to_global, off_process_owner, block_sizes, primary_dim)

          Create sparsity pattern for a generic tensor

        """
        _la.SparsityPattern_swiginit(self, _la.new_SparsityPattern(*args))
    __swig_destroy__ = _la.delete_SparsityPattern
SparsityPattern_swigregister = _la.SparsityPattern_swigregister
SparsityPattern_swigregister(SparsityPattern)

class GenericLinearAlgebraFactory(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _la.delete_GenericLinearAlgebraFactory

    def create_matrix(self):
        """

        Create empty matrix

        """
        return _la.GenericLinearAlgebraFactory_create_matrix(self)


    def create_vector(self):
        """

        Create empty vector

        """
        return _la.GenericLinearAlgebraFactory_create_vector(self)


    def create_layout(self, rank):
        """

        Create empty tensor layout

        """
        return _la.GenericLinearAlgebraFactory_create_layout(self, rank)


    def create_linear_operator(self):
        """

        Create empty linear operator

        """
        return _la.GenericLinearAlgebraFactory_create_linear_operator(self)


    def create_lu_solver(self, method):
        """

        Create LU solver

        """
        return _la.GenericLinearAlgebraFactory_create_lu_solver(self, method)


    def create_krylov_solver(self, method, preconditioner):
        """

        Create Krylov solver

        """
        return _la.GenericLinearAlgebraFactory_create_krylov_solver(self, method, preconditioner)


    def lu_solver_methods(self):
        """

        Return a list of available LU solver methods.  This function
        should be overloaded by subclass if non-empty.

        """
        return _la.GenericLinearAlgebraFactory_lu_solver_methods(self)


    def krylov_solver_methods(self):
        """

        Return a list of available Krylov solver methods.  This
        function should be overloaded by subclass if non-empty.

        """
        return _la.GenericLinearAlgebraFactory_krylov_solver_methods(self)


    def krylov_solver_preconditioners(self):
        """

        Return a list of available preconditioners.
        This function should be overloaded by subclass if non-empty.

        """
        return _la.GenericLinearAlgebraFactory_krylov_solver_preconditioners(self)

GenericLinearAlgebraFactory.create_matrix = new_instancemethod(_la.GenericLinearAlgebraFactory_create_matrix, None, GenericLinearAlgebraFactory)
GenericLinearAlgebraFactory.create_vector = new_instancemethod(_la.GenericLinearAlgebraFactory_create_vector, None, GenericLinearAlgebraFactory)
GenericLinearAlgebraFactory.create_layout = new_instancemethod(_la.GenericLinearAlgebraFactory_create_layout, None, GenericLinearAlgebraFactory)
GenericLinearAlgebraFactory.create_linear_operator = new_instancemethod(_la.GenericLinearAlgebraFactory_create_linear_operator, None, GenericLinearAlgebraFactory)
GenericLinearAlgebraFactory.create_lu_solver = new_instancemethod(_la.GenericLinearAlgebraFactory_create_lu_solver, None, GenericLinearAlgebraFactory)
GenericLinearAlgebraFactory.create_krylov_solver = new_instancemethod(_la.GenericLinearAlgebraFactory_create_krylov_solver, None, GenericLinearAlgebraFactory)
GenericLinearAlgebraFactory.lu_solver_methods = new_instancemethod(_la.GenericLinearAlgebraFactory_lu_solver_methods, None, GenericLinearAlgebraFactory)
GenericLinearAlgebraFactory.krylov_solver_methods = new_instancemethod(_la.GenericLinearAlgebraFactory_krylov_solver_methods, None, GenericLinearAlgebraFactory)
GenericLinearAlgebraFactory.krylov_solver_preconditioners = new_instancemethod(_la.GenericLinearAlgebraFactory_krylov_solver_preconditioners, None, GenericLinearAlgebraFactory)
GenericLinearAlgebraFactory_swigregister = _la.GenericLinearAlgebraFactory_swigregister
GenericLinearAlgebraFactory_swigregister(GenericLinearAlgebraFactory)

class DefaultFactory(GenericLinearAlgebraFactory):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """

        Constructor

        """
        _la.DefaultFactory_swiginit(self, _la.new_DefaultFactory())
    __swig_destroy__ = _la.delete_DefaultFactory

    def factory():
        """

        Return instance of default backend

        """
        return _la.DefaultFactory_factory()

    factory = staticmethod(factory)
DefaultFactory_swigregister = _la.DefaultFactory_swigregister
DefaultFactory_swigregister(DefaultFactory)

def DefaultFactory_factory():
    """

    Return instance of default backend

    """
    return _la.DefaultFactory_factory()

class EigenFactory(GenericLinearAlgebraFactory):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _la.delete_EigenFactory

    def instance():
        """

        Return singleton instance

        """
        return _la.EigenFactory_instance()

    instance = staticmethod(instance)
EigenFactory_swigregister = _la.EigenFactory_swigregister
EigenFactory_swigregister(EigenFactory)

def EigenFactory_instance():
    """

    Return singleton instance

    """
    return _la.EigenFactory_instance()

class PETScUserPreconditioner(PETScObject):
    """

    This class specifies the interface for user-defined Krylov
    method PETScPreconditioners. A user wishing to implement her own
    PETScPreconditioner needs only supply a function that approximately
    solves the linear system given a right-hand side.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """

        Constructor

        """
        if self.__class__ == PETScUserPreconditioner:
            _self = None
        else:
            _self = self
        _la.PETScUserPreconditioner_swiginit(self, _la.new_PETScUserPreconditioner(_self, ))
    __swig_destroy__ = _la.delete_PETScUserPreconditioner
    setup = staticmethod(_la.PETScUserPreconditioner_setup)

    def solve(self, x, b):
        """

        Solve linear system approximately for given right-hand side b

        """
        return _la.PETScUserPreconditioner_solve(self, x, b)

    def __disown__(self):
        self.this.disown()
        _la.disown_PETScUserPreconditioner(self)
        return weakref_proxy(self)
PETScUserPreconditioner.solve = new_instancemethod(_la.PETScUserPreconditioner_solve, None, PETScUserPreconditioner)
PETScUserPreconditioner_swigregister = _la.PETScUserPreconditioner_swigregister
PETScUserPreconditioner_swigregister(PETScUserPreconditioner)

def PETScUserPreconditioner_setup(ksp, pc):
    return _la.PETScUserPreconditioner_setup(ksp, pc)
PETScUserPreconditioner_setup = _la.PETScUserPreconditioner_setup

class PETScFactory(GenericLinearAlgebraFactory):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _la.delete_PETScFactory

    def instance():
        """

        Return singleton instance

        """
        return _la.PETScFactory_instance()

    instance = staticmethod(instance)
PETScFactory_swigregister = _la.PETScFactory_swigregister
PETScFactory_swigregister(PETScFactory)

def PETScFactory_instance():
    """

    Return singleton instance

    """
    return _la.PETScFactory_instance()

class STLFactory(GenericLinearAlgebraFactory):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _la.delete_STLFactory

    def instance():
        """

        Return singleton instance

        """
        return _la.STLFactory_instance()

    instance = staticmethod(instance)
STLFactory_swigregister = _la.STLFactory_swigregister
STLFactory_swigregister(STLFactory)

def STLFactory_instance():
    """

    Return singleton instance

    """
    return _la.STLFactory_instance()

class SLEPcEigenSolver(common.Variable, PETScObject):
    """

    This class provides an eigenvalue solver for PETSc matrices.
    It is a wrapper for the SLEPc eigenvalue solver.

    The following parameters may be specified to control the solver.

    1. "spectrum"

    This parameter controls which part of the spectrum to compute.
    Possible values are

      "largest magnitude"   (eigenvalues with largest magnitude)
      "smallest magnitude"  (eigenvalues with smallest magnitude)
      "largest real"        (eigenvalues with largest double part)
      "smallest real"       (eigenvalues with smallest double part)
      "largest imaginary"   (eigenvalues with largest imaginary part)
      "smallest imaginary"  (eigenvalues with smallest imaginary part)

    For SLEPc versions >= 3.1 , the following values are also possible

      "target magnitude"    (eigenvalues closest to target in magnitude)
      "target real"         (eigenvalues closest to target in real part)
      "target imaginary"    (eigenvalues closest to target in imaginary part)

    The default is "largest magnitude"

    2. "solver"

    This parameter controls which algorithm is used by SLEPc.
    Possible values are

      "power"               (power iteration)
      "subspace"            (subspace iteration)
      "arnoldi"             (Arnoldi)
      "lanczos"             (Lanczos)
      "krylov-schur"        (Krylov-Schur)
      "lapack"              (LAPACK, all values, direct, small systems only)
      "arpack"              (ARPACK)

    The default is "krylov-schur"

    3. "tolerance"

    This parameter controls the tolerance used by SLEPc.
    Possible values are positive double numbers.

    The default is 1e-15;

    4. "maximum_iterations"

    This parameter controls the maximum number of iterations used by SLEPc.
    Possible values are positive integers.

    Note that both the tolerance and the number of iterations must be
    specified if either one is specified.

    5. "problem_type"

    This parameter can be used to give extra information about the
    type of the eigenvalue problem. Some solver types require this
    extra piece of information. Possible values are:

      "hermitian"               (Hermitian)
      "non_hermitian"           (Non-Hermitian)
      "gen_hermitian"           (Generalized Hermitian)
      "gen_non_hermitian"       (Generalized Non-Hermitian)
      "pos_gen_non_hermitian"   (Generalized Non-Hermitian with positive semidefinite B)

    6. "spectral_transform"

    This parameter controls the application of a spectral transform. A
    spectral transform can be used to enhance the convergence of the
    eigensolver and in particular to only compute eigenvalues in the
    interior of the spectrum. Possible values are:

      "shift-and-invert"      (A shift-and-invert transform)

    Note that if a spectral transform is given, then also a non-zero
    spectral shift parameter has to be provided.

    The default is no spectral transform.

    7. "spectral_shift"

    This parameter controls the spectral shift used by the spectral
    transform and must be provided if a spectral transform is given. The
    possible values are real numbers.


    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * SLEPcEigenSolver\ (A)

          Create eigenvalue solver for Ax = \lambda x

        * SLEPcEigenSolver\ (A, B)

          Create eigenvalue solver Ax = \lambda Bx

        * SLEPcEigenSolver\ (A)

          Create eigenvalue solver for Ax = \lambda x

        * SLEPcEigenSolver\ (A, B)

          Create eigenvalue solver for Ax = \lambda x

        """
        _la.SLEPcEigenSolver_swiginit(self, _la.new_SLEPcEigenSolver(*args))
    __swig_destroy__ = _la.delete_SLEPcEigenSolver

    def solve(self, *args):
        """

        **Overloaded versions**

        * solve\ ()

          Compute all eigenpairs of the matrix A (solve Ax = \lambda x)

        * solve\ (n)

          Compute the n first eigenpairs of the matrix A (solve Ax = \lambda x)

        """
        return _la.SLEPcEigenSolver_solve(self, *args)


    def get_iteration_number(self):
        """

        Get the number of iterations used by the solver

        """
        return _la.SLEPcEigenSolver_get_iteration_number(self)


    def get_number_converged(self):
        """

        Get the number of converged eigenvalues

        """
        return _la.SLEPcEigenSolver_get_number_converged(self)


    def set_deflation_space(self, deflation_space):
        """

        Set deflation space

        """
        return _la.SLEPcEigenSolver_set_deflation_space(self, deflation_space)


    def default_parameters():
        """

        Default parameter values

        """
        return _la.SLEPcEigenSolver_default_parameters()

    default_parameters = staticmethod(default_parameters)

    def _get_eigenvalue(self, i):
        """Missing docstring"""
        return _la.SLEPcEigenSolver__get_eigenvalue(self, i)


    def _get_eigenpair(self, r, c, i):
        """Missing docstring"""
        return _la.SLEPcEigenSolver__get_eigenpair(self, r, c, i)


    def get_eigenpair(self, i = 0, r_vec = None, c_vec = None,):
        """Gets the i-th solution of the eigenproblem"""
        r_vec = r_vec or PETScVector()
        c_vec = c_vec or PETScVector()
        lr, lc = self._get_eigenpair(r_vec, c_vec, i)
        return lr, lc, r_vec, c_vec

    def get_eigenvalue(self, i = 0):
        """Gets the i-th eigenvalue of the eigenproblem"""
        return self._get_eigenvalue(i)


    def eps(self):
        """Return slepc4py representation of SLEPc EPS"""
        return _la.SLEPcEigenSolver_eps(self)

SLEPcEigenSolver.solve = new_instancemethod(_la.SLEPcEigenSolver_solve, None, SLEPcEigenSolver)
SLEPcEigenSolver.get_iteration_number = new_instancemethod(_la.SLEPcEigenSolver_get_iteration_number, None, SLEPcEigenSolver)
SLEPcEigenSolver.get_number_converged = new_instancemethod(_la.SLEPcEigenSolver_get_number_converged, None, SLEPcEigenSolver)
SLEPcEigenSolver.set_deflation_space = new_instancemethod(_la.SLEPcEigenSolver_set_deflation_space, None, SLEPcEigenSolver)
SLEPcEigenSolver._get_eigenvalue = new_instancemethod(_la.SLEPcEigenSolver__get_eigenvalue, None, SLEPcEigenSolver)
SLEPcEigenSolver._get_eigenpair = new_instancemethod(_la.SLEPcEigenSolver__get_eigenpair, None, SLEPcEigenSolver)
SLEPcEigenSolver.eps = new_instancemethod(_la.SLEPcEigenSolver_eps, None, SLEPcEigenSolver)
SLEPcEigenSolver_swigregister = _la.SLEPcEigenSolver_swigregister
SLEPcEigenSolver_swigregister(SLEPcEigenSolver)

def SLEPcEigenSolver_default_parameters():
    """

    Default parameter values

    """
    return _la.SLEPcEigenSolver_default_parameters()

class Vector(GenericVector):
    """

    This class provides the default DOLFIN vector class,
    based on the default DOLFIN linear algebra backend.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * Vector\ ()

          Create empty vector

        * Vector\ (comm, N)

          Create vector of size N

        * Vector\ (x)

          Copy constructor

        * Vector\ (x)

          Create a Vector from a GenericVector

        """
        _la.Vector_swiginit(self, _la.new_Vector(*args))

    def init(self, *args):
        """

        **Overloaded versions**

        * init\ (tensor_layout)

          Initialize zero tensor using sparsity pattern

        * init\ (comm, N)

          Initialize vector to global size N

        * init\ (comm, range)

          Initialize vector with given local ownership range

        * init\ (comm, range, local_to_global_map, ghost_indices)

          Initialise vector with given ownership range and with ghost
          values

        """
        return _la.Vector_init(self, *args)


    def get_local(self, *args):
        """

        **Overloaded versions**

        * get_local\ (block, m, rows)

          Get block of values using local indices (values must all live
          on the local process)

        * get_local\ (values)

          Get all values on local process

        """
        return _la.Vector_get_local(self, *args)


    def set_local(self, *args):
        """

        **Overloaded versions**

        * set_local\ (block, m, rows)

          Set block of values using local indices

        * set_local\ (values)

          Set all values on local process

        """
        return _la.Vector_set_local(self, *args)


    def add_local(self, *args):
        """

        **Overloaded versions**

        * add_local\ (block, m, rows)

          Add block of values using local indices

        * add_local\ (values)

          Add values to each entry on local process

        """
        return _la.Vector_add_local(self, *args)


    def gather(self, *args):
        """

        **Overloaded versions**

        * gather\ (x, indices)

          Gather entries into local vector x

        * gather\ (x, indices)

          Gather entries into x

        """
        return _la.Vector_gather(self, *args)


    def sum(self, *args):
        """

        Return sum of values of vector

        """
        return _la.Vector_sum(self, *args)


    def shared_instance(self, *args):
        """

        **Overloaded versions**

        * shared_instance\ ()

          Return concrete shared ptr instance / unwrap (const version)

        * shared_instance\ ()

          Return concrete shared ptr instance / unwrap (non-const version)

        """
        return _la.Vector_shared_instance(self, *args)


    def _assign(self, *args):
        """

        **Overloaded versions**

        * operator=\ (x)

          Assignment operator

        * operator=\ (a)

          Assignment operator

        * operator=\ (x)

          Assignment operator

        """
        return _la.Vector__assign(self, *args)

    __swig_destroy__ = _la.delete_Vector
Vector.init = new_instancemethod(_la.Vector_init, None, Vector)
Vector.get_local = new_instancemethod(_la.Vector_get_local, None, Vector)
Vector.set_local = new_instancemethod(_la.Vector_set_local, None, Vector)
Vector.add_local = new_instancemethod(_la.Vector_add_local, None, Vector)
Vector.gather = new_instancemethod(_la.Vector_gather, None, Vector)
Vector.sum = new_instancemethod(_la.Vector_sum, None, Vector)
Vector.shared_instance = new_instancemethod(_la.Vector_shared_instance, None, Vector)
Vector._assign = new_instancemethod(_la.Vector__assign, None, Vector)
Vector_swigregister = _la.Vector_swigregister
Vector_swigregister(Vector)

class Matrix(GenericMatrix):
    """

    This class provides the default DOLFIN matrix class,
    based on the default DOLFIN linear algebra backend.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * Matrix\ ()

          Create empty matrix

        * Matrix\ (A)

          Copy constructor

        * Matrix\ (A)

          Create a Vector from a GenericVector

        """
        _la.Matrix_swiginit(self, _la.new_Matrix(*args))
    __swig_destroy__ = _la.delete_Matrix

    def zero(self, *args):
        """

        **Overloaded versions**

        * zero\ ()

          Set all entries to zero and keep any sparse structure

        * zero\ (m, rows)

          Set given rows to zero

        """
        return _la.Matrix_zero(self, *args)


    def shared_instance(self, *args):
        """

        **Overloaded versions**

        * shared_instance\ ()

          Return concrete shared ptr instance / unwrap (const version)

        * shared_instance\ ()

          Return concrete shared ptr instance / unwrap (non-const version)

        """
        return _la.Matrix_shared_instance(self, *args)


    def assign(self, *args):
        """

        **Overloaded versions**

        * operator=\ (A)

          Assignment operator

        * operator=\ (A)

          Assignment operator

        """
        return _la.Matrix_assign(self, *args)

Matrix.zero = new_instancemethod(_la.Matrix_zero, None, Matrix)
Matrix.shared_instance = new_instancemethod(_la.Matrix_shared_instance, None, Matrix)
Matrix.assign = new_instancemethod(_la.Matrix_assign, None, Matrix)
Matrix_swigregister = _la.Matrix_swigregister
Matrix_swigregister(Matrix)

class Scalar(GenericTensor):
    """

    This class represents a real-valued scalar quantity and
    implements the GenericTensor interface for scalars.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """

        Create zero scalar

        """
        _la.Scalar_swiginit(self, _la.new_Scalar())
    __swig_destroy__ = _la.delete_Scalar

    def add_local(self, *args):
        """

        **Overloaded versions**

        * add_local\ (block, num_rows, rows)

          Add block of values using local indices

        * add_local\ (block, rows)

          Add block of values using local indices

        """
        return _la.Scalar_add_local(self, *args)


    def copy(self):
        """

        Return copy of scalar

        """
        return _la.Scalar_copy(self)


    def get_scalar_value(self):
        """

        Get final value (assumes prior apply(), not part of GenericTensor interface)

        """
        return _la.Scalar_get_scalar_value(self)


    def add_local_value(self, value):
        """

        Add to local increment (added for testing, remove if we add a better way from python)

        """
        return _la.Scalar_add_local_value(self, value)

Scalar.add_local = new_instancemethod(_la.Scalar_add_local, None, Scalar)
Scalar.copy = new_instancemethod(_la.Scalar_copy, None, Scalar)
Scalar.get_scalar_value = new_instancemethod(_la.Scalar_get_scalar_value, None, Scalar)
Scalar.add_local_value = new_instancemethod(_la.Scalar_add_local_value, None, Scalar)
Scalar_swigregister = _la.Scalar_swigregister
Scalar_swigregister(Scalar)

class LinearSolver(GenericLinearSolver):
    """

    This class provides a general solver for linear systems Ax = b.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        Create linear solver

        """
        _la.LinearSolver_swiginit(self, _la.new_LinearSolver(*args))
    __swig_destroy__ = _la.delete_LinearSolver

    def solve(self, *args):
        """

        **Overloaded versions**

        * solve\ (A, x, b)

          Solve linear system Ax = b

        * solve\ (x, b)

          Solve linear system Ax = b

        """
        return _la.LinearSolver_solve(self, *args)


    def default_parameters():
        """

        Default parameter values

        """
        return _la.LinearSolver_default_parameters()

    default_parameters = staticmethod(default_parameters)
LinearSolver.solve = new_instancemethod(_la.LinearSolver_solve, None, LinearSolver)
LinearSolver_swigregister = _la.LinearSolver_swigregister
LinearSolver_swigregister(LinearSolver)

def LinearSolver_default_parameters():
    """

    Default parameter values

    """
    return _la.LinearSolver_default_parameters()

class KrylovSolver(GenericLinearSolver):
    """

    This class defines an interface for a Krylov solver. The
    appropriate solver is chosen on the basis of the matrix/vector
    type.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * KrylovSolver\ (method="default", preconditioner="default")

          Constructor

        * KrylovSolver\ (A, method="default", preconditioner="default")

          Constructor

        """
        _la.KrylovSolver_swiginit(self, _la.new_KrylovSolver(*args))
    __swig_destroy__ = _la.delete_KrylovSolver

    def solve(self, *args):
        """

        **Overloaded versions**

        * solve\ (x, b)

          Solve linear system Ax = b

        * solve\ (A, x, b)

          Solve linear system Ax = b

        """
        return _la.KrylovSolver_solve(self, *args)


    def default_parameters():
        """

        Default parameter values

        """
        return _la.KrylovSolver_default_parameters()

    default_parameters = staticmethod(default_parameters)
KrylovSolver.solve = new_instancemethod(_la.KrylovSolver_solve, None, KrylovSolver)
KrylovSolver_swigregister = _la.KrylovSolver_swigregister
KrylovSolver_swigregister(KrylovSolver)

def KrylovSolver_default_parameters():
    """

    Default parameter values

    """
    return _la.KrylovSolver_default_parameters()

class LUSolver(GenericLUSolver):
    """

    LU solver for the built-in LA backends.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * LUSolver\ ("default")

          Constructor

        * LUSolver\ (A, method="default")

          Constructor

        """
        _la.LUSolver_swiginit(self, _la.new_LUSolver(*args))
    __swig_destroy__ = _la.delete_LUSolver

    def solve(self, *args):
        """

        **Overloaded versions**

        * solve\ (x, b)

          Solve linear system Ax = b

        * solve\ (A, x, b)

          Solve linear system

        """
        return _la.LUSolver_solve(self, *args)


    def solve_transpose(self, *args):
        """

        **Overloaded versions**

        * solve_transpose\ (x, b)

          Solve linear system A^Tx = b

        * solve_transpose\ (A, x, b)

          Solve linear system

        """
        return _la.LUSolver_solve_transpose(self, *args)


    def default_parameters():
        """

        Default parameter values

        """
        return _la.LUSolver_default_parameters()

    default_parameters = staticmethod(default_parameters)
LUSolver.solve = new_instancemethod(_la.LUSolver_solve, None, LUSolver)
LUSolver.solve_transpose = new_instancemethod(_la.LUSolver_solve_transpose, None, LUSolver)
LUSolver_swigregister = _la.LUSolver_swigregister
LUSolver_swigregister(LUSolver)

def LUSolver_default_parameters():
    """

    Default parameter values

    """
    return _la.LUSolver_default_parameters()


def la_solve(*args):
    """

    Solve linear system Ax = b

    """
    return _la.la_solve(*args)

def list_linear_algebra_backends():
    """

    List available linear algebra backends

    """
    return _la.list_linear_algebra_backends()

def list_linear_solver_methods():
    """

    List available solver methods for current linear algebra backend

    """
    return _la.list_linear_solver_methods()

def list_lu_solver_methods():
    """

    List available LU methods for current linear algebra backend

    """
    return _la.list_lu_solver_methods()

def list_krylov_solver_methods():
    """

    List available Krylov methods for current linear algebra backend

    """
    return _la.list_krylov_solver_methods()

def list_krylov_solver_preconditioners():
    """

    List available preconditioners for current linear algebra
    backend

    """
    return _la.list_krylov_solver_preconditioners()

def has_linear_algebra_backend(backend):
    return _la.has_linear_algebra_backend(backend)
has_linear_algebra_backend = _la.has_linear_algebra_backend

def has_lu_solver_method(method):
    """

    Return true if LU method for the current linear algebra backend is
    available

    """
    return _la.has_lu_solver_method(method)

def has_krylov_solver_method(method):
    """

    Return true if Krylov method for the current linear algebra
    backend is available

    """
    return _la.has_krylov_solver_method(method)

def has_krylov_solver_preconditioner(preconditioner):
    """

    Return true if Preconditioner for the current linear algebra
    backend is available

    """
    return _la.has_krylov_solver_preconditioner(preconditioner)

def linear_algebra_backends():
    """

    Return available linear algebra backends

    """
    return _la.linear_algebra_backends()

def linear_solver_methods():
    """

    Return a list of available solver methods for current linear
    algebra backend

    """
    return _la.linear_solver_methods()

def lu_solver_methods():
    """

    Return a list of available LU methods for current linear algebra
    backend

    """
    return _la.lu_solver_methods()

def krylov_solver_methods():
    """

    Return a list of available Krylov methods for current linear
    algebra backend

    """
    return _la.krylov_solver_methods()

def krylov_solver_preconditioners():
    """

    Return a list of available preconditioners for current linear
    algebra backend

    """
    return _la.krylov_solver_preconditioners()

def residual(A, x, b):
    """

    Compute residual ||Ax - b||

    """
    return _la.residual(A, x, b)

def normalize(*args):
    """

    Normalize vector according to given normalization type

    """
    return _la.normalize(*args)

def in_nullspace(*args):
    """

    Check whether a vector space basis is in the nullspace of a
    given operator. The string option 'type' can be "right" for the
    right nullspace (Ax=0) or "left" for the left nullspace (A^Tx =
    0). To test the left nullspace, A must also be of type
    GenericMatrix.

    """
    return _la.in_nullspace(*args)
class BlockVector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, n=0):
        """

        Constructor

        """
        _la.BlockVector_swiginit(self, _la.new_BlockVector(n))
    __swig_destroy__ = _la.delete_BlockVector

    def copy(self):
        """

        Return copy of tensor

        """
        return _la.BlockVector_copy(self)


    def set_block(self, i, v):
        """

        Set function

        """
        return _la.BlockVector_set_block(self, i, v)


    def get_block(self, *args):
        """

        **Overloaded versions**

        * get_block\ (i)

          Get sub-vector (const)

        * get_block\ ()

          Get sub-vector (non-const)

        """
        return _la.BlockVector_get_block(self, *args)


    def axpy(self, a, x):
        """

        Add multiple of given vector (AXPY operation)

        """
        return _la.BlockVector_axpy(self, a, x)


    def inner(self, x):
        """

        Return inner product with given vector

        """
        return _la.BlockVector_inner(self, x)


    def norm(self, norm_type):
        """

        Return norm of vector

        """
        return _la.BlockVector_norm(self, norm_type)


    def min(self):
        """

        Return minimum value of vector

        """
        return _la.BlockVector_min(self)


    def max(self):
        """

        Return maximum value of vector

        """
        return _la.BlockVector_max(self)


    def __imul__(self, a):
        """

        Multiply vector by given number

        """
        return _la.BlockVector___imul__(self, a)


    def __idiv__(self, a):
        """

        Divide vector by given number

        """
        return _la.BlockVector___idiv__(self, a)


    def __iadd__(self, x):
        """

        Add given vector

        """
        return _la.BlockVector___iadd__(self, x)


    def __isub__(self, x):
        """

        Subtract given vector

        """
        return _la.BlockVector___isub__(self, x)


    def empty(self):
        """

        Return true if empty

        """
        return _la.BlockVector_empty(self)


    def size(self):
        """

        Number of vectors

        """
        return _la.BlockVector_size(self)


    def str(self, verbose):
        """

        Return informal string representation (pretty-print)

        """
        return _la.BlockVector_str(self, verbose)



    def __getitem__(self, i):
        return self.get_block(i)

    def __setitem__(self, i, m):
        if not hasattr(self, "_items"):
            self._items = {}
        self._items[i] = m
        self.set_block(i, m)

    def __add__(self, v):
      a = self.copy()
      a += v
      return a

    def __sub__(self, v):
      a = self.copy()
      a -= v
      return a

    def __mul__(self, v):
      a = self.copy()
      a *= v
      return a

    def __rmul__(self, v):
      return self.__mul__(v)

BlockVector.copy = new_instancemethod(_la.BlockVector_copy, None, BlockVector)
BlockVector.set_block = new_instancemethod(_la.BlockVector_set_block, None, BlockVector)
BlockVector.get_block = new_instancemethod(_la.BlockVector_get_block, None, BlockVector)
BlockVector.axpy = new_instancemethod(_la.BlockVector_axpy, None, BlockVector)
BlockVector.inner = new_instancemethod(_la.BlockVector_inner, None, BlockVector)
BlockVector.norm = new_instancemethod(_la.BlockVector_norm, None, BlockVector)
BlockVector.min = new_instancemethod(_la.BlockVector_min, None, BlockVector)
BlockVector.max = new_instancemethod(_la.BlockVector_max, None, BlockVector)
BlockVector.__imul__ = new_instancemethod(_la.BlockVector___imul__, None, BlockVector)
BlockVector.__idiv__ = new_instancemethod(_la.BlockVector___idiv__, None, BlockVector)
BlockVector.__iadd__ = new_instancemethod(_la.BlockVector___iadd__, None, BlockVector)
BlockVector.__isub__ = new_instancemethod(_la.BlockVector___isub__, None, BlockVector)
BlockVector.empty = new_instancemethod(_la.BlockVector_empty, None, BlockVector)
BlockVector.size = new_instancemethod(_la.BlockVector_size, None, BlockVector)
BlockVector.str = new_instancemethod(_la.BlockVector_str, None, BlockVector)
BlockVector_swigregister = _la.BlockVector_swigregister
BlockVector_swigregister(BlockVector)

class BlockMatrix(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, m=0, n=0):
        _la.BlockMatrix_swiginit(self, _la.new_BlockMatrix(m, n))
    __swig_destroy__ = _la.delete_BlockMatrix

    def set_block(self, i, j, m):
        """

        Set block

        """
        return _la.BlockMatrix_set_block(self, i, j, m)


    def get_block(self, *args):
        """

        **Overloaded versions**

        * get_block\ (i, j)

          Get block (const version)

        * get_block\ (i, j)

          Get block

        """
        return _la.BlockMatrix_get_block(self, *args)


    def size(self, dim):
        """

        Return size of given dimension

        """
        return _la.BlockMatrix_size(self, dim)


    def zero(self):
        """

        Set all entries to zero and keep any sparse structure

        """
        return _la.BlockMatrix_zero(self)


    def apply(self, mode):
        """

        Finalize assembly of tensor

        """
        return _la.BlockMatrix_apply(self, mode)


    def str(self, verbose):
        """

        Return informal string representation (pretty-print)

        """
        return _la.BlockMatrix_str(self, verbose)


    def mult(self, x, y, transposed=False):
        """

        Matrix-vector product, y = Ax

        """
        return _la.BlockMatrix_mult(self, x, y, transposed)


    def schur_approximation(self, symmetry=True):
        """

        Create a crude explicit Schur approximation  of S = D - C A^-1
        B of  (A B; C  D) If symmetry !=  0, then the  caller promises
        that B = symmetry * transpose(C).

        """
        return _la.BlockMatrix_schur_approximation(self, symmetry)


    def __mul__(self, other):
        v = BlockVector(self.size(0))
        self.mult(other, v)
        return v

    def __getitem__(self, t):
        i,j = t
        return self.get_block(i, j)

    def __setitem__(self, t, m):
        if not hasattr(self, "_items"):
            self._items = {}
        self._items[t] = m
        i,j = t
        self.set_block(i, j, m)


BlockMatrix.set_block = new_instancemethod(_la.BlockMatrix_set_block, None, BlockMatrix)
BlockMatrix.get_block = new_instancemethod(_la.BlockMatrix_get_block, None, BlockMatrix)
BlockMatrix.size = new_instancemethod(_la.BlockMatrix_size, None, BlockMatrix)
BlockMatrix.zero = new_instancemethod(_la.BlockMatrix_zero, None, BlockMatrix)
BlockMatrix.apply = new_instancemethod(_la.BlockMatrix_apply, None, BlockMatrix)
BlockMatrix.str = new_instancemethod(_la.BlockMatrix_str, None, BlockMatrix)
BlockMatrix.mult = new_instancemethod(_la.BlockMatrix_mult, None, BlockMatrix)
BlockMatrix.schur_approximation = new_instancemethod(_la.BlockMatrix_schur_approximation, None, BlockMatrix)
BlockMatrix_swigregister = _la.BlockMatrix_swigregister
BlockMatrix_swigregister(BlockMatrix)

class LinearOperator(GenericLinearOperator):
    """

    This class defines an interface for linear operators defined
    only in terms of their action (matrix-vector product) and can be
    used for matrix-free solution of linear systems. The linear
    algebra backend is decided at run-time based on the present
    value of the "linear_algebra_backend" parameter.

    To define a linear operator, users need to inherit from this
    class and overload the function mult(x, y) which defines the
    action of the matrix on the vector x as y = Ax.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        Create linear operator

        """
        if self.__class__ == LinearOperator:
            _self = None
        else:
            _self = self
        _la.LinearOperator_swiginit(self, _la.new_LinearOperator(_self, *args))
    __swig_destroy__ = _la.delete_LinearOperator

    def size(self, dim):
        """

        Return size of given dimension

        """
        return _la.LinearOperator_size(self, dim)


    def mult(self, x, y):
        """

        Compute matrix-vector product y = Ax

        """
        return _la.LinearOperator_mult(self, x, y)


    def str(self, verbose):
        """

        Return informal string representation (pretty-print)

        """
        return _la.LinearOperator_str(self, verbose)


    def shared_instance(self, *args):
        """

        **Overloaded versions**

        * shared_instance\ ()

          Return concrete instance / unwrap (const shared pointer version)

        * shared_instance\ ()

          Return concrete instance / unwrap (shared pointer version)

        """
        return _la.LinearOperator_shared_instance(self, *args)

    def __disown__(self):
        self.this.disown()
        _la.disown_LinearOperator(self)
        return weakref_proxy(self)
LinearOperator.size = new_instancemethod(_la.LinearOperator_size, None, LinearOperator)
LinearOperator.mult = new_instancemethod(_la.LinearOperator_mult, None, LinearOperator)
LinearOperator.str = new_instancemethod(_la.LinearOperator_str, None, LinearOperator)
LinearOperator.shared_instance = new_instancemethod(_la.LinearOperator_shared_instance, None, LinearOperator)
LinearOperator.init_layout = new_instancemethod(_la.LinearOperator_init_layout, None, LinearOperator)
LinearOperator_swigregister = _la.LinearOperator_swigregister
LinearOperator_swigregister(LinearOperator)


def la_index_dtype():
    "Return the numpy dtype equivalent to the type of la_index"
    from numpy import intc, int64
    return intc if common.sizeof_la_index() == 4 else int64


_has_type_map = {}
_as_backend_type_map = {}
# A map with matrix types as keys and list of possible vector types as values
_matrix_vector_mul_map = {}


def _has_type_EigenVector(tensor):
    return _la._has_type_EigenVector(tensor)
_has_type_EigenVector = _la._has_type_EigenVector

def _as_backend_type_EigenVector(tensor):
    return _la._as_backend_type_EigenVector(tensor)
_as_backend_type_EigenVector = _la._as_backend_type_EigenVector

_has_type_map[EigenVector] = _has_type_EigenVector
_as_backend_type_map[EigenVector] = _as_backend_type_EigenVector


def _has_type_EigenMatrix(tensor):
    return _la._has_type_EigenMatrix(tensor)
_has_type_EigenMatrix = _la._has_type_EigenMatrix

def _as_backend_type_EigenMatrix(tensor):
    return _la._as_backend_type_EigenMatrix(tensor)
_as_backend_type_EigenMatrix = _la._as_backend_type_EigenMatrix

_has_type_map[EigenMatrix] = _has_type_EigenMatrix
_as_backend_type_map[EigenMatrix] = _as_backend_type_EigenMatrix


_matrix_vector_mul_map[EigenMatrix] = [EigenVector]


def _has_type_PETScVector(tensor):
    return _la._has_type_PETScVector(tensor)
_has_type_PETScVector = _la._has_type_PETScVector

def _as_backend_type_PETScVector(tensor):
    return _la._as_backend_type_PETScVector(tensor)
_as_backend_type_PETScVector = _la._as_backend_type_PETScVector

_has_type_map[PETScVector] = _has_type_PETScVector
_as_backend_type_map[PETScVector] = _as_backend_type_PETScVector


def _has_type_PETScMatrix(tensor):
    return _la._has_type_PETScMatrix(tensor)
_has_type_PETScMatrix = _la._has_type_PETScMatrix

def _as_backend_type_PETScMatrix(tensor):
    return _la._as_backend_type_PETScMatrix(tensor)
_as_backend_type_PETScMatrix = _la._as_backend_type_PETScMatrix

_has_type_map[PETScMatrix] = _has_type_PETScMatrix
_as_backend_type_map[PETScMatrix] = _as_backend_type_PETScMatrix


def _has_type_PETScLinearOperator(tensor):
    return _la._has_type_PETScLinearOperator(tensor)
_has_type_PETScLinearOperator = _la._has_type_PETScLinearOperator

def _as_backend_type_PETScLinearOperator(tensor):
    return _la._as_backend_type_PETScLinearOperator(tensor)
_as_backend_type_PETScLinearOperator = _la._as_backend_type_PETScLinearOperator

_has_type_map[PETScLinearOperator] = _has_type_PETScLinearOperator
_as_backend_type_map[PETScLinearOperator] = _as_backend_type_PETScLinearOperator


_matrix_vector_mul_map[PETScMatrix] = [PETScVector]
_matrix_vector_mul_map[PETScLinearOperator] = [PETScVector]


def get_tensor_type(tensor):
    "Return the concrete subclass of tensor."
    for k, v in _has_type_map.items():
        if v(tensor):
            return k
    common.dolfin_error("dolfin/swig/la/post.i",
                        "extract backend type for %s" % type(tensor).__name__,
                        "Unable to get tensor type in Python layer")

def has_type(tensor, subclass):
    "Return wether tensor is of the given subclass."
    global _has_type_map
    assert _has_type_map
    assert subclass in _has_type_map
    return bool(_has_type_map[subclass](tensor))

def as_backend_type(tensor, subclass=None):
    "Cast tensor to the given subclass, passing the wrong class is an error."
    global _as_backend_type_map
    assert _as_backend_type_map
    if subclass is None:
        subclass = get_tensor_type(tensor)
    assert subclass in _as_backend_type_map
    ret = _as_backend_type_map[subclass](tensor)

# Store the tensor to avoid garbage collection
    ret._org_upcasted_tensor = tensor
    return ret


class NonlinearProblem(object):
    """

    This is a base class for nonlinear problems which can return the
    nonlinear function F(u) and its Jacobian J = dF(u)/du.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """

        Constructor

        """
        if self.__class__ == NonlinearProblem:
            _self = None
        else:
            _self = self
        _la.NonlinearProblem_swiginit(self, _la.new_NonlinearProblem(_self, ))
    __swig_destroy__ = _la.delete_NonlinearProblem

    def form(self, A, b, x):
        """

        Function called by Newton solver before requesting F or J.
        This can be used to compute F and J together

        """
        return _la.NonlinearProblem_form(self, A, b, x)


    def F(self, b, x):
        """

        Compute F at current point x

        """
        return _la.NonlinearProblem_F(self, b, x)


    def J(self, A, x):
        """

        Compute J = F' at current point x

        """
        return _la.NonlinearProblem_J(self, A, x)

    def __disown__(self):
        self.this.disown()
        _la.disown_NonlinearProblem(self)
        return weakref_proxy(self)
NonlinearProblem.form = new_instancemethod(_la.NonlinearProblem_form, None, NonlinearProblem)
NonlinearProblem.F = new_instancemethod(_la.NonlinearProblem_F, None, NonlinearProblem)
NonlinearProblem.J = new_instancemethod(_la.NonlinearProblem_J, None, NonlinearProblem)
NonlinearProblem_swigregister = _la.NonlinearProblem_swigregister
NonlinearProblem_swigregister(NonlinearProblem)

class NewtonSolver(common.Variable):
    """

    This class defines a Newton solver for nonlinear systems of
    equations of the form :math:`F(x) = 0`.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * NewtonSolver\ ()

          Create nonlinear solver

        * NewtonSolver\ (solver, factory)

          Create nonlinear solver using provided linear solver

          *Arguments*
              solver (:py:class:`GenericLinearSolver`)
                  The linear solver.
              factory (:py:class:`GenericLinearAlgebraFactory`)
                  The factory.

        """
        if self.__class__ == NewtonSolver:
            _self = None
        else:
            _self = self
        _la.NewtonSolver_swiginit(self, _la.new_NewtonSolver(_self, *args))
    __swig_destroy__ = _la.delete_NewtonSolver

    def solve(self, nonlinear_function, x):
        """

        Solve abstract nonlinear problem :math:`F(x) = 0` for given
        :math:`F` and Jacobian :math:`\dfrac{\partial F}{\partial x}`.

        *Arguments*
            nonlinear_function (:py:class:`NonlinearProblem`)
                The nonlinear problem.
            x (:py:class:`GenericVector`)
                The vector.

        *Returns*
            (int, bool)
                Pair of number of Newton iterations, and whether
                iteration converged)

        """
        return _la.NewtonSolver_solve(self, nonlinear_function, x)


    def iteration(self):
        """

        Return Newton iteration number

        *Returns*
            int
                The iteration number.

        """
        return _la.NewtonSolver_iteration(self)


    def residual(self):
        """

        Return current residual

        *Returns*
            float
                Current residual.

        """
        return _la.NewtonSolver_residual(self)


    def relative_residual(self):
        """

        Return current relative residual

        *Returns*
            float
              Current relative residual.

        """
        return _la.NewtonSolver_relative_residual(self)


    def linear_solver(self):
        """

        Return the linear solver

        *Returns*
            :py:class:`GenericLinearSolver`
                The linear solver.

        """
        return _la.NewtonSolver_linear_solver(self)


    def default_parameters():
        """

        Default parameter values

        *Returns*
            :py:class:`Parameters`
                Parameter values.

        """
        return _la.NewtonSolver_default_parameters()

    default_parameters = staticmethod(default_parameters)

    def converged(self, r, nonlinear_problem, iteration):
        """

        Convergence test. It may be overloaded using virtual inheritance and
        this base criterion may be called from derived, both in C++ and Python.

        *Arguments*
            r (:py:class:`GenericVector`)
                Residual for criterion evaluation.
            nonlinear_problem (:py:class:`NonlinearProblem`)
                The nonlinear problem.
            iteration (int)
                Newton iteration number.

        *Returns*
            bool
                Whether convergence occured.

        """
        return _la.NewtonSolver_converged(self, r, nonlinear_problem, iteration)

    def __disown__(self):
        self.this.disown()
        _la.disown_NewtonSolver(self)
        return weakref_proxy(self)
NewtonSolver.solve = new_instancemethod(_la.NewtonSolver_solve, None, NewtonSolver)
NewtonSolver.iteration = new_instancemethod(_la.NewtonSolver_iteration, None, NewtonSolver)
NewtonSolver.residual = new_instancemethod(_la.NewtonSolver_residual, None, NewtonSolver)
NewtonSolver.relative_residual = new_instancemethod(_la.NewtonSolver_relative_residual, None, NewtonSolver)
NewtonSolver.linear_solver = new_instancemethod(_la.NewtonSolver_linear_solver, None, NewtonSolver)
NewtonSolver.converged = new_instancemethod(_la.NewtonSolver_converged, None, NewtonSolver)
NewtonSolver_swigregister = _la.NewtonSolver_swigregister
NewtonSolver_swigregister(NewtonSolver)

def NewtonSolver_default_parameters():
    """

    Default parameter values

    *Returns*
        :py:class:`Parameters`
            Parameter values.

    """
    return _la.NewtonSolver_default_parameters()

class OptimisationProblem(NonlinearProblem):
    """

    This is a base class for nonlinear optimisation problems which
    return the real-valued objective function :math:`f(x)`, its
    gradient :math:`F(x) = f'(x)` and its Hessian :math:`J(x) =
    f''(x)`

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """

        Constructor

        """
        if self.__class__ == OptimisationProblem:
            _self = None
        else:
            _self = self
        _la.OptimisationProblem_swiginit(self, _la.new_OptimisationProblem(_self, ))
    __swig_destroy__ = _la.delete_OptimisationProblem

    def f(self, x):
        """

        Compute the objective function :math:`f(x)`

        """
        return _la.OptimisationProblem_f(self, x)


    def form(self, A, b, x):
        """

        Compute the Hessian :math:`J(x)=f''(x)` and the gradient
        :math:`F(x)=f'(x)`

        """
        return _la.OptimisationProblem_form(self, A, b, x)


    def F(self, b, x):
        """

        Compute the gradient :math:`F(x) = f'(x)`

        """
        return _la.OptimisationProblem_F(self, b, x)


    def J(self, A, x):
        """

        Compute the Hessian :math:`J(x) = f''(x)`

        """
        return _la.OptimisationProblem_J(self, A, x)

    def __disown__(self):
        self.this.disown()
        _la.disown_OptimisationProblem(self)
        return weakref_proxy(self)
OptimisationProblem.f = new_instancemethod(_la.OptimisationProblem_f, None, OptimisationProblem)
OptimisationProblem.form = new_instancemethod(_la.OptimisationProblem_form, None, OptimisationProblem)
OptimisationProblem.F = new_instancemethod(_la.OptimisationProblem_F, None, OptimisationProblem)
OptimisationProblem.J = new_instancemethod(_la.OptimisationProblem_J, None, OptimisationProblem)
OptimisationProblem_swigregister = _la.OptimisationProblem_swigregister
OptimisationProblem_swigregister(OptimisationProblem)

class PETScSNESSolver(PETScObject):
    """

    This class implements methods for solving nonlinear systems via
    PETSc's SNES interface. It includes line search and trust region
    techniques for globalising the convergence of the nonlinear
    iteration.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        Create SNES solver for a particular method

        """
        _la.PETScSNESSolver_swiginit(self, _la.new_PETScSNESSolver(*args))
    __swig_destroy__ = _la.delete_PETScSNESSolver

    def solve(self, *args):
        """

        **Overloaded versions**

        * solve\ (nonlinear_problem, x, lb, ub)

          Solve a nonlinear variational inequality with bound constraints

          *Arguments*
              nonlinear_function (:py:class:`NonlinearProblem`)
                  The nonlinear problem.
              x (:py:class:`GenericVector`)
                  The vector.
              lb (:py:class:`GenericVector`)
                  The lower bound.
              ub (:py:class:`GenericVector`)
                  The upper bound.

          *Returns*
              (int, bool)
                  Pair of number of Newton iterations, and whether
                  iteration converged)

        * solve\ (nonlinear_function, x)

          Solve abstract nonlinear problem :math:`F(x) = 0` for given
          :math:`F` and Jacobian :math:`\dfrac{\partial F}{\partial x}`.

          *Arguments*
              nonlinear_function (:py:class:`NonlinearProblem`)
                  The nonlinear problem.
              x (:py:class:`GenericVector`)
                  The vector.

          *Returns*
              (int, bool)
                  Pair of number of Newton iterations, and whether
                  iteration converged)

        """
        return _la.PETScSNESSolver_solve(self, *args)


    def init(self, nonlinear_problem, x):
        """

        Set up the SNES object, but don't do anything yet, in case the
        user wants to access the SNES object directly

        """
        return _la.PETScSNESSolver_init(self, nonlinear_problem, x)


    def methods():
        """

        Return a list of available solver methods

        """
        return _la.PETScSNESSolver_methods()

    methods = staticmethod(methods)

    def default_parameters():
        """

        Default parameter values

        """
        return _la.PETScSNESSolver_default_parameters()

    default_parameters = staticmethod(default_parameters)
    parameters = _swig_property(_la.PETScSNESSolver_parameters_get, _la.PETScSNESSolver_parameters_set)

    def snes(self):
        """Return petsc4py representation of PETSc SNES solver"""
        return _la.PETScSNESSolver_snes(self)

PETScSNESSolver.solve = new_instancemethod(_la.PETScSNESSolver_solve, None, PETScSNESSolver)
PETScSNESSolver.init = new_instancemethod(_la.PETScSNESSolver_init, None, PETScSNESSolver)
PETScSNESSolver.snes = new_instancemethod(_la.PETScSNESSolver_snes, None, PETScSNESSolver)
PETScSNESSolver_swigregister = _la.PETScSNESSolver_swigregister
PETScSNESSolver_swigregister(PETScSNESSolver)

def PETScSNESSolver_methods():
    """

    Return a list of available solver methods

    """
    return _la.PETScSNESSolver_methods()

def PETScSNESSolver_default_parameters():
    """

    Default parameter values

    """
    return _la.PETScSNESSolver_default_parameters()

class PETScTAOSolver(PETScObject):
    """

    This class implements methods for solving nonlinear optimisation
    problems via PETSc TAO solver. It supports unconstrained as well
    as bound-constrained minimisation problem

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        Create TAO solver for a particular method

        """
        _la.PETScTAOSolver_swiginit(self, _la.new_PETScTAOSolver(*args))
    __swig_destroy__ = _la.delete_PETScTAOSolver

    def solve(self, *args):
        """

        **Overloaded versions**

        * solve\ (optimisation_problem, x, lb, ub)

          Solve a nonlinear bound-constrained optimisation problem

          *Arguments*
              optimisation_problem (:py:class:`OptimisationProblem`)
                  The nonlinear optimisation problem.
              x (:py:class:`GenericVector`)
                  The solution vector (initial guess).
              lb (:py:class:`GenericVector`)
                  The lower bound.
              ub (:py:class:`GenericVector`)
                  The upper bound.

          *Returns*
              num_iterations (std::size_t)
                  Number of iterations

        * solve\ (optimisation_problem, x)

          Solve a nonlinear unconstrained minimisation problem

          *Arguments*
              optimisation_problem (:py:class:`OptimisationProblem`)
                  The nonlinear optimisation problem.
              x (:py:class:`GenericVector`)
                  The solution vector (initial guess).

          *Returns*
              num_iterations (std::size_t)
                  Number of iterations

        * solve\ (optimisation_problem, x, lb, ub)

          Solve a nonlinear bound-constrained minimisation problem

          *Arguments*
              optimisation_problem (:py:class:`OptimisationProblem`)
                  The nonlinear optimisation problem.
              x (:py:class:`PETScVector`)
                  The solution vector (initial guess).
              lb (:py:class:`PETScVector`)
                  The lower bound.
              ub (:py:class:`PETScVector`)
                  The upper bound.

          *Returns*
              num_iterations (std::size_t)
                  Number of iterations

        """
        return _la.PETScTAOSolver_solve(self, *args)


    def methods():
        """

        Return a list of available solver methods

        """
        return _la.PETScTAOSolver_methods()

    methods = staticmethod(methods)

    def default_parameters():
        """

        Default parameter values

        """
        return _la.PETScTAOSolver_default_parameters()

    default_parameters = staticmethod(default_parameters)
    parameters = _swig_property(_la.PETScTAOSolver_parameters_get, _la.PETScTAOSolver_parameters_set)

    def tao(self):
        """

        Return the TAO pointer

        """
        return _la.PETScTAOSolver_tao(self)


    def init(self, *args):
        """

        **Overloaded versions**

        * init\ (optimisation_problem, x, lb, ub)

          Initialise the TAO solver for a bound-constrained minimisation
          problem, in case the user wants to access the TAO object
          directly

        * init\ (optimisation_problem, x)

          Initialise the TAO solver for an unconstrained minimisation
          problem, in case the user wants to access the TAO object
          directly

        """
        return _la.PETScTAOSolver_init(self, *args)

PETScTAOSolver.solve = new_instancemethod(_la.PETScTAOSolver_solve, None, PETScTAOSolver)
PETScTAOSolver.tao = new_instancemethod(_la.PETScTAOSolver_tao, None, PETScTAOSolver)
PETScTAOSolver.init = new_instancemethod(_la.PETScTAOSolver_init, None, PETScTAOSolver)
PETScTAOSolver_swigregister = _la.PETScTAOSolver_swigregister
PETScTAOSolver_swigregister(PETScTAOSolver)

def PETScTAOSolver_methods():
    """

    Return a list of available solver methods

    """
    return _la.PETScTAOSolver_methods()

def PETScTAOSolver_default_parameters():
    """

    Default parameter values

    """
    return _la.PETScTAOSolver_default_parameters()

class TAOLinearBoundSolver(common.Variable, PETScObject):
    """

    This class provides a bound constrained solver for a
    linear variational inequality defined by a matrix A and a vector b.
    It solves the problem:

    Find :math:`x_l\leq x\leq x_u` such that
    :math:`(Ax-b)\cdot (y-x)\geq 0,\; orall x_l\leq y\leq x_u`

    It is a wrapper for the TAO bound constrained solver.

    *Example*
        .. note::

            No example code available for this function.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        Create TAO bound constrained solver

        """
        _la.TAOLinearBoundSolver_swiginit(self, _la.new_TAOLinearBoundSolver(*args))
    __swig_destroy__ = _la.delete_TAOLinearBoundSolver

    def solve(self, *args):
        """

        **Overloaded versions**

        * solve\ (A, x, b, xl, xu)

          Solve the linear variational inequality defined by A and b
          with xl =< x <= xu

        * solve\ (A, x, b, xl, xu)

          Solve the linear variational inequality defined by A and b
          with xl =< x <= xu

        """
        return _la.TAOLinearBoundSolver_solve(self, *args)


    def set_ksp(self, *args):
        """

        Set PETSC Krylov Solver (ksp) used by TAO

        """
        return _la.TAOLinearBoundSolver_set_ksp(self, *args)


    def methods():
        """

        Return a list of available Tao solver methods

        """
        return _la.TAOLinearBoundSolver_methods()

    methods = staticmethod(methods)

    def krylov_solvers():
        """

        Return a list of available krylov solvers

        """
        return _la.TAOLinearBoundSolver_krylov_solvers()

    krylov_solvers = staticmethod(krylov_solvers)

    def preconditioners():
        """

        Return a list of available preconditioners

        """
        return _la.TAOLinearBoundSolver_preconditioners()

    preconditioners = staticmethod(preconditioners)

    def default_parameters():
        """

        Default parameter values

        """
        return _la.TAOLinearBoundSolver_default_parameters()

    default_parameters = staticmethod(default_parameters)
TAOLinearBoundSolver.solve = new_instancemethod(_la.TAOLinearBoundSolver_solve, None, TAOLinearBoundSolver)
TAOLinearBoundSolver.set_solver = new_instancemethod(_la.TAOLinearBoundSolver_set_solver, None, TAOLinearBoundSolver)
TAOLinearBoundSolver.set_ksp = new_instancemethod(_la.TAOLinearBoundSolver_set_ksp, None, TAOLinearBoundSolver)
TAOLinearBoundSolver.tao = new_instancemethod(_la.TAOLinearBoundSolver_tao, None, TAOLinearBoundSolver)
TAOLinearBoundSolver.get_matrix = new_instancemethod(_la.TAOLinearBoundSolver_get_matrix, None, TAOLinearBoundSolver)
TAOLinearBoundSolver.get_vector = new_instancemethod(_la.TAOLinearBoundSolver_get_vector, None, TAOLinearBoundSolver)
TAOLinearBoundSolver_swigregister = _la.TAOLinearBoundSolver_swigregister
TAOLinearBoundSolver_swigregister(TAOLinearBoundSolver)

def TAOLinearBoundSolver_methods():
    """

    Return a list of available Tao solver methods

    """
    return _la.TAOLinearBoundSolver_methods()

def TAOLinearBoundSolver_krylov_solvers():
    """

    Return a list of available krylov solvers

    """
    return _la.TAOLinearBoundSolver_krylov_solvers()

def TAOLinearBoundSolver_preconditioners():
    """

    Return a list of available preconditioners

    """
    return _la.TAOLinearBoundSolver_preconditioners()

def TAOLinearBoundSolver_default_parameters():
    """

    Default parameter values

    """
    return _la.TAOLinearBoundSolver_default_parameters()



