# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _common.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_common', [dirname(__file__)])
        except ImportError:
            import _common
            return _common
        if fp is not None:
            try:
                _mod = imp.load_module('_common', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _common = swig_import_helper()
    del swig_import_helper
else:
    import _common
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0



def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except Exception:
    weakref_proxy = lambda x: x



_common.SHARED_PTR_DISOWN_swigconstant(_common)
SHARED_PTR_DISOWN = _common.SHARED_PTR_DISOWN
import ufc

def _attach_base_to_numpy_array(obj, owner):
    return _common._attach_base_to_numpy_array(obj, owner)
_attach_base_to_numpy_array = _common._attach_base_to_numpy_array

def dolfin_swigversion():
    return _common.dolfin_swigversion()
dolfin_swigversion = _common.dolfin_swigversion

def dolfin_pythonversion():
    return _common.dolfin_pythonversion()
dolfin_pythonversion = _common.dolfin_pythonversion

tmp = hex(dolfin_swigversion())
__swigversion__ = "%d.%d.%d"%(tuple(map(int, [tmp[-5], tmp[-3], tmp[-2:]])))
tmp = hex(dolfin_pythonversion())
__pythonversion__ = "%d.%d.%d"%(tuple(map(lambda x: int(x,16), [tmp[2], tmp[3:5], tmp[5:7]])))
del tmp, dolfin_pythonversion, dolfin_swigversion


def has_petsc4py():
    return _common.has_petsc4py()
has_petsc4py = _common.has_petsc4py

def has_slepc4py():
    return _common.has_slepc4py()
has_slepc4py = _common.has_slepc4py

def init(argc, argv):
    """

    Initialize DOLFIN (and PETSc) with command-line arguments. This
    should not be needed in most cases since the initialization is
    otherwise handled automatically.

    """
    return _common.init(argc, argv)

def dolfin_version():
    """

    Return DOLFIN version string

    """
    return _common.dolfin_version()

def git_commit_hash():
    """

    Return git changeset hash (returns "unknown" if changeset is
    not known)

    """
    return _common.git_commit_hash()

def sizeof_la_index():
    """

    Return sizeof the dolfin::la_index type

    """
    return _common.sizeof_la_index()

def has_openmp():
    """

    Return true if DOLFIN is compiled with OpenMP

    """
    return _common.has_openmp()

def has_mpi():
    """

    Return true if DOLFIN is compiled with MPI

    """
    return _common.has_mpi()

def has_petsc():
    """

    Return true if DOLFIN is compiled with PETSc

    """
    return _common.has_petsc()

def has_tao():
    """

    Return true if DOLFIN is compiled with PETSc and PETSc version
    provides TAO

    """
    return _common.has_tao()

def has_slepc():
    """

    Return true if DOLFIN is compiled with SLEPc

    """
    return _common.has_slepc()

def has_scotch():
    """

    Return true if DOLFIN is compiled with Scotch

    """
    return _common.has_scotch()

def has_umfpack():
    """

    Return true if DOLFIN is compiled with Umfpack

    """
    return _common.has_umfpack()

def has_cholmod():
    """

    Return true if DOLFIN is compiled with Cholmod

    """
    return _common.has_cholmod()

def has_parmetis():
    """

    Return true if DOLFIN is compiled with ParMETIS

    """
    return _common.has_parmetis()

def has_zlib():
    """

    Return true if DOLFIN is compiled with ZLIB

    """
    return _common.has_zlib()

def has_hdf5():
    """

    Return true if DOLFIN is compiled with HDF5

    """
    return _common.has_hdf5()

_common.DOLFIN_VERSION_RELEASE_swigconstant(_common)
DOLFIN_VERSION_RELEASE = _common.DOLFIN_VERSION_RELEASE

_common.DOLFIN_VERSION_MAJOR_swigconstant(_common)
DOLFIN_VERSION_MAJOR = _common.DOLFIN_VERSION_MAJOR

_common.DOLFIN_VERSION_MINOR_swigconstant(_common)
DOLFIN_VERSION_MINOR = _common.DOLFIN_VERSION_MINOR

_common.DOLFIN_VERSION_MICRO_swigconstant(_common)
DOLFIN_VERSION_MICRO = _common.DOLFIN_VERSION_MICRO

_common.DOLFIN_VERSION_STRING_swigconstant(_common)
DOLFIN_VERSION_STRING = _common.DOLFIN_VERSION_STRING

_common.DOLFIN_VERSION_GIT_swigconstant(_common)
DOLFIN_VERSION_GIT = _common.DOLFIN_VERSION_GIT

_common.DOLFIN_EPS_swigconstant(_common)
DOLFIN_EPS = _common.DOLFIN_EPS

_common.DOLFIN_EPS_LARGE_swigconstant(_common)
DOLFIN_EPS_LARGE = _common.DOLFIN_EPS_LARGE

_common.DOLFIN_SQRT_EPS_swigconstant(_common)
DOLFIN_SQRT_EPS = _common.DOLFIN_SQRT_EPS

_common.DOLFIN_PI_swigconstant(_common)
DOLFIN_PI = _common.DOLFIN_PI

_common.DOLFIN_LINELENGTH_swigconstant(_common)
DOLFIN_LINELENGTH = _common.DOLFIN_LINELENGTH

_common.DOLFIN_TERM_WIDTH_swigconstant(_common)
DOLFIN_TERM_WIDTH = _common.DOLFIN_TERM_WIDTH

_common.TimingClear_keep_swigconstant(_common)
TimingClear_keep = _common.TimingClear_keep

_common.TimingClear_clear_swigconstant(_common)
TimingClear_clear = _common.TimingClear_clear

_common.TimingType_wall_swigconstant(_common)
TimingType_wall = _common.TimingType_wall

_common.TimingType_user_swigconstant(_common)
TimingType_user = _common.TimingType_user

_common.TimingType_system_swigconstant(_common)
TimingType_system = _common.TimingType_system

def tic():
    """

    Start timing (should not be used internally in DOLFIN!)

    """
    return _common.tic()

def toc():
    """

    Return elapsed wall time (should not be used internally in DOLFIN!)

    """
    return _common.toc()

def time():
    """

    Return wall time elapsed since some implementation dependent epoch

    """
    return _common.time()

def timings(clear, type):
    """

    Return a summary of timings and tasks in a :py:class:`Table`, optionally clearing
    stored timings

    *Arguments*
        clear (TimingClear)
            * ``TimingClear::clear`` resets stored timings
            * ``TimingClear::keep`` leaves stored timings intact
        type (std::set<TimingType>)
            subset of ``{ TimingType::wall, TimingType::user,
            TimingType::system }``

    *Returns*
        :py:class:`Table`
            :py:class:`Table` with timings

    """
    return _common.timings(clear, type)

def list_timings(*args):
    """

    **Overloaded versions**

    * list_timings\ (reset=false)

      **DEPRECATED**: List a summary of timings and tasks, optionally clearing
      stored timings. ``MPI_AVG`` reduction is printed. Collective on
      ``MPI_COMM_WORLD``. Only wall time is printed.

    * list_timings\ (clear, type)

      List a summary of timings and tasks, optionally clearing stored timings.
      ``MPI_AVG`` reduction is printed. Collective on ``MPI_COMM_WORLD``.

      *Arguments*
          clear (TimingClear)
              * ``TimingClear::clear`` resets stored timings
              * ``TimingClear::keep`` leaves stored timings intact
          type (std::set<TimingType>)
              subset of ``{ TimingType::wall, TimingType::user,
              TimingType::system }``

    """
    return _common.list_timings(*args)

def dump_timings_to_xml(filename, clear):
    """

    Dump a summary of timings and tasks to XML file, optionally clearing
    stored timings. ``MPI_MAX``, ``MPI_MIN`` and ``MPI_AVG`` reductions are
    stored. Collective on ``MPI_COMM_WORLD``.

    *Arguments*
        filename (str)
            output filename; must have ``.xml`` suffix; existing file
            is silently overwritten
        clear (TimingClear)
            * ``TimingClear::clear`` resets stored timings
            * ``TimingClear::keep`` leaves stored timings intact

    """
    return _common.dump_timings_to_xml(filename, clear)

def timing(task, clear):
    """

    Return timing (count, total wall time, total user time,
    total system time) for given task, optionally clearing
    all timings for the task

    *Arguments*
        task (str)
            name of a task
        clear (TimingClear)
            * ``TimingClear::clear`` resets stored timings
            * ``TimingClear::keep`` leaves stored timings intact

    *Returns*
        std::tuple<std::size_t, double, double, double>
            (count, total wall time, total user time, total system time)

    """
    return _common.timing(task, clear)
class IndexSet(object):
    """

    This class provides an efficient data structure for index sets.
    The cost of checking whether a given index is in the set is O(1)
    and very very fast (optimal) at the cost of extra storage.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, size):
        """

        Create index set of given size

        """
        _common.IndexSet_swiginit(self, _common.new_IndexSet(size))
    __swig_destroy__ = _common.delete_IndexSet

    def empty(self):
        """

        Return true if set is empty

        """
        return _common.IndexSet_empty(self)


    def size(self):
        """

        Return size of set

        """
        return _common.IndexSet_size(self)


    def has_index(self, index):
        """

        Check whether index is in set

        """
        return _common.IndexSet_has_index(self, index)


    def find(self, index):
        """

        Return position (if any) for given index

        """
        return _common.IndexSet_find(self, index)


    def insert(self, index):
        """

        Insert index into set

        """
        return _common.IndexSet_insert(self, index)


    def fill(self):
        """

        Fill index set with indices 0, 1, 2, ..., size - 1

        """
        return _common.IndexSet_fill(self)


    def clear(self):
        """

        Clear set

        """
        return _common.IndexSet_clear(self)

IndexSet.empty = new_instancemethod(_common.IndexSet_empty, None, IndexSet)
IndexSet.size = new_instancemethod(_common.IndexSet_size, None, IndexSet)
IndexSet.has_index = new_instancemethod(_common.IndexSet_has_index, None, IndexSet)
IndexSet.find = new_instancemethod(_common.IndexSet_find, None, IndexSet)
IndexSet.insert = new_instancemethod(_common.IndexSet_insert, None, IndexSet)
IndexSet.fill = new_instancemethod(_common.IndexSet_fill, None, IndexSet)
IndexSet.clear = new_instancemethod(_common.IndexSet_clear, None, IndexSet)
IndexSet_swigregister = _common.IndexSet_swigregister
IndexSet_swigregister(IndexSet)

class Timer(object):
    """

    A timer can be used for timing tasks. The basic usage is

      Timer timer("Assembling over cells");

    The timer is started at construction and timing ends
    when the timer is destroyed (goes out of scope). It is
    also possible to start and stop a timer explicitly by

      timer.start();
      timer.stop();

    Timings are stored globally and a summary may be printed
    by calling

      list_timings();

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * Timer\ ()

          Create timer without logging

        * Timer\ (task)

          Create timer with logging

        """
        _common.Timer_swiginit(self, _common.new_Timer(*args))
    __swig_destroy__ = _common.delete_Timer

    def start(self):
        """

        Zero and start timer

        """
        return _common.Timer_start(self)


    def resume(self):
        """

        Resume timer. Not well-defined for logging timer

        """
        return _common.Timer_resume(self)


    def stop(self):
        """

        Stop timer, return wall time elapsed and store timing data
        into logger

        """
        return _common.Timer_stop(self)


    def value(self):
        """

        DEPRECATED: Return value of timer (or time at start if not stopped)

        """
        return _common.Timer_value(self)


    def elapsed(self):
        """

        Return wall, user and system time in seconds. Wall-clock time
        has precision around 1 microsecond; user and system around
        10 millisecond.

        """
        return _common.Timer_elapsed(self)

Timer.start = new_instancemethod(_common.Timer_start, None, Timer)
Timer.resume = new_instancemethod(_common.Timer_resume, None, Timer)
Timer.stop = new_instancemethod(_common.Timer_stop, None, Timer)
Timer.value = new_instancemethod(_common.Timer_value, None, Timer)
Timer.elapsed = new_instancemethod(_common.Timer_elapsed, None, Timer)
Timer_swigregister = _common.Timer_swigregister
Timer_swigregister(Timer)

class Variable(object):
    """

    Common base class for DOLFIN variables.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * Variable\ ()

          Create unnamed variable

        * Variable\ (name, label)

          Create variable with given name and label

        * Variable\ (variable)

          Copy constructor

        """
        _common.Variable_swiginit(self, _common.new_Variable(*args))
    __swig_destroy__ = _common.delete_Variable

    def rename(self, name, label):
        """

        Rename variable

        """
        return _common.Variable_rename(self, name, label)


    def name(self):
        """

        Return name

        """
        return _common.Variable_name(self)


    def label(self):
        """

        Return label (description)

        """
        return _common.Variable_label(self)


    def id(self):
        """

        Get unique identifier.

        *Returns*
            _std::size_t_
                The unique integer identifier associated with the object.

        """
        return _common.Variable_id(self)


    def str(self, verbose):
        """

        Return informal string representation (pretty-print)

        """
        return _common.Variable_str(self, verbose)

    parameters = _swig_property(_common.Variable_parameters_get, _common.Variable_parameters_set)

    def __str__(self):
        """Missing docstring"""
        return _common.Variable___str__(self)

Variable.rename = new_instancemethod(_common.Variable_rename, None, Variable)
Variable.name = new_instancemethod(_common.Variable_name, None, Variable)
Variable.label = new_instancemethod(_common.Variable_label, None, Variable)
Variable.id = new_instancemethod(_common.Variable_id, None, Variable)
Variable.str = new_instancemethod(_common.Variable_str, None, Variable)
Variable.__str__ = new_instancemethod(_common.Variable___str__, None, Variable)
Variable_swigregister = _common.Variable_swigregister
Variable_swigregister(Variable)


_common.MPICH_IGNORE_CXX_SEEK_swigconstant(_common)
MPICH_IGNORE_CXX_SEEK = _common.MPICH_IGNORE_CXX_SEEK
class MPIInfo(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        _common.MPIInfo_swiginit(self, _common.new_MPIInfo())
    __swig_destroy__ = _common.delete_MPIInfo
MPIInfo.__ref__ = new_instancemethod(_common.MPIInfo___ref__, None, MPIInfo)
MPIInfo_swigregister = _common.MPIInfo_swigregister
MPIInfo_swigregister(MPIInfo)

class MPI(object):
    """

    This class provides utility functions for easy communication
    with MPI and handles cases when DOLFIN is not configured with
    MPI.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def rank(comm):
        """

        Return process rank for the communicator

        """
        return _common.MPI_rank(comm)

    rank = staticmethod(rank)

    def size(comm):
        """

        Return size of the group (number of processes) associated with
        the communicator

        """
        return _common.MPI_size(comm)

    size = staticmethod(size)

    def is_broadcaster(comm):
        """

        Determine whether we should broadcast (based on current
        parallel policy)

        """
        return _common.MPI_is_broadcaster(comm)

    is_broadcaster = staticmethod(is_broadcaster)

    def is_receiver(comm):
        """

        Determine whether we should receive (based on current parallel
        policy)

        """
        return _common.MPI_is_receiver(comm)

    is_receiver = staticmethod(is_receiver)

    def barrier(comm):
        """

        Set a barrier (synchronization point)

        """
        return _common.MPI_barrier(comm)

    barrier = staticmethod(barrier)

    def gather(comm, in_values, out_values, receiving_process=0):
        """

        **Overloaded versions**

        * gather\ (comm, in_values, out_values, receiving_process=0)

          Gather values on one process

        * gather\ (comm, in_values, out_values, receiving_process=0)

          Gather strings on one process

        """
        return _common.MPI_gather(comm, in_values, out_values, receiving_process)

    gather = staticmethod(gather)

    def global_offset(comm, range, exclusive):
        """

        Find global offset (index) (wrapper for MPI_(Ex)Scan with
        MPI_SUM as reduction op)

        """
        return _common.MPI_global_offset(comm, range, exclusive)

    global_offset = staticmethod(global_offset)

    def local_range(*args):
        """

        **Overloaded versions**

        * local_range\ (comm, N)

          Return local range for local process, splitting [0, N - 1] into
          size() portions of almost equal size

        * local_range\ (comm, process, N)

          Return local range for given process, splitting [0, N - 1] into
          size() portions of almost equal size

        """
        return _common.MPI_local_range(*args)

    local_range = staticmethod(local_range)

    def compute_local_range(process, N, size):
        """

        Return local range for given process, splitting [0, N - 1] into
        size() portions of almost equal size

        """
        return _common.MPI_compute_local_range(process, N, size)

    compute_local_range = staticmethod(compute_local_range)

    def index_owner(comm, index, N):
        """

        Return which process owns index (inverse of local_range)

        """
        return _common.MPI_index_owner(comm, index, N)

    index_owner = staticmethod(index_owner)

    def MPI_AVG():
        """

        Return average reduction operation; recognized by
        all_reduce(MPI_Comm, Table&, MPI_Op)

        """
        return _common.MPI_MPI_AVG()

    MPI_AVG = staticmethod(MPI_AVG)

    def max(*args):
        """

        Return global max value

        """
        return _common.MPI_max(*args)

    max = staticmethod(max)

    def min(*args):
        """

        Return global min value

        """
        return _common.MPI_min(*args)

    min = staticmethod(min)

    def sum(*args):
        """

        Sum values and return sum

        """
        return _common.MPI_sum(*args)

    sum = staticmethod(sum)

    def avg(comm, value):
        """

        Return average across comm; implemented only for T == Table

        """
        return _common.MPI_avg(comm, value)

    avg = staticmethod(avg)

    def __init__(self):
        _common.MPI_swiginit(self, _common.new_MPI())
    __swig_destroy__ = _common.delete_MPI
MPI_swigregister = _common.MPI_swigregister
MPI_swigregister(MPI)

def MPI_rank(comm):
    """

    Return process rank for the communicator

    """
    return _common.MPI_rank(comm)

def MPI_size(comm):
    """

    Return size of the group (number of processes) associated with
    the communicator

    """
    return _common.MPI_size(comm)

def MPI_is_broadcaster(comm):
    """

    Determine whether we should broadcast (based on current
    parallel policy)

    """
    return _common.MPI_is_broadcaster(comm)

def MPI_is_receiver(comm):
    """

    Determine whether we should receive (based on current parallel
    policy)

    """
    return _common.MPI_is_receiver(comm)

def MPI_barrier(comm):
    """

    Set a barrier (synchronization point)

    """
    return _common.MPI_barrier(comm)

def MPI_gather(comm, in_values, out_values, receiving_process=0):
    """

    **Overloaded versions**

    * gather\ (comm, in_values, out_values, receiving_process=0)

      Gather values on one process

    * gather\ (comm, in_values, out_values, receiving_process=0)

      Gather strings on one process

    """
    return _common.MPI_gather(comm, in_values, out_values, receiving_process)

def MPI_global_offset(comm, range, exclusive):
    """

    Find global offset (index) (wrapper for MPI_(Ex)Scan with
    MPI_SUM as reduction op)

    """
    return _common.MPI_global_offset(comm, range, exclusive)

def MPI_local_range(*args):
    """

    **Overloaded versions**

    * local_range\ (comm, N)

      Return local range for local process, splitting [0, N - 1] into
      size() portions of almost equal size

    * local_range\ (comm, process, N)

      Return local range for given process, splitting [0, N - 1] into
      size() portions of almost equal size

    """
    return _common.MPI_local_range(*args)

def MPI_compute_local_range(process, N, size):
    """

    Return local range for given process, splitting [0, N - 1] into
    size() portions of almost equal size

    """
    return _common.MPI_compute_local_range(process, N, size)

def MPI_index_owner(comm, index, N):
    """

    Return which process owns index (inverse of local_range)

    """
    return _common.MPI_index_owner(comm, index, N)

def MPI_MPI_AVG():
    """

    Return average reduction operation; recognized by
    all_reduce(MPI_Comm, Table&, MPI_Op)

    """
    return _common.MPI_MPI_AVG()

def MPI_max(*args):
    """

    Return global max value

    """
    return _common.MPI_max(*args)

def MPI_min(*args):
    """

    Return global min value

    """
    return _common.MPI_min(*args)

def MPI_sum(*args):
    """

    Sum values and return sum

    """
    return _common.MPI_sum(*args)

def MPI_avg(comm, value):
    """

    Return average across comm; implemented only for T == Table

    """
    return _common.MPI_avg(comm, value)

class SubSystemsManager(object):
    """

    This is a singleton class which manages the initialisation and
    finalisation of various sub systems, such as MPI and PETSc.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def init_mpi(*args):
        """

        **Overloaded versions**

        * init_mpi\ ()

          Initialise MPI

        * init_mpi\ (argc, argv[], required_thread_level)

          Initialise MPI with required level of thread support

        """
        return _common.SubSystemsManager_init_mpi(*args)

    init_mpi = staticmethod(init_mpi)

    def init_petsc(*args):
        """

        **Overloaded versions**

        * init_petsc\ ()

          Initialize PETSc without command-line arguments

        * init_petsc\ (argc, argv[])

          Initialize PETSc with command-line arguments. Note that PETSc
          command-line arguments may also be filtered and sent to PETSc
          by parameters.parse(argc, argv).

        """
        return _common.SubSystemsManager_init_petsc(*args)

    init_petsc = staticmethod(init_petsc)

    def finalize():
        """

        Finalize subsystems. This will be called by the destructor, but in
        special cases it may be necessary to call finalize() explicitly.

        """
        return _common.SubSystemsManager_finalize()

    finalize = staticmethod(finalize)

    def responsible_mpi():
        """

        Return true if DOLFIN initialised MPI (and is therefore responsible
        for finalization)

        """
        return _common.SubSystemsManager_responsible_mpi()

    responsible_mpi = staticmethod(responsible_mpi)

    def responsible_petsc():
        """

        Return true if DOLFIN initialised PETSc (and is therefore
        responsible for finalization)

        """
        return _common.SubSystemsManager_responsible_petsc()

    responsible_petsc = staticmethod(responsible_petsc)

    def mpi_initialized():
        """

        Check if MPI has been initialised (returns true if MPI has been
        initialised, even if it is later finalised)

        """
        return _common.SubSystemsManager_mpi_initialized()

    mpi_initialized = staticmethod(mpi_initialized)

    def mpi_finalized():
        """

        Check if MPI has been finalized (returns true if MPI has been
        finalised)

        """
        return _common.SubSystemsManager_mpi_finalized()

    mpi_finalized = staticmethod(mpi_finalized)
SubSystemsManager_swigregister = _common.SubSystemsManager_swigregister
SubSystemsManager_swigregister(SubSystemsManager)

def SubSystemsManager_init_mpi(*args):
    """

    **Overloaded versions**

    * init_mpi\ ()

      Initialise MPI

    * init_mpi\ (argc, argv[], required_thread_level)

      Initialise MPI with required level of thread support

    """
    return _common.SubSystemsManager_init_mpi(*args)

def SubSystemsManager_init_petsc(*args):
    """

    **Overloaded versions**

    * init_petsc\ ()

      Initialize PETSc without command-line arguments

    * init_petsc\ (argc, argv[])

      Initialize PETSc with command-line arguments. Note that PETSc
      command-line arguments may also be filtered and sent to PETSc
      by parameters.parse(argc, argv).

    """
    return _common.SubSystemsManager_init_petsc(*args)

def SubSystemsManager_finalize():
    """

    Finalize subsystems. This will be called by the destructor, but in
    special cases it may be necessary to call finalize() explicitly.

    """
    return _common.SubSystemsManager_finalize()

def SubSystemsManager_responsible_mpi():
    """

    Return true if DOLFIN initialised MPI (and is therefore responsible
    for finalization)

    """
    return _common.SubSystemsManager_responsible_mpi()

def SubSystemsManager_responsible_petsc():
    """

    Return true if DOLFIN initialised PETSc (and is therefore
    responsible for finalization)

    """
    return _common.SubSystemsManager_responsible_petsc()

def SubSystemsManager_mpi_initialized():
    """

    Check if MPI has been initialised (returns true if MPI has been
    initialised, even if it is later finalised)

    """
    return _common.SubSystemsManager_mpi_initialized()

def SubSystemsManager_mpi_finalized():
    """

    Check if MPI has been finalized (returns true if MPI has been
    finalised)

    """
    return _common.SubSystemsManager_mpi_finalized()

class MPI_Comm(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        _common.MPI_Comm_swiginit(self, _common.new_MPI_Comm())
    __swig_destroy__ = _common.delete_MPI_Comm
MPI_Comm_swigregister = _common.MPI_Comm_swigregister
MPI_Comm_swigregister(MPI_Comm)


def mpi_comm_world():
    return _common.mpi_comm_world()
mpi_comm_world = _common.mpi_comm_world

def mpi_comm_self():
    return _common.mpi_comm_self()
mpi_comm_self = _common.mpi_comm_self
class DoubleArray(object):
    """

    This class provides a simple wrapper for a pointer to an array. A
    purpose of this class is to enable the simple and safe exchange
    of data between C++ and Python.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * Array\ (N)

          Create array of size N. Array has ownership.

        * Array\ (N, x)

          Construct array from a pointer. Array does not take ownership.

        * Array\ (other)

          Disable copy construction, to avoid unanticipated sharing or
          copying of data. This means that an Array must always be passed as
          reference, or as a (possibly shared) pointer.

        """
        _common.DoubleArray_swiginit(self, _common.new_DoubleArray(*args))
    __swig_destroy__ = _common.delete_DoubleArray

    def str(self, verbose):
        """

        Return informal string representation (pretty-print).
        Note that the Array class is not a subclass of Variable (for
        efficiency) which means that one needs to call str() directly
        instead of using the info() function on Array objects.

        """
        return _common.DoubleArray_str(self, verbose)


    def size(self):
        """

        Return size of array

        """
        return _common.DoubleArray_size(self)


    def data(self, *args):
        """

        **Overloaded versions**

        * data\ ()

          Return pointer to data (const version)

        * data\ ()

          Return pointer to data (non-const version)

        """
        return _common.DoubleArray_data(self, *args)


    def array(self):
        """
        Return a NumPy array view of object
        """
        data = self._array()
        _attach_base_to_numpy_array(data, self)
        return data

    def __getitem__(self, index):
        if not isinstance(index, int):
            raise TypeError("expected an int as index argument")
        while index < 0:
            index += self.size()
        if index >= self.size():
            raise IndexError("index out of range")
        return self._getitem(index)

    def __setitem__(self, index, value):
        if not isinstance(index, int):
            raise TypeError("expected an int as index argument")
        while index < 0:
            index += self.size()
        if index >= self.size():
            raise IndexError("index out of range")
        self._setitem(index, value)

    def __len__(self):
        return self.size()

DoubleArray.str = new_instancemethod(_common.DoubleArray_str, None, DoubleArray)
DoubleArray.size = new_instancemethod(_common.DoubleArray_size, None, DoubleArray)
DoubleArray.data = new_instancemethod(_common.DoubleArray_data, None, DoubleArray)
DoubleArray._getitem = new_instancemethod(_common.DoubleArray__getitem, None, DoubleArray)
DoubleArray._setitem = new_instancemethod(_common.DoubleArray__setitem, None, DoubleArray)
DoubleArray._array = new_instancemethod(_common.DoubleArray__array, None, DoubleArray)
DoubleArray_swigregister = _common.DoubleArray_swigregister
DoubleArray_swigregister(DoubleArray)

class UIntArray(object):
    """

    This class provides a simple wrapper for a pointer to an array. A
    purpose of this class is to enable the simple and safe exchange
    of data between C++ and Python.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * Array\ (N)

          Create array of size N. Array has ownership.

        * Array\ (N, x)

          Construct array from a pointer. Array does not take ownership.

        * Array\ (other)

          Disable copy construction, to avoid unanticipated sharing or
          copying of data. This means that an Array must always be passed as
          reference, or as a (possibly shared) pointer.

        """
        _common.UIntArray_swiginit(self, _common.new_UIntArray(*args))
    __swig_destroy__ = _common.delete_UIntArray

    def str(self, verbose):
        """

        Return informal string representation (pretty-print).
        Note that the Array class is not a subclass of Variable (for
        efficiency) which means that one needs to call str() directly
        instead of using the info() function on Array objects.

        """
        return _common.UIntArray_str(self, verbose)


    def size(self):
        """

        Return size of array

        """
        return _common.UIntArray_size(self)


    def data(self, *args):
        """

        **Overloaded versions**

        * data\ ()

          Return pointer to data (const version)

        * data\ ()

          Return pointer to data (non-const version)

        """
        return _common.UIntArray_data(self, *args)


    def array(self):
        """
        Return a NumPy array view of object
        """
        data = self._array()
        _attach_base_to_numpy_array(data, self)
        return data

    def __getitem__(self, index):
        if not isinstance(index, int):
            raise TypeError("expected an int as index argument")
        while index < 0:
            index += self.size()
        if index >= self.size():
            raise IndexError("index out of range")
        return self._getitem(index)

    def __setitem__(self, index, value):
        if not isinstance(index, int):
            raise TypeError("expected an int as index argument")
        while index < 0:
            index += self.size()
        if index >= self.size():
            raise IndexError("index out of range")
        self._setitem(index, value)

    def __len__(self):
        return self.size()

UIntArray.str = new_instancemethod(_common.UIntArray_str, None, UIntArray)
UIntArray.size = new_instancemethod(_common.UIntArray_size, None, UIntArray)
UIntArray.data = new_instancemethod(_common.UIntArray_data, None, UIntArray)
UIntArray._getitem = new_instancemethod(_common.UIntArray__getitem, None, UIntArray)
UIntArray._setitem = new_instancemethod(_common.UIntArray__setitem, None, UIntArray)
UIntArray._array = new_instancemethod(_common.UIntArray__array, None, UIntArray)
UIntArray_swigregister = _common.UIntArray_swigregister
UIntArray_swigregister(UIntArray)

class IntArray(object):
    """

    This class provides a simple wrapper for a pointer to an array. A
    purpose of this class is to enable the simple and safe exchange
    of data between C++ and Python.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * Array\ (N)

          Create array of size N. Array has ownership.

        * Array\ (N, x)

          Construct array from a pointer. Array does not take ownership.

        * Array\ (other)

          Disable copy construction, to avoid unanticipated sharing or
          copying of data. This means that an Array must always be passed as
          reference, or as a (possibly shared) pointer.

        """
        _common.IntArray_swiginit(self, _common.new_IntArray(*args))
    __swig_destroy__ = _common.delete_IntArray

    def str(self, verbose):
        """

        Return informal string representation (pretty-print).
        Note that the Array class is not a subclass of Variable (for
        efficiency) which means that one needs to call str() directly
        instead of using the info() function on Array objects.

        """
        return _common.IntArray_str(self, verbose)


    def size(self):
        """

        Return size of array

        """
        return _common.IntArray_size(self)


    def data(self, *args):
        """

        **Overloaded versions**

        * data\ ()

          Return pointer to data (const version)

        * data\ ()

          Return pointer to data (non-const version)

        """
        return _common.IntArray_data(self, *args)


    def array(self):
        """
        Return a NumPy array view of object
        """
        data = self._array()
        _attach_base_to_numpy_array(data, self)
        return data

    def __getitem__(self, index):
        if not isinstance(index, int):
            raise TypeError("expected an int as index argument")
        while index < 0:
            index += self.size()
        if index >= self.size():
            raise IndexError("index out of range")
        return self._getitem(index)

    def __setitem__(self, index, value):
        if not isinstance(index, int):
            raise TypeError("expected an int as index argument")
        while index < 0:
            index += self.size()
        if index >= self.size():
            raise IndexError("index out of range")
        self._setitem(index, value)

    def __len__(self):
        return self.size()

IntArray.str = new_instancemethod(_common.IntArray_str, None, IntArray)
IntArray.size = new_instancemethod(_common.IntArray_size, None, IntArray)
IntArray.data = new_instancemethod(_common.IntArray_data, None, IntArray)
IntArray._getitem = new_instancemethod(_common.IntArray__getitem, None, IntArray)
IntArray._setitem = new_instancemethod(_common.IntArray__setitem, None, IntArray)
IntArray._array = new_instancemethod(_common.IntArray__array, None, IntArray)
IntArray_swigregister = _common.IntArray_swigregister
IntArray_swigregister(IntArray)


for f in [timings, list_timings, dump_timings_to_xml, timing]:
    doc = f.__doc__
    doc = doc.replace("TimingType::", "TimingType_")
    doc = doc.replace("TimingClear::", "TimingClear_")
    doc = doc.replace("std::set<TimingType>", "list")
    doc = doc.replace("{ ", "[")
    doc = doc.replace(" }", "]")
    f.__doc__ = doc
    del doc

class ParameterValue(object):
    """

    Base class for parameters.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_ParameterValue

    def key(self):
        """

        Return parameter key

        """
        return _common.ParameterValue_key(self)


    def description(self):
        """

        Return parameter description

        """
        return _common.ParameterValue_description(self)


    def is_set(self):
        """

        Return true if parameter is set, return false otherwise

        """
        return _common.ParameterValue_is_set(self)


    def reset(self):
        """

        Reset the parameter to empty, so that is_set() returns false.

        """
        return _common.ParameterValue_reset(self)


    def access_count(self):
        """

        Return access count (number of times parameter has been accessed)

        """
        return _common.ParameterValue_access_count(self)


    def change_count(self):
        """

        Return change count (number of times parameter has been changed)

        """
        return _common.ParameterValue_change_count(self)


    def set_range(self, *args):
        """

        **Overloaded versions**

        * set_range\ (min_value, max_value)

          Set range for int-valued parameter

        * set_range\ (min_value, max_value)

          Set range for double-valued parameter

        * set_range\ (range)

          Set range for string-valued parameter

        """
        return _common.ParameterValue_set_range(self, *args)


    def _get_int_range(self):
        """

        **Overloaded versions**

        * get_range\ (min_value, max_value)

          Get range for int-valued parameter

        * get_range\ (min_value, max_value)

          Get range for double-valued parameter

        * get_range\ (range)

          Get range for string-valued parameter

        """
        return _common.ParameterValue__get_int_range(self)


    def _get_double_range(self):
        """

        **Overloaded versions**

        * get_range\ (min_value, max_value)

          Get range for int-valued parameter

        * get_range\ (min_value, max_value)

          Get range for double-valued parameter

        * get_range\ (range)

          Get range for string-valued parameter

        """
        return _common.ParameterValue__get_double_range(self)


    def _get_string_range(self):
        """

        **Overloaded versions**

        * get_range\ (min_value, max_value)

          Get range for int-valued parameter

        * get_range\ (min_value, max_value)

          Get range for double-valued parameter

        * get_range\ (range)

          Get range for string-valued parameter

        """
        return _common.ParameterValue__get_string_range(self)


    def _assign(self, *args):
        """

        **Overloaded versions**

        * operator=\ (value)

          Assignment from int

        * operator=\ (value)

          Assignment from double

        * operator=\ (value)

          Assignment from string

        * operator=\ (value)

          Assignment from string

        * operator=\ (value)

          Assignment from bool

        """
        return _common.ParameterValue__assign(self, *args)


    def _assign_bool(self, value):
        """

        **Overloaded versions**

        * operator=\ (value)

          Assignment from int

        * operator=\ (value)

          Assignment from double

        * operator=\ (value)

          Assignment from string

        * operator=\ (value)

          Assignment from string

        * operator=\ (value)

          Assignment from bool

        """
        return _common.ParameterValue__assign_bool(self, value)


    def __int__(self):
        """

        Cast parameter to int

        """
        return _common.ParameterValue___int__(self)


    def __float__(self):
        """

        Cast parameter to double

        """
        return _common.ParameterValue___float__(self)


    def __str__(self):
        """

        Cast parameter to string

        """
        return _common.ParameterValue___str__(self)


    def __nonzero__(self):
        return _common.ParameterValue___nonzero__(self)
    __bool__ = __nonzero__



    def type_str(self):
        """

        Return value type string

        """
        return _common.ParameterValue_type_str(self)


    def value_str(self):
        """

        Return value string

        """
        return _common.ParameterValue_value_str(self)


    def range_str(self):
        """

        Return range string

        """
        return _common.ParameterValue_range_str(self)


    def str(self):
        """

        Return short string description

        """
        return _common.ParameterValue_str(self)

    check_key = staticmethod(_common.ParameterValue_check_key)

    def warn_once(self, msg):
        cls = self.__class__
        if not hasattr(cls, '_warned'):
            cls._warned = set()
        if not msg in cls._warned:
            cls._warned.add(msg)
            print(msg)

    def value(self):
        val_type = self.type_str()
        if val_type == "string":
            return str(self)
        elif  val_type == "int":
            return int(self)
        elif val_type == "bool":
            return bool(self)
        elif val_type == "double":
            return float(self)
        else:
            raise TypeError("unknown value type '%s' of parameter '%s'"%(val_type, self.key()))

    def get_range(self):
        val_type = self.type_str()
        if val_type == "string":
            local_range = self._get_string_range()
            if len(local_range) == 0:
                return
            return local_range
        elif  val_type == "int":
            local_range = self._get_int_range()
            if local_range[0] == 0 and local_range[0] == local_range[0]:
                return
            return local_range
        elif val_type == "bool":
            return
        elif val_type == "double":
            from logging import DEBUG
            local_range = self._get_double_range()
            if local_range[0] == 0 and local_range[0] == local_range[0]:
                return
            return local_range
        else:
            raise TypeError("unknown value type '%s' of parameter '%s'"%(val_type, self.key()))

    def data(self):
        return self.value(), self.get_range(), self.access_count(), self.change_count()

ParameterValue.key = new_instancemethod(_common.ParameterValue_key, None, ParameterValue)
ParameterValue.description = new_instancemethod(_common.ParameterValue_description, None, ParameterValue)
ParameterValue.is_set = new_instancemethod(_common.ParameterValue_is_set, None, ParameterValue)
ParameterValue.reset = new_instancemethod(_common.ParameterValue_reset, None, ParameterValue)
ParameterValue.access_count = new_instancemethod(_common.ParameterValue_access_count, None, ParameterValue)
ParameterValue.change_count = new_instancemethod(_common.ParameterValue_change_count, None, ParameterValue)
ParameterValue.set_range = new_instancemethod(_common.ParameterValue_set_range, None, ParameterValue)
ParameterValue._get_int_range = new_instancemethod(_common.ParameterValue__get_int_range, None, ParameterValue)
ParameterValue._get_double_range = new_instancemethod(_common.ParameterValue__get_double_range, None, ParameterValue)
ParameterValue._get_string_range = new_instancemethod(_common.ParameterValue__get_string_range, None, ParameterValue)
ParameterValue._assign = new_instancemethod(_common.ParameterValue__assign, None, ParameterValue)
ParameterValue._assign_bool = new_instancemethod(_common.ParameterValue__assign_bool, None, ParameterValue)
ParameterValue.__int__ = new_instancemethod(_common.ParameterValue___int__, None, ParameterValue)
ParameterValue.__float__ = new_instancemethod(_common.ParameterValue___float__, None, ParameterValue)
ParameterValue.__str__ = new_instancemethod(_common.ParameterValue___str__, None, ParameterValue)
ParameterValue.type_str = new_instancemethod(_common.ParameterValue_type_str, None, ParameterValue)
ParameterValue.value_str = new_instancemethod(_common.ParameterValue_value_str, None, ParameterValue)
ParameterValue.range_str = new_instancemethod(_common.ParameterValue_range_str, None, ParameterValue)
ParameterValue.str = new_instancemethod(_common.ParameterValue_str, None, ParameterValue)
ParameterValue_swigregister = _common.ParameterValue_swigregister
ParameterValue_swigregister(ParameterValue)

def ParameterValue_check_key(key):
    return _common.ParameterValue_check_key(key)
ParameterValue_check_key = _common.ParameterValue_check_key

class IntParameter(ParameterValue):
    """

    Parameter with value type int

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * IntParameter\ (key)

          Create unset int-valued

        * IntParameter\ (key, value)

          Create int-valued parameter

        """
        _common.IntParameter_swiginit(self, _common.new_IntParameter(*args))
    __swig_destroy__ = _common.delete_IntParameter

    def _assign(self, value):
        """

        Assignment

        """
        return _common.IntParameter__assign(self, value)

IntParameter._assign = new_instancemethod(_common.IntParameter__assign, None, IntParameter)
IntParameter_swigregister = _common.IntParameter_swigregister
IntParameter_swigregister(IntParameter)

class DoubleParameter(ParameterValue):
    """

    Parameter with value type double

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * DoubleParameter\ (key)

          Create unset double-valued parameter

        * DoubleParameter\ (key, value)

          Create double-valued parameter

        """
        _common.DoubleParameter_swiginit(self, _common.new_DoubleParameter(*args))
    __swig_destroy__ = _common.delete_DoubleParameter

    def _assign(self, value):
        """

        Assignment

        """
        return _common.DoubleParameter__assign(self, value)

DoubleParameter._assign = new_instancemethod(_common.DoubleParameter__assign, None, DoubleParameter)
DoubleParameter_swigregister = _common.DoubleParameter_swigregister
DoubleParameter_swigregister(DoubleParameter)

class StringParameter(ParameterValue):
    """

    Parameter with value type string

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * StringParameter\ (key)

          Create unset string-valued parameter

        * StringParameter\ (key, value)

          Create string-valued parameter

        """
        _common.StringParameter_swiginit(self, _common.new_StringParameter(*args))
    __swig_destroy__ = _common.delete_StringParameter

    def _assign(self, *args):
        """

        **Overloaded versions**

        * operator=\ (value)

          Assignment

        * operator=\ (value)

          Assignment

        """
        return _common.StringParameter__assign(self, *args)

StringParameter._assign = new_instancemethod(_common.StringParameter__assign, None, StringParameter)
StringParameter_swigregister = _common.StringParameter_swigregister
StringParameter_swigregister(StringParameter)

class BoolParameter(ParameterValue):
    """

    Parameter with value type bool

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * BoolParameter\ (key)

          Create unset bool-valued parameter

        * BoolParameter\ (key, value)

          Create bool-valued parameter

        """
        _common.BoolParameter_swiginit(self, _common.new_BoolParameter(*args))
    __swig_destroy__ = _common.delete_BoolParameter

    def _assign_bool(self, value):
        """

        Assignment

        """
        return _common.BoolParameter__assign_bool(self, value)

BoolParameter._assign_bool = new_instancemethod(_common.BoolParameter__assign_bool, None, BoolParameter)
BoolParameter_swigregister = _common.BoolParameter_swigregister
BoolParameter_swigregister(BoolParameter)

class Parameters(object):
    """

    This class stores a set of parameters. Each parameter is
    identified by a unique string (the key) and a value of some
    given value type. Parameter sets can be nested at arbitrary
    depths.

    A parameter may be either int, double, string or boolean valued.

    Parameters may be added as follows:

      Parameters p("my_parameters");
      p.add("relative_tolerance",  1e-15);
      p.add("absolute_tolerance",  1e-15);
      p.add("gmres_restart",       30);
      p.add("monitor_convergence", false);

    Parameters may be changed as follows:

      p["gmres_restart"] = 50;

    Parameter values may be retrieved as follows:

      int gmres_restart = p["gmres_restart"];

    Parameter sets may be nested as follows:

      Parameters q("nested_parameters");
      p.add(q);

    Nested parameters may then be accessed by

      p("nested_parameters")["..."]

    Parameters may be nested at arbitrary depths.

    Parameters may be parsed from the command-line as follows:

      p.parse(argc, argv);

    Note: spaces in parameter keys are not allowed (to simplify
    usage from command-line).

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_Parameters

    def __init__(self, *args):
        """

        **Overloaded versions**

        * Parameters\ ("parameters")

          Create empty parameter set

        * Parameters\ (parameters)

          Copy constructor

        """
        _common.Parameters_swiginit(self, _common.new_Parameters(*args))

    def name(self):
        """

        Return name for parameter set

        """
        return _common.Parameters_name(self)


    def rename(self, key):
        """

        Rename parameter set

        """
        return _common.Parameters_rename(self, key)


    def clear(self):
        """

        Clear parameter set

        """
        return _common.Parameters_clear(self)


    def _add_bool(self, key, value):
        """

        **Overloaded versions**

        * add\ (key)

          Add an unset parameter of type T. For example, to create a
          unset parameter of type bool, do
          parameters.add<bool>("my_setting")

        * add\ (key, min, max)

          Add an unset parameter of type T with allows parameters. For
          example, to create a unset parameter of type bool, do
          parameters.add<bool>("my_setting")

        * add\ (key, valid_values)

          Add an unset parameter of type T with allows parameters. For
          example, to create a unset parameter of type bool, do
          parameters.add<bool>("my_setting")

        * add\ (key, value)

          Add int-valued parameter

        * add\ (key, value, min_value, max_value)

          Add int-valued parameter with given range

        * add\ (key, value)

          Add double-valued parameter

        * add\ (key, value, min_value, max_value)

          Add double-valued parameter with given range

        * add\ (key, value)

          Add string-valued parameter

        * add\ (key, value)

          Add string-valued parameter

        * add\ (key, value, range)

          Add string-valued parameter with given range

        * add\ (key, value, range)

          Add string-valued parameter with given range

        * add\ (key, value)

          Add bool-valued parameter

        * add\ (parameters)

          Add nested parameter set

        """
        return _common.Parameters__add_bool(self, key, value)


    def _add(self, *args):
        """

        **Overloaded versions**

        * add\ (key)

          Add an unset parameter of type T. For example, to create a
          unset parameter of type bool, do
          parameters.add<bool>("my_setting")

        * add\ (key, min, max)

          Add an unset parameter of type T with allows parameters. For
          example, to create a unset parameter of type bool, do
          parameters.add<bool>("my_setting")

        * add\ (key, valid_values)

          Add an unset parameter of type T with allows parameters. For
          example, to create a unset parameter of type bool, do
          parameters.add<bool>("my_setting")

        * add\ (key, value)

          Add int-valued parameter

        * add\ (key, value, min_value, max_value)

          Add int-valued parameter with given range

        * add\ (key, value)

          Add double-valued parameter

        * add\ (key, value, min_value, max_value)

          Add double-valued parameter with given range

        * add\ (key, value)

          Add string-valued parameter

        * add\ (key, value)

          Add string-valued parameter

        * add\ (key, value, range)

          Add string-valued parameter with given range

        * add\ (key, value, range)

          Add string-valued parameter with given range

        * add\ (key, value)

          Add bool-valued parameter

        * add\ (parameters)

          Add nested parameter set

        """
        return _common.Parameters__add(self, *args)


    def remove(self, key):
        """

        Remove parameter or parameter set with given key

        """
        return _common.Parameters_remove(self, key)


    def _get_parameter(self, *args):
        """

        **Overloaded versions**

        * operator[]\ (key)

          Return parameter for given key

        * operator[]\ (key)

          Return parameter for given key (const version)

        """
        return _common.Parameters__get_parameter(self, *args)


    def assign(self, parameters):
        """

        Assignment operator

        """
        return _common.Parameters_assign(self, parameters)


    def has_key(self, key):
        """

        Check if parameter set has key (parameter or nested parameter set)

        """
        return _common.Parameters_has_key(self, key)


    def has_parameter(self, key):
        """

        Check if parameter set has given parameter

        """
        return _common.Parameters_has_parameter(self, key)


    def has_parameter_set(self, key):
        """

        Check if parameter set has given nested parameter set

        """
        return _common.Parameters_has_parameter_set(self, key)


    def _get_parameter_keys(self):
        """

        Return a vector of parameter keys

        """
        return _common.Parameters__get_parameter_keys(self)


    def _get_parameter_set_keys(self):
        """

        Return a vector of parameter set keys

        """
        return _common.Parameters__get_parameter_set_keys(self)


    def str(self, verbose):
        """

        Return informal string representation (pretty-print)

        """
        return _common.Parameters_str(self, verbose)


    def _parse(self, op):
        """Missing docstring"""
        return _common.Parameters__parse(self, op)



    def add(self,*args):
        """Add a parameter to the parameter set"""
        if len(args) == 2 and isinstance(args[1],bool):
            self._add_bool(*args)
        else:
            self._add(*args)

    def parse(self,argv=None):
        "Parse command line arguments"
        if argv is None:
            import sys
            argv = sys.argv
        self._parse(argv)

    def keys(self):
        "Returns a list of the parameter keys"
        ret = self._get_parameter_keys()
        ret += self._get_parameter_set_keys()
        return ret

    def iterkeys(self):
        "Returns an iterator for the parameter keys"
        for key in self.keys():
            yield key

    def __iter__(self):
        return self.iterkeys()

    def values(self):
        "Returns a list of the parameter values"
        return [self[key] for key in self.keys()]

    def itervalues(self):
        "Returns an iterator to the parameter values"
        return (self[key] for key in self.keys())

    def items(self):
        return zip(self.keys(),self.values())

    def iteritems(self):
        "Returns an iterator over the (key, value) items of the Parameters"
        return iter(self.items())

    def set_range(self, key, *arg):
        "Set the range for the given parameter"
        if key not in self._get_parameter_keys():
            raise KeyError("no parameter with name '%s'"%key)
        self._get_parameter(key).set_range(*arg)

    def get_range(self, key):
        "Get the range for the given parameter"
        if key not in self._get_parameter_keys():
            raise KeyError("no parameter with name '%s'"%key)
        return self._get_parameter(key).get_range()

    def __getitem__(self, key):
        "Return the parameter corresponding to the given key"
        if key in self._get_parameter_keys():
            return self._get_parameter(key).value()

        if key in self._get_parameter_set_keys():
            return self._get_parameter_set(key)

        raise KeyError("'%s'"%key)

    def __setitem__(self, key, value):
        "Set the parameter 'key', with given 'value'"
        if (key == "this") and type(value).__name__ == 'SwigPyObject':
            self.__dict__[key] = value
            return
        if key not in self._get_parameter_keys():
            raise KeyError("'%s' is not a parameter"%key)
        if not isinstance(value,(int,str,float,bool)):
            raise TypeError("can only set 'int', 'bool', 'float' and 'str' parameters")
        par = self._get_parameter(key)
        if isinstance(value,bool):
            par._assign_bool(value)
        else:
            par._assign(value)

    def update(self, other):
        "A recursive update that handles parameter subsets correctly."
        if not isinstance(other,(Parameters, dict)):
            raise TypeError("expected a 'dict' or a '%s'"%Parameters.__name__)
        for key, other_value in other.items():
            self_value  = self[key]
            if isinstance(self_value, Parameters):
                self_value.update(other_value)
            else:
                setattr(self, key, other_value)

    def to_dict(self):
        """Convert the Parameters to a dict"""
        ret = {}
        for key, value in self.items():
            if isinstance(value, Parameters):
                ret[key] = value.to_dict()
            else:
                ret[key] = value
        return ret

    def copy(self):
        "Return a copy of it self"
        return Parameters(self)

    def option_string(self):
        "Return an option string representation of the Parameters"
        def option_list(parent,basename):
            ret_list = []
            for key, value in parent.items():
                if isinstance(value, Parameters):
                    ret_list.extend(option_list(value,basename + key + '.'))
                else:
                    ret_list.append(basename + key + " " + str(value))
            return ret_list

        return " ".join(option_list(self,"--"))

    def __str__(self):
        "p.__str__() <==> str(x)"
        return self.str(False)

    __getattr__ = __getitem__
    __setattr__ = __setitem__

    def iterdata(self):
        """Returns an iterator of a tuple of a parameter key together with its value"""
        for key in self.iterkeys():
            yield key, self.get(key)

    def get(self, key):
        """Return all data available for a certain parameter

        The data is returned in a tuple:
        value, range, access_count, change_count = parameters.get('name')
        """
        if key in self._get_parameter_keys():
            return self._get_parameter(key).data()

        if key in self._get_parameter_set_keys():
            return self._get_parameter_set(key)

        raise KeyError("'%s'"%key)


Parameters.name = new_instancemethod(_common.Parameters_name, None, Parameters)
Parameters.rename = new_instancemethod(_common.Parameters_rename, None, Parameters)
Parameters.clear = new_instancemethod(_common.Parameters_clear, None, Parameters)
Parameters._add_bool = new_instancemethod(_common.Parameters__add_bool, None, Parameters)
Parameters._add = new_instancemethod(_common.Parameters__add, None, Parameters)
Parameters.remove = new_instancemethod(_common.Parameters_remove, None, Parameters)
Parameters._get_parameter = new_instancemethod(_common.Parameters__get_parameter, None, Parameters)
Parameters._get_parameter_set = new_instancemethod(_common.Parameters__get_parameter_set, None, Parameters)
Parameters.assign = new_instancemethod(_common.Parameters_assign, None, Parameters)
Parameters.has_key = new_instancemethod(_common.Parameters_has_key, None, Parameters)
Parameters.has_parameter = new_instancemethod(_common.Parameters_has_parameter, None, Parameters)
Parameters.has_parameter_set = new_instancemethod(_common.Parameters_has_parameter_set, None, Parameters)
Parameters._get_parameter_keys = new_instancemethod(_common.Parameters__get_parameter_keys, None, Parameters)
Parameters._get_parameter_set_keys = new_instancemethod(_common.Parameters__get_parameter_set_keys, None, Parameters)
Parameters.str = new_instancemethod(_common.Parameters_str, None, Parameters)
Parameters.find_parameter = new_instancemethod(_common.Parameters_find_parameter, None, Parameters)
Parameters.find_parameter_set = new_instancemethod(_common.Parameters_find_parameter_set, None, Parameters)
Parameters._parse = new_instancemethod(_common.Parameters__parse, None, Parameters)
Parameters_swigregister = _common.Parameters_swigregister
Parameters_swigregister(Parameters)

class GlobalParameters(Parameters):
    """

    This class defines the global DOLFIN parameter database.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """

        Constructor

        """
        _common.GlobalParameters_swiginit(self, _common.new_GlobalParameters())
    __swig_destroy__ = _common.delete_GlobalParameters

    def default_parameters():
        """

        Default parameter values

        """
        return _common.GlobalParameters_default_parameters()

    default_parameters = staticmethod(default_parameters)
GlobalParameters_swigregister = _common.GlobalParameters_swigregister
GlobalParameters_swigregister(GlobalParameters)
cvar = _common.cvar

def GlobalParameters_default_parameters():
    """

    Default parameter values

    """
    return _common.GlobalParameters_default_parameters()


old_init = Parameters.__init__
def __new_Parameter_init__(self,*args,**kwargs):
    """Initialize Parameters

    Usage:

    Parameters()
       create empty parameter set

    Parameters(name)
       create empty parameter set with given name

    Parameters(other_parameters)
       create copy of parameter set

    Parameters(name, dim=3, tol=0.1, foo="Foo")
       create parameter set with given parameters

    Parameters(name, dim=(3, 0, 4), foo=("Foo", ["Foo", "Bar"])
       create parameter set with given parameters and ranges
    """

    if len(args) == 0:
        old_init(self, "parameters")
    elif len(args) == 1 and isinstance(args[0], (str,type(self))):
        old_init(self, args[0])
    else:
        raise TypeError("expected a single optional argument of type 'str' or ''"%type(self).__name__)
    if len(kwargs) == 0:
        return

    from numpy import isscalar
    from six import iteritems
    for key, value in iteritems(kwargs):
        if isinstance(value,type(self)):
            self.add(value)
        elif isinstance(value,tuple):
            if isscalar(value[0]) and len(value) == 3:
                self.add(key, *value)
            elif isinstance(value[0], str) and len(value) == 2:
                if not isinstance(value[1], list):
                    raise TypeError("expected a list as second item of tuple, when first is a 'str'")
                self.add(key, *value)
            else:
                raise TypeError("expected a range tuple of size 2 for 'str' values and 3 for scalars")
        else:
            self.add(key,value)

Parameters.__init__ = __new_Parameter_init__



def get_global_parameters():
    return _common.get_global_parameters()
get_global_parameters = _common.get_global_parameters

def _info(msg):
    """

    **Overloaded versions**

    * info\ (msg, ...)

      The DOLFIN log system provides the following set of functions for
      uniform handling of log messages, warnings and errors. In addition,
      macros are provided for debug messages and dolfin_assertions.

      Only messages with a debug level higher than or equal to the current
      log level are printed (the default being zero). Logging may also be
      turned off by calling set_log_active(false).
      Print message

    * info\ (parameters, verbose=false)

      Print parameter (using output of str() method)

    * info\ (variable, verbose=false)

      Print variable (using output of str() method)

    """
    return _common._info(msg)

def info_stream(out, msg):
    """

    Print message to stream

    """
    return _common.info_stream(out, msg)

def info_underline(msg):
    """

    Print underlined message

    """
    return _common.info_underline(msg)

def warning(msg):
    """

    Print warning

    """
    return _common.warning(msg)

def error(msg):
    """

    Print error message and throw an exception.
    Note to developers: this function should not be used internally
    in DOLFIN. Use the more informative dolfin_error instead.

    """
    return _common.error(msg)

def dolfin_error(location, task, reason):
    """

    Print error message. Prefer this to the above generic error message.

    *Arguments*
        location (str)
            Name of the file from which the error message was generated.
        task (str)
            Name of the task that failed.
            Note that this string should begin with lowercase.
            Note that this string should not be punctuated.
        reason (str)
            A format string explaining the reason for the failure.
            Note that this string should begin with uppercase.
            Note that this string should not be punctuated.
            Note that this string may contain printf style formatting.
        ... (primitive types like int, std::size_t, double, bool)
            Optional arguments for the format string.

    Developers should read the file dolfin/log/README in the DOLFIN
    source tree for further notes about the use of this function.

    """
    return _common.dolfin_error(location, task, reason)

def deprecation(feature, version_deprecated, version_remove, message):
    """

    Issue deprecation warning for removed feature

    *Arguments*
        feature (str)
           Name of the feature that has been removed.
        version_deprecated (str)
           Version number of the release in which the feature is deprecated.
        version_remove (str)
           Version number of the release in which the feature will be removed.
        message (str)
           A format string explaining the deprecation.

    """
    return _common.deprecation(feature, version_deprecated, version_remove, message)

def log(debug_level, msg):
    """

    Print message at given debug level

    """
    return _common.log(debug_level, msg)

def begin(*args):
    """

    **Overloaded versions**

    * begin\ (msg, ...)

      Begin task (increase indentation level)

    * begin\ (debug_level, msg, ...)

      Begin task (increase indentation level)

    """
    return _common.begin(*args)

def end():
    """

    End task (decrease indentation level)

    """
    return _common.end()

def set_log_active(active=True):
    """

    Turn logging on or off

    """
    return _common.set_log_active(active)

def set_log_level(level):
    """

    Set log level

    """
    return _common.set_log_level(level)

def set_output_stream(out):
    """

    Set output stream

    """
    return _common.set_output_stream(out)

def get_log_level():
    """

    Get log level

    """
    return _common.get_log_level()

def monitor_memory_usage():
    """

    Monitor memory usage. Call this function at the start of a
    program to continuously monitor the memory usage of the process.

    """
    return _common.monitor_memory_usage()

def not_working_in_parallel(what):
    """

    Report that functionality has not (yet) been implemented to work
    in parallel

    """
    return _common.not_working_in_parallel(what)

def __debug(file, line, function, format):
    return _common.__debug(file, line, function, format)
__debug = _common.__debug

def __dolfin_assert(file, line, function, check):
    return _common.__dolfin_assert(file, line, function, check)
__dolfin_assert = _common.__dolfin_assert
class Event(object):
    """

    A event is a string message which is displayed
    only a limited number of times.

    *Example*
        .. code-block:: python

            >>> event = dolfin.Event("System is stiff, damping is needed.", 3)
            >>> for i in range(10):
            ...     if i > 7:
            ...         print i
            ...         event()

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, msg, maxcount=1):
        """

        Constructor

        """
        _common.Event_swiginit(self, _common.new_Event(msg, maxcount))
    __swig_destroy__ = _common.delete_Event

    def count(self):
        """

        Display count

        """
        return _common.Event_count(self)


    def maxcount(self):
        """

        Maximum display count

        """
        return _common.Event_maxcount(self)

Event.__call__ = new_instancemethod(_common.Event___call__, None, Event)
Event.count = new_instancemethod(_common.Event_count, None, Event)
Event.maxcount = new_instancemethod(_common.Event_maxcount, None, Event)
Event_swigregister = _common.Event_swigregister
Event_swigregister(Event)

class Progress(object):
    """

    This class provides a simple way to create and update progress
    bars during a computation.

    *Example*
        A progress bar may be used either in an iteration with a known number
        of steps:

        .. code-block:: python

            >>> n = 1000000
            >>> p = dolfin.Progress("Iterating...", n)
            >>> for i in range(n):
            ...     p += 1

        or in an iteration with an unknown number of steps:

        .. code-block:: python

            >>> pr = dolfin.Progress("Iterating")
            >>> t = 0.0
            >>> n = 1000000.0
            >>> while t < n:
            ...     t += 1.0
            ...     p += t/n

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        **Overloaded versions**

        * Progress\ (title, n)

          Create progress bar with a known number of steps

          *Arguments*
              title (str)
                  The title.
              n (int)
                  Number of steps.

        * Progress\ (title)

          Create progress bar with an unknown number of steps

          *Arguments*
              title (str)
                  The title.

        """
        _common.Progress_swiginit(self, _common.new_Progress(*args))
    __swig_destroy__ = _common.delete_Progress

    def _add(self, incr):
        """Missing docstring"""
        return _common.Progress__add(self, incr)


    def _set(self, value):
        """Missing docstring"""
        return _common.Progress__set(self, value)


    def __iadd__(self, other):
        if isinstance(other, int):
            self._add(other)
        elif isinstance(other, float):
            self._set(other)
        return self

    def update(self, other):
        "Update the progress with given number"
        if isinstance(other, float):
            self._set(other)

Progress._add = new_instancemethod(_common.Progress__add, None, Progress)
Progress._set = new_instancemethod(_common.Progress__set, None, Progress)
Progress_swigregister = _common.Progress_swigregister
Progress_swigregister(Progress)

class Table(Variable):
    """

    This class provides storage and pretty-printing for tables.
    Example usage:

      Table table("Timings");

      table("Eigen",  "Assemble") = 0.010;
      table("Eigen",  "Solve")    = 0.020;
      table("PETSc",  "Assemble") = 0.011;
      table("PETSc",  "Solve")    = 0.019;
      table("Tpetra", "Assemble") = 0.012;
      table("Tpetra", "Solve")    = 0.018;

      info(table);

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        Create empty table

        """
        _common.Table_swiginit(self, _common.new_Table(*args))
    __swig_destroy__ = _common.delete_Table

    def set(self, *args):
        """

        **Overloaded versions**

        * set\ (row, col, value)

          Set value of table entry

        * set\ (row, col, value)

          Set value of table entry

        * set\ (row, col, value)

          Set value of table entry

        * set\ (row, col, value)

          Set value of table entry

        """
        return _common.Table_set(self, *args)


    def get(self, row, col):
        """

        Get value of table entry

        """
        return _common.Table_get(self, row, col)


    def get_value(self, row, col):
        """

        Get value of table entry

        """
        return _common.Table_get_value(self, row, col)


    def str_latex(self):
        """

        Return informal string representation for LaTeX

        """
        return _common.Table_str_latex(self)

Table.__call__ = new_instancemethod(_common.Table___call__, None, Table)
Table.set = new_instancemethod(_common.Table_set, None, Table)
Table.get = new_instancemethod(_common.Table_get, None, Table)
Table.get_value = new_instancemethod(_common.Table_get_value, None, Table)
Table.str_latex = new_instancemethod(_common.Table_str_latex, None, Table)
Table_swigregister = _common.Table_swigregister
Table_swigregister(Table)

class TableEntry(object):
    """

    This class represents an entry in a Table

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, row, col, table):
        """

        Create table entry

        """
        _common.TableEntry_swiginit(self, _common.new_TableEntry(row, col, table))
    __swig_destroy__ = _common.delete_TableEntry
TableEntry_swigregister = _common.TableEntry_swigregister
TableEntry_swigregister(TableEntry)


_common.CRITICAL_swigconstant(_common)
CRITICAL = _common.CRITICAL

_common.ERROR_swigconstant(_common)
ERROR = _common.ERROR

_common.WARNING_swigconstant(_common)
WARNING = _common.WARNING

_common.INFO_swigconstant(_common)
INFO = _common.INFO

_common.PROGRESS_swigconstant(_common)
PROGRESS = _common.PROGRESS

_common.TRACE_swigconstant(_common)
TRACE = _common.TRACE

_common.DBG_swigconstant(_common)
DBG = _common.DBG

def debug(message):
    import traceback
    file, line, func, txt = traceback.extract_stack(None, 2)[0]
    __debug(file, line, func, message)

def info(object, verbose=False):
    """Print string or object.

    *Arguments*
        object
            A string or a DOLFIN object (:py:class:`Variable <dolfin.cpp.Variable>`
            or :py:class:`Parameters <dolfin.cpp.Parameters>`)
        verbose
            An optional argument that indicates whether verbose object data
            should be printed. If False, a short one-line summary is printed.
            If True, verbose and sometimes very exhaustive object data are
            printed.
    """

    if isinstance(object, (Variable, Parameters)):
        _info(object.str(verbose))
    else:
        _info(object)



